// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	'use strict';

	var resolve, getRequire, wmRequire, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]}
	  , envRequire = typeof require === 'function' ? require : null;

	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullPath, state, id) {
		var name, dir, exports, module, fn, found, ext;
		path = path.split('/');
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null) {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
				id = id.slice(0, id.lastIndexOf('/'));
			} else {
				tree.push(scope);
				scope = scope[dir];
				id += '/' + dir;
			}
			if (!scope) throw notFoundError(fullPath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				id += '/' + name;
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullPath, 1, id);
			}
			return resolve(scope, tree, 'index', fullPath, 2, id);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullPath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports, id: id + '/' + name };
		fn.call(exports, exports, module, getRequire(scope, tree, id));
		return module.exports;
	};
	wmRequire = function (scope, tree, fullPath, id) {
		var name, path = fullPath, t = fullPath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = '/';
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = name;
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullPath, state, id);
	};
	getRequire = function (scope, tree, id) {
		return function (path) {
			return wmRequire(scope, [].concat(tree), path, id);
		};
	};
	return getRequire(modules, [], '');
})({
	"workspace": {
		"editor": {
			"js": {
				"editor": {
					"src": {
						"util": {
							"content.js": function (exports, module, require) {
								/**
								 * Created on 2/18/2017.
								 */
								(function ( $ ) {
									module.exports = {

										TCB_CLS_PAT: ['thrv_', 'tve-', 'tve_', 'tcb_', 'tcb-', 'thrv-', 'img_style_', 'mce-', 'fr-'],

										/**
										 * Cleanup content in preparation for save
										 * @param options
										 * @param $root
										 */
										get_clean_content: function ( options, $root ) {
											if ( typeof options === 'undefined' ) {
												options = {};
											}
											$root = $root || TVE.Editor_Page.editor;
											var $filter = $( '#pre-save-filter' );
											if ( ! $filter.length ) {
												$filter = $( '<div style="display:none" id="pre-save-filter"></div>' ).appendTo( 'body' );
											}
											$filter.empty();

											var $target = $root.children( '.tve_content_save' ).length ? $root.children( '.tve_content_save' ) : $root;
											$filter.html( $target.html() );
											if ( ! options.keep_wp_shortcodes ) {
												$filter.find( '.tve_shortcode_rendered' ).remove();
											}

											$filter.find( '.ui-resizable-handle, .ui-resize-left, .ui-resize-right, .thrive-shortcode-html,grammarly-btn,' +
											              '.tve_custom_html_placeholder,.tve_dropzone,.rangySelectionBoundary, .tve_shortcode_overlay,' +
											              '.tve_shortcode_rendered script, .tcb-remove-on-save, .tve_post_grid_wrapper,.tve_widget_container,' +
											              '.gr-textarea-btn_status,.gr-textarea-btn, .tve-remove-auxiliary-content' ).remove()
												.end().find( '.canvas-mode, .tve-element-overlay, .edit_mode, .tve_merge_cells, .tve_merge_selected, .tve_active_hyperlink, .active_highlight, .active_delete, .active_duplicate' ).removeClass( 'edit_mode tve_merge_cells tve_merge_selected, tve_active_hyperlink active_highlight active_delete active_duplicatecanvas-mode tve-element-overlay' )
												.end().find( '.tve_faqC' ).hide()
												.end().find( '.tve_oFaq' ).removeClass( 'tve_oFaq' )
												.end().find( '.ui-resizable,.init_done,.ui-sortable,.ui-sortable-handle,.tve-draggable,.tve-droppable' ).removeClass( 'ui-resizable init_done ui-sortable ui-sortable-handle tve-draggable tve_grabbed tve-droppable' )
												.end().find( '[contenteditable]' ).removeAttr( 'contenteditable' )
												.end().find( '[draggable]' ).removeAttr( 'draggable' )
												.end().find( '[data-gramm]' ).removeAttr( 'data-gramm data-gramm_id data-gramm_editor' ).filter( ':empty' ).remove().end()
												.end().find( '.tve-state-hover,.tve-state-active' ).removeClass( 'tve-state-hover' )
												.end().find( 'p' ).each( function () {
												//remove some attributes to let WP correctly do shortcode_unautop()
												if ( typeof this.className !== 'undefined' && this.className.toString().length === 0 ) {
													this.removeAttribute( 'class' );
												}
											} );
											$filter.find( '.tve-froala' ).each( function () {
												var $ed = $( this ),
													$element = $ed.find( '.fr-element' ).last();
												if ( $element.length ) {
													$ed.html( $element.html() ).removeClass( function ( i, className ) {
														return (className.match( /(^|\s)(fr-|tve-froal)\S+/g ) || []).join( ' ' );
													} );
												}
											} );
											$filter.find( '.tve_more_tag' ).replaceWith( '<!--tvemorestart--><p class="tve_more_tag"><span class="tve_no_edit">More...</span></p><!--tvemoreend-->' );

											var html = $filter.html();
											$filter.html( '' );

											return html.split( "\n" ).map( $.trim ).filter( function ( line ) {
												return line !== '';
											} ).join( "\n" );
										},
										/**
										 * function to extract the custom inline rules from the document
										 * @returns {string} - string of css to be saved in db
										 */
										get_stylesheet_rules: function () {
											var myrules = TVE.stylesheet.cssRules ? TVE.stylesheet.cssRules : TVE.stylesheet.rules;
											var inline_rules = '',
												selectors = [],
												selector_text,
												allow_save = ['tve_selected_typist'],
												media_subset = '',
												imported_fonts = [];

											function is_whitelist( selector ) {
												for ( var i = 0, item; item = allow_save[i ++]; ) {
													if ( selector.indexOf( item ) > - 1 ) {
														return true;
													}
												}
												return false;
											}

											function process_rule( rule, media ) {
												media = media || '';
												var text = '', css_text;
												/* :hover selector will not work from JS */
												selector_text = rule.selectorText.replace( /(:hover|:active)/g, '' );
												if ( selectors.indexOf( media + rule.selectorText ) !== - 1 ) {
													return '';
												}

												if ( is_whitelist( selector_text ) || jQuery( selector_text ).length ) { // do not save extra CSS in the head
													css_text = jQuery.trim( rule.cssText.replace( rule.selectorText, '' ).replace( /\{(\s*)\}/g, '' ) );
													if ( ! css_text ) {
														return '';
													}
													text += rule.cssText;
													selectors.push( media + rule.selectorText );
												}

												return text;
											}

											for ( var i = 0, _rule; _rule = myrules[i ++]; ) {

												if ( _rule.type === CSSRule.IMPORT_RULE ) {
													/* Save only fonts that are used  */
													var font = TVE.FontManager.read_font_name( _rule.cssText );
													if ( TVE.FontManager.is_font_used( font ) && typeof imported_fonts[font] === 'undefined' ) {
														imported_fonts[font] = 1;
														inline_rules += _rule.cssText;
													}
													continue;
												}

												if ( _rule.type === CSSRule.MEDIA_RULE ) {
													// recurse into the contained rules
													media_subset = '';
													for ( var j = 0, _sub_rule; _sub_rule = _rule.cssRules[j ++]; ) {
														media_subset += process_rule( _sub_rule, _rule.media.item( 0 ) );
													}
													if ( media_subset ) {
														inline_rules += '@media ' + _rule.media.item( 0 ) + '{' + media_subset + '}';
													}
													continue;
												}
												inline_rules += process_rule( _rule );
											}
											return inline_rules;
										},
										/**
										 * Function that prepares the element to be saved as a user template
										 * Parses the element and strips specific classes out of it.
										 *
										 * @param $element
										 */
										prepare_content_template: function ( $element ) {
											var _remove_template_class = 'edit_mode mce-edit-focus active_delete active_duplicate';

											$element.add( $element.find( '.ui-resizable' ) ).removeClass( 'ui-resizable' );
											$element.find( '.ui-resizable-handle' ).remove();
											TVE.froala.disable( $element );
											TVE.froala.disable( $element.find( TVE.TEXT_ALL ) );

											return jQuery( '<div></div>' ).append( $element.removeClass( _remove_template_class ) ).html();
										},
										/**
										 * Parses an element class list and strips it of certain classes
										 * This function is used to fetch a clean class string for the Style and Template TCB Component
										 *
										 * @param {string} element_classes
										 * @returns {string}
										 */
										parse_element_classes: function ( element_classes ) {
											//TODO: custom_font_classes also exclude this from the list

											var pat = new RegExp( this.TCB_CLS_PAT.join( '([^ ]*)|' ) + '([^ ]*)|' + TVE.thrv_custom_classes.join( '|' ), 'g' );

											return element_classes ? $.trim( element_classes.replace( pat, '' ).replace( '/\S+/g', ' ' ) ) : '';
										},
										get_shotcode_tinymce_content: function () {
											if ( typeof tinymce === 'undefined' || ! tinymce || ! tinymce.activeEditor || tinymce.activeEditor.isHidden() ) {
												// no active editor, fallback to the textarea
												return jQuery( '#tve_tinymce_shortcode' ).val();
											}
											return tinymce.activeEditor.getContent();
										},
										set_shotcode_tinymce_content: function ( editor_content ) {
											if ( typeof tinymce === 'undefined' || ! tinymce || ! tinymce.activeEditor || tinymce.activeEditor.isHidden() ) {
												jQuery( '#tve_tinymce_shortcode' ).val( editor_content );
											} else {
												tinymce.activeEditor.setContent( editor_content );
											}
										},
										/**
										 * convert all script tags inside html to shortcodes that will be converted on display
										 * @param string html
										 */
										convert_script_tags: function ( html ) {
											html = html.replace( '<\\/script', '<\\\\/script' );
											var $html = jQuery( '<div class="tve_escaped_js">' + html + '</div>' );

											if ( $html.find( 'script' ).length === 0 && $html.find( "noscript" ) === 0 ) {
												return $html.html();
											}
											$html.find( 'script' ).each( function () {
												var $script = jQuery( this ),
													_text = '[tcb-script';
												var $replacement = jQuery( '<code class="tve_js_placeholder"></code>' );
												jQuery.each( this.attributes, function () {
													_text += ' ' + this.name + '="' + this.value + '"';
												} );
												_text += ']' + $script.text() + '[/tcb-script]';

												$replacement.text( _text );
												$script.replaceWith( $replacement );
											} );
											$html.find( 'noscript' ).each( function () {
												var $script = jQuery( this ),
													_text = '[tcb-noscript';
												var $replacement = jQuery( '<code class="tve_js_placeholder tve_noscript"></code>' );
												jQuery.each( this.attributes, function () {
													_text += ' ' + this.name + '="' + this.value + '"';
												} );
												_text += ']' + $script.text() + '[/tcb-noscript]';
												$replacement.html( _text );
												$script.replaceWith( $replacement );
											} );
											return $html.html();
										},
										/**
										 * convert all <code>[tcb-script] tags back to <script>
										 * @param html
										 */
										revert_script_tags: function ( html ) {
											if ( ! jQuery.trim( html ) ) {
												return '';
											}
											var $html = jQuery( '<div class="tve_escaped_js">' + html + '</div>' );

											// remove all custom html placeholders
											$html.find( '.tve_custom_html_placeholder,.tve_click' ).remove();
											$html.find( '.tve_shortcode_overlay' ).remove();
											if ( $html.find( 'code.tve_js_placeholder' ).length === 0 ) {
												return jQuery.trim( $html.html() );
											}

											$html.find( 'code.tve_js_placeholder' ).each( function () {
												var $script = jQuery( this ),
													shortcodeRegexp = new RegExp( '^\\[tcb-script([^\\]]*?)\\]([\\s\\S]*?)\\[\/tcb-script\\]$', 'g' ), _text; // jeez

												_text = $script[$script.hasClass( 'tve_noscript' ) ? 'html' : 'text']().replace( shortcodeRegexp, '<script$1>$2</script>' );

												var shortcodeNoscriptRegex = new RegExp( '^\\[tcb-noscript([^\\]]*?)\\]([\\s\\S]*?)\\[\/tcb-noscript\\]$', 'g' ); // jeez
												_text = _text.replace( shortcodeNoscriptRegex, '<noscript$1>$2</noscript>' );
												if ( $script.hasClass( 'tve_noscript' ) ) { // <noscript> tag does not allow innerHTML manipulation
													_text = jQuery( '<textarea>' ).html( _text ).text();
												}
												var $replacement = jQuery( _text );
												$replacement.removeAttr( 'class className' );
												$script.replaceWith( $replacement );
											} );
											return jQuery.trim( $html.html() );
										},
										/**
										 * Prepare the JSON data to be sent to the server on save
										 */
										prepare_save_data: function ( update, extra_data ) {
											var tve_content = this.get_clean_content( {}, this.editor ),
												custom_css_rules = this.get_stylesheet_rules(),
												data = {
													tve_content: tve_content,
													post_id: TVE.CONST.post_id,
													update: update,
													inline_rules: custom_css_rules,
													custom_colours: TVE.CONST.colors.favorites || [],
													tve_custom_css: TVE.Editor_Page.get_custom_css(),
													tve_landing_page: TVE.CONST.landing_page ? TVE.CONST.landing_page : '',
													custom_font_classes: [],
													tve_globals: {},
													tve_global_scripts: TVE.CONST.tve_global_scripts ? TVE.CONST.tve_global_scripts : {},
													has_icons: 0,
													page_events: TVE.CONST.page_events
												};

											data = TVE.apply_filters( 'tcb_save_post_data_before', data );

											if ( TVE.CONST.custom_post_data ) {
												$.each( TVE.CONST.custom_post_data, function ( _key, _value ) {
													data[_key] = _value;
												} );
											}

											TVE.CONST.tve_globals.js_sdk = [];
											TVE.Editor_Page.editor.find( '.thrv_social' ).each( function () {
												TVE.CONST.tve_globals.js_sdk = TVE.CONST.tve_globals.js_sdk.concat( $( this ).tve_social().getRequiredSDKs() );
											} );

											if ( TVE.CONST.social_fb_app_id ) {
												data.social_fb_app_id = TVE.CONST.social_fb_app_id;
											}

											/* Add facebook sdk for comments element */
											if ( TVE.Editor_Page.editor.find( '.tve-fb-comments' ).length > 0 ) {
												if ( TVE.CONST.tve_globals.js_sdk.indexOf( 'fb' ) === - 1 ) {
													TVE.CONST.tve_globals.js_sdk.push( 'fb' );
												}
											}

											/* include the tve_globals meta stuff */
											$.each( TVE.CONST.tve_globals, function ( k, v ) {
												if ( k ) {
													data.tve_globals[k] = v;
												}
											} );

											/* also save each of the custom fonts that are being used */
											if ( custom_font_classes ) {
												$.each( custom_font_classes.split( ' ' ), function ( i, v ) {
													if ( TVE.Editor_Page.editor.find( '.' + v ).length || (TVE.landing_fonts && TVE.landing_fonts.fontUsed( v )) ) {
														data.custom_font_classes.push( v );
													}
												} );
											}
											if ( data.tve_globals.extra_fonts ) {
												$.each( data.tve_globals.extra_fonts, function ( i, font ) {
													if ( TVE.Editor_Page.editor.find( '.' + font.font_class ).length || (TVE.landing_fonts && TVE.landing_fonts.fontUsed( font.font_class )) ) {
														font.ignore = 0;
													} else {
														font.ignore = 1;
													}
												} );
											}

											if ( typeof extra_data !== 'undefined' ) {
												$.each( extra_data, function ( k, v ) {
													data[k] = v;
												} );
											}
											var $all_icons = jQuery( '.tve_sc_icon:not(.tve_sc_text)' ),
												$custom_icons = jQuery();
											data.tve_globals.used_icon_packs = [];
											if ( $all_icons.length ) {
												/* check for custom icon_packs */
												var actually_used = [];
												if ( TVE.CONST.tve_globals.extra_icons ) {
													for ( var i = 0, icon_pack; icon_pack = TVE.CONST.tve_globals.extra_icons[i ++]; ) {
														if ( ! icon_pack.icons || ! icon_pack.icons.length ) {
															continue;
														}
														var $current_icons = $all_icons.filter( '.' + icon_pack.icons.join( ',.' ) );
														if ( $current_icons.length ) {
															data.tve_globals.used_icon_packs.push( icon_pack['font-family'] );
														}
														$custom_icons = $custom_icons.add( $current_icons );
														$current_icons.each( function () {
															actually_used.push( this.dataset.tveIcon );
														} );
														TVE.CONST.tve_globals.extra_icons[i - 1].icons = actually_used;
													}
												}
												/* has regular (main) icon pack only if not all icons from the page are custom icons */
												data.has_icons = $all_icons.length != $custom_icons.length ? 1 : 0;
											}

											var $fb_comments = $( '.tve-fb-comments:visible' );
											if ( $fb_comments.length > 0 ) {
												var $fb_admins = $fb_comments.attr( 'data-fb-moderator-ids' );
												if ( typeof $fb_admins !== 'undefined' && $fb_admins != '' ) {
													data.tve_globals.fb_comment_admins = JSON.stringify( $fb_admins.split( ';' ) );
												}
											}

											if ( $( '.tve_post_grid_masonry' ).length ) {
												data.tve_has_masonry = 1;
											}

											if ( $( '.tve_typefocus' ).length ) {
												data.tve_has_typefocus = 1;
											}

											if ( $( '.tve_wistia_popover:visible' ).length || $( '.tve_ea_thrive_wistia' ).length ) {
												data.tve_has_wistia_popover = 1;
											}

											data = TVE.apply_filters( 'tcb_save_post_data_after', data );

											return data;
										},
										/**
										 * Adds the required CSS to the current page when inserting previously saved templates.
										 * It will replace the [data-tve-custom-colour] with new unique values for each of the elements found in the
										 * $html content
										 * @param {string} css_text
										 * @param {jQuery} $html_content
										 * @param {object} [media_rules] CSS media query rules for the element
										 */
										process_saved_template: function ( css_text, $html_content, media_rules ) {
											$html_content.find( '.edit_mode' ).removeClass( 'edit_mode' );
											if ( $html_content.find( '.tve_sc_icon' ).length && ! jQuery( '#thrive_icon_pack' ).length && TVE.CONST.icon_pack_css ) {
												/* make sure we have the icomoon css file loaded */
												jQuery( '<link id="thrive_icon_pack" rel="stylesheet" type="text/css" href="' + TVE.CONST.icon_pack_css + '">' ).appendTo( 'head' );
											}
											if ( ! jQuery.trim( css_text ) && ! media_rules ) {
												return $html_content;
											}

											function compat_css_id( $elem ) {
												var rand_id = Math.floor( (Math.random() * 100000000) + 1 );
												$elem.attr( 'data-tve-custom-colour', rand_id );
												return rand_id;
											}

											var $container = $html_content.wrapAll( '<div></div>' ).parent();
											css_text = jQuery.trim( css_text );

											if ( css_text ) {
												var css_code = css_text.match( /[^{}]+(?=\})/g ),
													css_selectors = css_text.match( /\[(.*?)\]([^\{]*)/g ),
													existing_map = {},
													max = css_selectors ? css_selectors.length : 0;

												for ( var i = 0; i < max; i ++ ) {
													var _attrCode = css_selectors[i].match( /\[data-tve-custom-colour=([^0-9]{1,1})(\d+)('|")\]/ );
													if ( ! _attrCode || _attrCode.length < 3 ) {
														continue;
													}
													var new_identifier = typeof existing_map['code' + _attrCode[2]] !== 'undefined' ?
															existing_map['code' + _attrCode[2]] :
															compat_css_id( $container.find( '[data-tve-custom-colour="' + _attrCode[2] + '"]' ) ),
														new_selector = css_selectors[i].replace( _attrCode[2], new_identifier );

													TVE.compat.insert_css_rule( new_selector, css_code[i], 0 );
													existing_map['code' + _attrCode[2]] = new_identifier;
												}
											}

											/**
											 * CSS @media queries that need to be added to the page - replace every ID with new ones
											 */
											if ( media_rules ) {
												var id_map = {};
												jQuery.each( media_rules, function ( media, css_text ) {
													var rules = css_text.match( /[^{}]+(?=\})/g ),
														selectors = css_text.match( /\[(.*?)\]([^\{]*)/g );
													if ( ! rules || ! selectors || rules.length !== selectors.length ) {
														return true;
													}
													var media_rule = TVE.CSS_Rule_Cache.media_rule( media ),
														old_id;
													selectors = selectors.map( jQuery.trim );
													rules = rules.map( jQuery.trim );
													for ( var i = 0, current_selector; current_selector = selectors[i]; i ++ ) {
														if ( jQuery.trim( rules[i] ) && current_selector.match( /tve-u-(.[^"]*)/ ) ) {
															old_id = 'tve-u-' + RegExp.$1;
															id_map[old_id] = id_map[old_id] || TVE.CSS_Rule_Cache.generate_id();
															current_selector = current_selector.replace( new RegExp( '(' + old_id + ')', 'g' ), id_map[old_id] );
															media_rule.insertRule( jQuery.trim( current_selector ) + '{' + rules[i] + '}', media_rule.cssRules.length );
														}
													}
												} );
												jQuery.each( id_map, function ( old_selector, new_id ) {
													$container.find( '[data-css="' + old_selector + '"]' ).attr( 'data-css', new_id );
												} );
											}
											if ( $html_content.hasClass( 'thrv_widget_menu' ) ) {
												/**
												 * we need to update the custom colors in the JSON configuration object
												 */
												var _config = TVE.Editor_Page.thriveShrtcodeConfig( $html_content.find( '.thrive-shortcode-config' ), 'widget_menu' ),
													_data = _config.get();
												jQuery.each( [
													'ul_attr',
													'top_link_attr',
													'link_attr',
													'trigger_attr'
												], function ( i, _attr ) {
													if ( _data[_attr] && existing_map['code' + _data[_attr]] ) {
														_data[_attr] = existing_map['code' + _data[_attr]];
													}
												} );
												_config.save( _data );
											}

											TVE.compat.texts( $container );

											return $container.html();
										}
									};
								})( jQuery );
							},
							"font-manager.js": function (exports, module, require) {
								/**
								 * Font Manager
								 */
								module.exports = {

									/**
									 * Google API url
									 */
									_api: 'https://www.googleapis.com/webfonts/v1/webfonts',

									/**
									 * Google Fonts API key
									 */
									_key: 'AIzaSyDJhU1bXm2YTz_c4VpWZrAyspOS37Nn-kI',

									/**
									 * Add import rule for font in head css
									 * @param {string|object} font
									 * @return {int} rule index
									 */
									import_font: function ( font ) {
										if ( typeof font === 'object' ) {
											font = this.generate_link( font );
										}

										return TVE.CSS_Rule_Cache.insertImport( font );
									},

									/**
									 * Get all imported fonts in the head css
									 * @returns {{}}
									 */
									get_imported_fonts: function () {
										var imports = TVE.CSS_Rule_Cache.getImports(),
											fonts = {};

										imports.forEach( function ( font ) {
											fonts.push( this.parse_link( font ) );
										} );

										return fonts
									},
									/**
									 * Generate api url from font object
									 * @param font Object with family/variants/subsets
									 *
									 * @returns {string}
									 */
									generate_link: function ( font ) {
										var apiUrl = [];

										apiUrl.push( '//fonts.googleapis.com/css?family=' );
										apiUrl.push( font.family.replace( / /g, '+' ) );
										apiUrl.push( ':' );
										apiUrl.push( font.variants.join( ',' ) );
										apiUrl.push( '&subset=' );
										apiUrl.push( font.subsets );

										return apiUrl.join( '' );
									},
									parse_link: function ( url ) {
										//TODO: implement functionality - get url as parameter and return object with font family, variants and subsets
										return {};
									},
									/**
									 * Get font name from import url
									 * @param link
									 * @returns string
									 */
									read_font_name: function ( link ) {
										var match = link.match( /family=((\w|\+)*)/ ),
											font = link;

										if ( match.length > 1 ) {
											font = match[1].replace( /\+/g, ' ' );
										}

										return font;
									},
									/**
									 * Check if a font is used in the head css or not.
									 * @param font {string}
									 * @returns {boolean}
									 */
									is_font_used: function ( font ) {
										if ( ! font ) {
											return false;
										}

										/* if the font is send as link, we parse it first */
										if ( font.indexOf( 'fonts.googleapis.com' ) !== - 1 ) {
											font = this.read_font_name( font );
										}

										var re = new RegExp( 'font-family: [\"]?' + font, 'g' ),
											css = TVE.CSS_Rule_Cache.toText( CSSRule.MEDIA_RULE ),
											fontFound = re.test( css );

										/**
										 * If no block elements match the font ( added through head_css )
										 * also look for inline styles ( e.g. for text elements )
										 */
										if ( ! fontFound ) {
											TVE.Editor_Page.editor.find( TVE.TEXT_ALL ).find( 'span[style]' ).each( function () {
												if ( this.style.fontFamily && this.style.fontFamily.replace( /"/g, '' ) === font ) {
													fontFound = true;
													
													return false;
												}
											} );
										}

										return fontFound;
									},
									/**
									 * Get Google Fonts
									 * @returns {Array}
									 */
									get_google_fonts: function () {
										/* try and get google fonts from local storage */
										var fonts = TVE.StorageManager.get( 'tcb_google_fonts' );

										if ( ! fonts || ! fonts.length ) {
											/* if we don't have the fonts in the local storage we get them from the API */
											jQuery.ajax( {
												method: 'GET',
												url: this._api,
												dataType: 'json',
												async: false,
												cache: true,
												data: {key: this._key}
											} ).done( function ( response ) {
												fonts = response.items || [];
											} ).fail( function () {
												fonts = [];
											} );
											/* and save them afterwards  */
											TVE.StorageManager.set( 'tcb_google_fonts', fonts );
										}

										return fonts;
									}
								};
							}
						}
					}
				},
				"main": {
					"_utils.js": function (exports, module, require) {
						(function ( $ ) {

							module.exports = {
								/**
								 *
								 * @param $element
								 * @returns {*}
								 * @private
								 */
								_type: function ( $element ) {
									if ( $element.data( 'tcb-elem-type' ) ) {
										return $element.data( 'tcb-elem-type' );
									}
									var _type = null;
									$.each( TVE.Elements, function ( key, data ) {
										if ( $element.is( data.identifier ) ) {
											_type = key;
											return false;
										}
									} );
									$element.data( 'tcb-elem-type', _type );
									return _type;
								},

								/**
								 * Classes that are used by TCB
								 */
								thrv_custom_classes: [
									'edit_mode',
									'alignleft',
									'aligncenter',
									'alignright',
									'tvealign',
									'init_done', //Countdown & Countdown Evergreen
									'active_delete',
									'active_duplicate',
									'canvas-mode',
									'active_highlight'
								],

								/**
								 * returns the template function or rendered template content for a backbone template
								 *
								 * @param {string} tpl_path path to the template (e.g. dir1/page-loader)
								 * @param {object} [opt] optional. If sent, it will return html content (the rendered template)
								 */
								tpl: function ( tpl_path, opt ) {
									if ( tpl_path.indexOf( 'tve-' ) !== 0 ) {
										tpl_path = 'tve-' + tpl_path;
									}
									var _html = $( 'script#' + tpl_path.replace( /\//g, '-' ) ).html() || '';
									if ( opt ) {
										return _.template( _html )( opt );
									}
									return _.template( _html );
								},

								/**
								 * Check to see if a template exists or not
								 * @param tpl
								 * @returns {boolean}
								 */
								is_tpl: function ( tpl ) {
									if ( tpl.indexOf( 'tve-' ) !== 0 ) {
										tpl = 'tve-' + tpl;
									}

									return $( 'script#' + tpl.replace( /\//g, '-' ) ).length > 0
								},

								/**
								 * 1 REM size in pixels
								 * @returns {Number|*}
								 */
								rem_size: function () {
									if ( ! this.__rem ) {
										this.__rem = parseInt( $( 'html' ).css( 'font-size' ) || 16 );
									}

									return this.__rem;
								},

								/**
								 * Convert unit of measure from px to the specified unit of measure
								 * @param element
								 * @param um
								 * @param context needed for relative conversion - usually it should be
								 * @param style css style that we'll have to get value for
								 */
								convertUM: function ( element, um, context, style ) {
									if ( ! element || ! style ) {
										return false;
									}

									var newUM = TVE.getComputedStyle( element, style );

									if ( ! newUM ) {
										return 0
									}

									var map = {
											'min-width': 'width',
											'max-width': 'width'
										},
										current_um = isNaN( newUM ) ? newUM.replace( /[0-9,.]/g, '' ) : undefined; //read the current UM from css property value

									//todo: maybe we should have another function which transforms units FROM x TO y
									if ( current_um === '%' ) { //if it is % transform it into px
										newUM = parseFloat( newUM ) * TVE.getComputedStyle( context, map[style] || style ) / 100;
									} else if ( current_um === 'em' ) {
										newUM = parseFloat( newUM ) * TVE.getComputedStyle( element, 'font-size' );
									}

									switch ( um ) {
										case 'rem':
											newUM = parseFloat( newUM / this.rem_size() ).toFixed( 3 );
											break;
										case 'em':
											var target = element;
											if ( style === 'fontSize' ) {
												target = element.parentNode;
											}
											newUM = parseFloat( newUM / TVE.getComputedStyle( target, 'fontSize' ) ).toFixed( 3 );
											break;
										case '%':
											newUM = parseFloat( newUM * 100 / TVE.getComputedStyle( context, map[style] || style ) );
											break;
										case 'vw':
											newUM = parseFloat( newUM * 100 / TVE.inner.document.documentElement.clientWidth ).toFixed( 3 );
											break;
										case 'vh':
											newUM = parseFloat( newUM * 100 / (TVE.inner.document.documentElement.clientHeight) );
											break;
										case 'px':
										default:
											newUM = parseFloat( newUM );
											break;
									}

									if ( isNaN( newUM ) ) {
										newUM = 0;
									}

									return newUM;
								},

								/**
								 * Get computed CSS style
								 * @param element
								 * @param style
								 * @param raw
								 * @returns {*}
								 */
								getComputedStyle: function ( element, style, raw ) {

									if ( typeof element === 'undefined' || typeof style === 'undefined' ) {
										return 0;
									}

									if ( element instanceof jQuery || element.jquery ) {
										element = element[0];
									}

									var computed = getComputedStyle( element || document.documentElement )[style];

									if ( raw ) {
										return computed;
									}

									var normal_size_map = {'lineHeight': '1.12em', 'letterSpacing': 0};

									/* treat special cases that don't return numbers */
									if ( computed === 'normal' ) {
										if ( normal_size_map[style] ) {
											computed = normal_size_map[style];
										} else {
											computed = 0;
										}
									} else if ( computed.indexOf( 'none' ) === 0 ) {
										/* if we have none, then it's nothing */
										computed = 0;
									} else if ( computed.indexOf( 'rgb' ) === 0 || computed.indexOf( '%' ) !== - 1 ) {
										/* color picker - leave it as it is */
										/* percent unit of measure - leave it as it and we'll treat it separately */
									} else {
										computed = parseFloat( computed );
									}

									return computed;
								},

								/**
								 * Create first letter uppercase from string
								 * @param string
								 * @returns {string}
								 */
								firstLetterUppercase: function ( string ) {
									return string.charAt( 0 ).toUpperCase() + string.slice( 1 );
								},

								/**
								 * Create First letter uppercase wording or camel case names from string
								 *
								 * @param string
								 * @param camel
								 * @returns {string}
								 */
								camelCase: function ( string, camel ) {
									var chunks = string.split( '_' ),
										result = '',
										wordspacing = ' ';

									// try separating the dashed words too
									if ( chunks.length === 1 ) {
										chunks = string.split( '-' )
									}
									/**
									 * if camel is set to true then we shouldn't add any word spacing
									 */
									if ( camel ) {
										wordspacing = ''
									}
									$.each( chunks, function ( index, value ) {
										result += value.toLowerCase().charAt( 0 ).toUpperCase() + value.slice( 1 ) + wordspacing;
									} );

									return result;
								},

								/**
								 * Capitalize first letter of string
								 * @param string
								 * @returns {string}
								 */
								ucFirst: function ( string ) {
									return string.charAt( 0 ).toUpperCase() + string.slice( 1 );
								},

								set_event_callback: function ( frame, evt_name, callback ) {
									frame = frame || 'outer';

									if ( typeof callback === 'undefined' ) {
										TVE[frame].$document.off( evt_name + '.tve' );
										return;
									}

									TVE[frame].$document.off( evt_name + '.tve' ).on( evt_name + '.tve', callback );

								},

								/**
								 * Get the main parameters for an ajax request. Handles error callbacks
								 *
								 * @param {String} custom_action see TCB_Editor_Ajax class
								 * @param {String} [type] Optional, type of the AJAX request (post, get etc)
								 * @param {Object} [extra_data] Optional, extra data to send
								 * @param {String} [data_type] Optional, defaults to json
								 */
								ajax_data: function ( custom_action, type, extra_data, data_type ) {
									return {
										url: TVE.CONST.ajax_url,
										dataType: typeof data_type === 'undefined' ? 'json' : data_type,
										type: type || 'get',
										data: _.extend( {
											action: TVE.CONST.ajax.action,
											custom: custom_action,
											nonce: TVE.CONST.nonce
										}, extra_data || {} ),
										error: function ( jqXHR, textStatus, errorThrown ) {
											if ( typeof jqXHR.tcb_error === 'function' && jqXHR.tcb_error.apply( jqXHR, arguments ) === false ) {
												return;
											}
											if ( jqXHR.responseText ) {
												try {
													var response = JSON.parse( jqXHR.responseText );
													TVE.page_message( response.message, true );
												} catch ( e ) {
													TVE.page_message( jqXHR.responseText, true );
												}
												return;
											}
											// finally just the error text
											TVE.page_message( errorThrown, true );
										}
									}
								},

								/**
								 * Send an ajax request and return the jq xhr object
								 *
								 * @param {String} action see TCB_Editor_Ajax class
								 * @param {String} [type] Optional, type of the AJAX request (post, get etc)
								 * @param {Object} [extra_data] Optional, extra data to send
								 * @param {String} [data_type] dataType parameter
								 */
								ajax: function ( action, type, extra_data, data_type ) {
									return $.ajax( this.ajax_data( action, type, extra_data, data_type ) );
								},
								findClass: function ( items, element ) {
									var selected;
									for ( var i = 0; i < items.length; i ++ ) {
										if ( items[i].substr( 0, element.length ) == element && items[i].length > element.length ) {
											selected = items[i];
											break;
										}
									}

									return selected;
								},

								/**
								 * Truncate a string
								 *
								 * @param {String} text
								 * @param {Number} [length]
								 */
								truncate: function ( text, length ) {
									length = length || 10;
									if ( text.length < length + 3 ) {
										return text;
									}
									return text.substring( 0, length ) + '...';
								},

								/**
								 * Test if a string is a valid URL
								 *
								 * @param string
								 * @returns {boolean}
								 */
								isValidUrl: function ( string ) {
									if ( string.indexOf( '#' ) === 0 || string.indexOf( 'mailto' ) === 0 ) {
										return true;
									}
									return ! ( string.match( /(http(s)?:\/\/.)(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/g ) === null );
								},

								/**
								 * Adds http:// to the url if there isn't a http:// or https:// or ftp://
								 *
								 * @param url
								 * @returns {*}
								 */
								addHttp: function ( url ) {
									url = $.trim( url );
									if ( url && url.indexOf( '#' ) !== 0 && ! /^mailto/.test( url ) && ! /^(?:f|ht)tps?\:\/\//.test( url ) ) {
										url = 'http://' + url;
									}
									return url;
								},

								/**
								 * Get all properties from an object
								 *
								 * @param obj
								 * @param prop
								 * @returns {*}
								 */
								get_all_props: function ( obj, prop ) {
									var result = [];
									if ( ! obj || (typeof obj !== 'object' && ! _.isArray( obj ) ) ) {
										return result;
									}

									_.each( obj, function ( value, key ) {
										if ( key === prop ) {
											result.push( value );

											return true;
										}
										result = result.concat( TVE.get_all_props( value, prop ) );
									} );

									return result.filter( function ( item ) {
										return item;
									} );
								},

								/**
								 * Remove all attributes from an element that starts with "data-"
								 *
								 * @param $target - jQuery object
								 */
								removeDataAttributes: function ( $target ) {
									var i,
										dataAttrs = $target.get( 0 ).attributes,
										dataAttrsLen = dataAttrs.length;

									/*
									 loop through attributes and make a list of those
									 that begin with 'data-'
									 */
									for ( i = 0; i < dataAttrsLen; i ++ ) {
										if ( dataAttrs[i] && dataAttrs[i].name && 'data-' === dataAttrs[i].name.substring( 0, 5 ) ) {
											if ( dataAttrs[i].name ) {
												$target.removeAttr( dataAttrs[i].name );
											}
										}
									}
								},

								/**
								 * Gets an url param value from param name
								 *
								 * @param paramName
								 * @param url
								 * @returns {*|number}
								 */
								getUrlParam: function ( url, paramName ) {
									var results = new RegExp( '[\?&]' + paramName + '=([^&#]*)' ).exec( url );
									return decodeURIComponent( results[1] ) || 0;
								},

								/**
								 * Sets or Replace URL parameter value
								 *
								 * @param url
								 * @param param
								 * @param value
								 * @returns {*}
								 */
								setOrReplaceUrlParam: function ( url, param, value ) {
									var re = new RegExp( '([?&])' + param + '=.*?(&|$)', 'i' ),
										separator = url.indexOf( '?' ) !== - 1 ? '&' : '?';
									if ( url.match( re ) ) {
										return url.replace( re, '$1' + param + '=' + value + '$2' );
									}
									else {
										return url + separator + param + '=' + value;
									}
								},

								/**
								 * Return icon html from svg template
								 *
								 * @param icon
								 * @param {String} [icon_type] svg or css
								 * @param {String} [namespace] optional 'sidebar' / 'editor'
								 * @param {String} extra_class classes to be added to the svg
								 *
								 * @returns {string}
								 */
								icon: function ( icon, icon_type, namespace, extra_class ) {
									if ( ! icon ) {
										return '';
									}

									if ( typeof extra_class === 'undefined' ) {
										extra_class = '';
									} else {
										extra_class = ' ' + extra_class;
									}

									if ( typeof namespace === 'undefined' || ! namespace ) {
										namespace = 'sidebar';
									}
									var html = '<span class="tcb-icon-inline ' + icon + '"></span>';

									if ( typeof icon_type === 'undefined' || icon_type === 'svg' ) {
										icon = ( namespace === 'sidebar' ? 'icon-' : 'tcb-icon-' ) + icon;
										html = TVE.tpl( 'util/icon' )( {icon: icon, extra_class: extra_class} );
									}

									return html;
								},

								/**
								 * Renders an svg icon based on path which the source of the icon
								 * and viewBox which is a must for SVGs
								 *
								 * @param item JSON obj which has to contain path and viewBox prop
								 *
								 * @returns string
								 */
								svg_icon: function ( item ) {

									var _default = {
											path: '',
											viewBox: '0 0 28 28',
											name: tcb_main_const.i18n.none
										},
										model = _.extend( _default, item );

									return TVE.tpl( 'util/svg_icon' )( model );
								},

								/**
								 *
								 * @param {String} filter_tag
								 * @param {Function} callback
								 * @param {int} [priority]
								 */
								add_filter: function ( filter_tag, callback, priority ) {
									if ( typeof priority === 'undefined' ) {
										priority = 10;
									}
									if ( ! this.filter_callbacks ) {
										this.filter_callbacks = {};
									}
									if ( ! this.filter_callbacks[filter_tag] ) {
										this.filter_callbacks[filter_tag] = [];
									}
									this.filter_callbacks[filter_tag].push( {
										fn: callback,
										priority: parseInt( priority )
									} );

									return this;
								},

								remove_filter: function ( filter_tag, callback, priority ) {

									if ( ! this.filter_callbacks ) {
										return this;
									}

									if ( typeof callback === 'undefined' ) {
										delete this.filter_callbacks[filter_tag];
										return this;
									}

									if ( typeof priority === 'undefined' ) {
										priority = 10;
									}

									if ( ! this.has_filter( filter_tag ) ) {
										return this;
									}

									for ( var i = 0, item; item = this.filter_callbacks[filter_tag][i ++]; ) {
										if ( item.priority === priority && item.fn === callback ) {
											i --;
											this.filter_callbacks[filter_tag].splice( i, 1 );
										}
									}

									return this;
								},

								/**
								 *
								 * @param {String} tag
								 * @returns {Boolean}
								 */
								has_filter: function ( tag ) {
									return this.filter_callbacks && this.filter_callbacks[tag] && this.filter_callbacks[tag].length;
								},

								/**
								 * Applies all registered filters and returns the filtered value
								 *
								 * @param {String} tag
								 * @param {Object|*} value
								 * @returns {*}
								 */
								apply_filters: function ( tag, value ) {
									if ( arguments.length < 1 ) {
										return typeof value !== 'undefined' ? value : null;
									}
									if ( this.has_filter( tag ) ) {
										var params = [];
										if ( arguments.length > 2 ) {
											params = Array.prototype.slice.call( arguments, 2 );
										}
										var callbacks = this.filter_callbacks[tag].sort( function ( a, b ) {
											return a.priority - b.priority;
										} );
										$.each( callbacks, function ( i, data ) {
											if ( data.fn ) {
												value = data.fn.apply( null, [value].concat( params ) );
											}
										} );
									}

									return value;
								},

								/**
								 * Bind actions on both inner frame and on outer frame
								 */
								bind_global_events: function () {

									// undo, redo, save on ctrl+z keyboard press
									var cb = function ( e ) {
										if ( TVE.Editor_Page.STATE !== 'enabled' ) {
											return true;
										}

										/* issue with Polish keyboards: if right Alt key is pressed, the equivalent is pressing Ctrl + Alt in windows-based keyboards */
										if ( e.ctrlKey && ! e.altKey ) {
											switch ( e.which ) {
												case 83: /* CTRL + S */
													TVE.main.editor_settings.save();
													return false;
												case 90: /* CTRL + Z */
													TVE.UndoManager.undo();
													return false;
												case 89: /* CTRL + Y */
													TVE.UndoManager.redo();
													return false;
											}
										}
									};
									TVE.$document.add( TVE.inner.$document ).off( 'keydown.tcbglobal' ).on( 'keydown.tcbtcbglobal', cb );
								},

								/**
								 * Refresh iframe so it will get the latest changes.
								 */
								iframe_refresh: function () {
									TVE.main.$frame.attr( 'src', function ( i, val ) {
										return val;
									} );
									/**
									 * Close any possible overlay when the iframe loaded
									 */
									TVE.main.$frame.one( 'load', function () {
										TVE.main.overlay( 'close' );
									} );
									/* just in case, close it after 3 seconds */
									setTimeout( function () {
										TVE.main.overlay( 'close' );
									}, 3000 );
								},
								/**
								 * Shows the WP inline login form
								 */
								relogin: function () {
									/**
									 * Close any possible overlay
									 */
									TVE.main.overlay( 'close' );
									TVE.$document.trigger( 'heartbeat-tick.wp-auth-check', {'wp-auth-check': false} );
								},
								/**
								 * Handles both cases of the inline login - appending an extra field to the interim login form and refresh the nonces on success
								 */
								handle_login: function ( nonce ) {
									TVE.CONST.nonce = nonce;
									if ( this.login_callback ) {
										this.login_callback.fn.apply( this.login_callback.scope );
										delete this.login_callback;
									}
								},
								/**
								 *
								 * @param {Function} cb
								 * @param {Object} [scope]
								 */
								set_login_callback: function ( cb, scope ) {
									this.login_callback = {
										fn: cb,
										scope: scope
									};
								},
								/**
								 * Get input values selected from a container
								 * @param $container
								 * @param selector
								 * @param exclude
								 * @returns {{}}
								 */
								get_inputs_value: function ( $container, selector, exclude ) {

									selector = selector || 'input';
									exclude = exclude || '*';

									var _values = {};

									$container.find( selector ).filter( exclude ).each( function () {
										var $this = jQuery( this ),
											_field = this.name;

										if ( $this.is( 'input:radio, input:checkbox' ) ) {
											if ( $this.is( ':radio' ) && $this.is( ':checked' ) ) {
												_values[_field] = this.value;
											} else if ( $this.is( ':checkbox' ) && $this.is( ':checked' ) ) {

												if ( typeof _values[_field] === 'undefined' ) {
													_values[_field] = [];
												}

												_values[_field].push( this.value );
											}
										} else {
											_values[_field] = this.value;
										}
									} );

									return _values;
								},
								/**
								 * URL of the plugin
								 *
								 * @param {String} [path]
								 */
								url: function ( path ) {
									return TVE.CONST.plugin_url + ( path || '' );
								},
								/**
								 * Unserialize string to javascript object
								 * @param data
								 * @returns {*}
								 */
								unserialize: function ( data ) {

									var $global = (typeof window !== 'undefined' ? window : global),

										utf8Overhead = function ( str ) {
											var s = str.length;
											for ( var i = str.length - 1; i >= 0; i -- ) {
												var code = str.charCodeAt( i );
												if ( code > 0x7f && code <= 0x7ff ) {
													s ++;
												} else if ( code > 0x7ff && code <= 0xffff ) {
													s += 2;
												}
												// trail surrogate
												if ( code >= 0xDC00 && code <= 0xDFFF ) {
													i --;
												}
											}
											return s - 1;
										},
										error = function ( type, msg, filename, line ) {
											throw new $global[type]( msg, filename, line )
										},
										readUntil = function ( data, offset, stopchr ) {
											var i = 2, buf = [], chr = data.slice( offset, offset + 1 );

											while ( chr !== stopchr ) {
												if ( (i + offset) > data.length ) {
													error( 'Error', 'Invalid' );
												}
												buf.push( chr );
												chr = data.slice( offset + (i - 1), offset + i );
												i += 1;
											}
											return [buf.length, buf.join( '' )];
										},
										readChrs = function ( data, offset, length ) {
											var i, chr, buf = [];

											for ( i = 0; i < length; i ++ ) {
												chr = data.slice( offset + (i - 1), offset + i );
												buf.push( chr );
												length -= utf8Overhead( chr );
											}
											return [buf.length, buf.join( '' )];
										};

									function _unserialize( data, offset ) {
										var dtype, dataoffset, keyandchrs, keys, contig, length, array, readdata, readData, ccount, stringlength, i, key, kprops, kchrs, vprops, vchrs, value, chrs = 0,
											typeconvert = function ( x ) {
												return x;
											};

										if ( ! offset ) {
											offset = 0
										}

										dtype = (data.slice( offset, offset + 1 )).toLowerCase();

										dataoffset = offset + 2;

										switch ( dtype ) {
											case 'i':
												typeconvert = function ( x ) {
													return parseInt( x, 10 );
												};
												readData = readUntil( data, dataoffset, ';' );
												chrs = readData[0];
												readdata = readData[1];
												dataoffset += chrs + 1;
												break;
											case 'b':
												typeconvert = function ( x ) {
													return parseInt( x, 10 ) !== 0;
												};
												readData = readUntil( data, dataoffset, ';' );
												chrs = readData[0];
												readdata = readData[1];
												dataoffset += chrs + 1;
												break;
											case 'd':
												typeconvert = function ( x ) {
													return parseFloat( x );
												};
												readData = readUntil( data, dataoffset, ';' );
												chrs = readData[0];
												readdata = readData[1];
												dataoffset += chrs + 1;
												break;
											case 'n':
												readdata = null;
												break;
											case 's':
												ccount = readUntil( data, dataoffset, ':' );
												chrs = ccount[0];
												stringlength = ccount[1];
												dataoffset += chrs + 2;

												readData = readChrs( data, dataoffset + 1, parseInt( stringlength, 10 ) );
												chrs = readData[0];
												readdata = readData[1];
												dataoffset += chrs + 2;
												if ( chrs !== parseInt( stringlength, 10 ) && chrs !== readdata.length ) {
													error( 'SyntaxError', 'String length mismatch' )
												}
												break;
											case 'a':
												readdata = {};

												keyandchrs = readUntil( data, dataoffset, ':' );
												chrs = keyandchrs[0];
												keys = keyandchrs[1];
												dataoffset += chrs + 2;

												length = parseInt( keys, 10 );
												contig = true;

												for ( i = 0; i < length; i ++ ) {
													kprops = _unserialize( data, dataoffset );
													kchrs = kprops[1];
													key = kprops[2];
													dataoffset += kchrs;

													vprops = _unserialize( data, dataoffset );
													vchrs = vprops[1];
													value = vprops[2];
													dataoffset += vchrs;

													if ( key !== i ) {
														contig = false;
													}

													readdata[key] = value;
												}

												if ( contig ) {
													array = new Array( length );
													for ( i = 0; i < length; i ++ ) {
														array[i] = readdata[i]
													}
													readdata = array;
												}

												dataoffset += 1;
												break;
											default:
												error( 'SyntaxError', 'Unknown / Unhandled data type(s): ' + dtype );
												break
										}
										return [dtype, dataoffset - offset, typeconvert( readdata )];
									}

									return _unserialize( (data + ''), 0 )[2];
								},

								serialize: function ( mixedValue ) {
									var val, key, okey,
										ktype = '', vals = '',
										count = 0,
										_utf8Size = function ( str ) {
											var size = 0, i,
												l = str.length,
												code = '';

											for ( i = 0; i < l; i ++ ) {
												code = str.charCodeAt( i );
												if ( code < 0x0080 ) {
													size += 1;
												} else if ( code < 0x0800 ) {
													size += 2;
												} else {
													size += 3;
												}
											}

											return size;
										},
										_getType = function ( inp ) {
											var match, key, cons, types, type = typeof inp;

											if ( type === 'object' && ! inp ) {
												return 'null';
											}

											if ( type === 'object' ) {
												if ( ! inp.constructor ) {
													return 'object';
												}
												cons = inp.constructor.toString();
												match = cons.match( /(\w+)\(/ );
												if ( match ) {
													cons = match[1].toLowerCase();
												}
												types = ['boolean', 'number', 'string', 'array'];
												for ( key in types ) {
													if ( cons === types[key] ) {
														type = types[key];
														break;
													}
												}
											}

											return type;
										},
										type = _getType( mixedValue );

									switch ( type ) {
										case 'function':
											val = '';
											break;
										case 'boolean':
											val = 'b:' + (mixedValue ? '1' : '0');
											break;
										case 'number':
											val = (Math.round( mixedValue ) === mixedValue ? 'i' : 'd') + ':' + mixedValue;
											break;
										case 'string':
											val = 's:' + _utf8Size( mixedValue ) + ':"' + mixedValue + '"';
											break;
										case 'array':
										case 'object':
											val = 'a';

											for ( key in mixedValue ) {
												if ( mixedValue.hasOwnProperty( key ) ) {
													ktype = _getType( mixedValue[key] );
													if ( ktype === 'function' ) {
														continue;
													}
													okey = (key.match( /^[0-9]+$/ ) ? parseInt( key, 10 ) : key);
													vals += TVE.serialize( okey ) + TVE.serialize( mixedValue[key] );
													count ++;
												}
											}
											val += ':' + count + ':{' + vals + '}';
											break;
										case 'undefined':
										default:
											val = 'N';
											break
									}

									if ( type !== 'object' && type !== 'array' ) {
										val += ';'
									}

									return val;
								},
								/**
								 * Base64 decode and encode
								 */
								Base64: {
									_keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

									encode: function ( input ) {
										var output = "", chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;

										input = this._utf8_encode( input );

										while ( i < input.length ) {

											chr1 = input.charCodeAt( i ++ );
											chr2 = input.charCodeAt( i ++ );
											chr3 = input.charCodeAt( i ++ );

											enc1 = chr1 >> 2;
											enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
											enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
											enc4 = chr3 & 63;

											if ( isNaN( chr2 ) ) {
												enc3 = enc4 = 64;
											} else if ( isNaN( chr3 ) ) {
												enc4 = 64;
											}

											output = output + this._keyStr.charAt( enc1 ) + this._keyStr.charAt( enc2 ) + this._keyStr.charAt( enc3 ) + this._keyStr.charAt( enc4 );
										}

										return output;
									},

									decode: function ( input ) {
										var output = "", chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;

										input = input.replace( /[^A-Za-z0-9\+\/\=]/g, "" );

										while ( i < input.length ) {

											enc1 = this._keyStr.indexOf( input.charAt( i ++ ) );
											enc2 = this._keyStr.indexOf( input.charAt( i ++ ) );
											enc3 = this._keyStr.indexOf( input.charAt( i ++ ) );
											enc4 = this._keyStr.indexOf( input.charAt( i ++ ) );

											chr1 = (enc1 << 2) | (enc2 >> 4);
											chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
											chr3 = ((enc3 & 3) << 6) | enc4;

											output = output + String.fromCharCode( chr1 );

											if ( enc3 != 64 ) {
												output = output + String.fromCharCode( chr2 );
											}
											if ( enc4 != 64 ) {
												output = output + String.fromCharCode( chr3 );
											}

										}

										output = this._utf8_decode( output );

										return output;
									},

									_utf8_encode: function ( string ) {
										string = string.replace( /\r\n/g, "\n" );
										var utftext = "";

										for ( var n = 0; n < string.length; n ++ ) {

											var c = string.charCodeAt( n );

											if ( c < 128 ) {
												utftext += String.fromCharCode( c );
											}
											else if ( (c > 127) && (c < 2048) ) {
												utftext += String.fromCharCode( (c >> 6) | 192 );
												utftext += String.fromCharCode( (c & 63) | 128 );
											}
											else {
												utftext += String.fromCharCode( (c >> 12) | 224 );
												utftext += String.fromCharCode( ((c >> 6) & 63) | 128 );
												utftext += String.fromCharCode( (c & 63) | 128 );
											}
										}

										return utftext;
									},

									_utf8_decode: function ( utftext ) {
										var string = "", i = 0, c = 0, c1 = 0, c2 = 0;

										while ( i < utftext.length ) {

											c = utftext.charCodeAt( i );

											if ( c < 128 ) {
												string += String.fromCharCode( c );
												i ++;
											}
											else if ( (c > 191) && (c < 224) ) {
												c1 = utftext.charCodeAt( i + 1 );
												string += String.fromCharCode( ((c & 31) << 6) | (c1 & 63) );
												i += 2;
											}
											else {
												c1 = utftext.charCodeAt( i + 1 );
												c2 = utftext.charCodeAt( i + 2 );
												string += String.fromCharCode( ((c & 15) << 12) | ((c1 & 63) << 6) | (c2 & 63) );
												i += 3;
											}
										}

										return string;
									}
								},

								/**
								 * Global notifications - shows notifications on the page.
								 *
								 * @param {String} message
								 * @param {Number|Boolean} [error] -1 => warning. true|1 => error. false|undefined => success
								 * @param {Number} [duration] defaults to 4 seconds
								 */
								page_message: function ( message, error, duration ) {
									if ( typeof TVE.t[message] !== 'undefined' ) {
										message = TVE.t[message];
									}
									duration = duration || 4000;

									var $box = $( '#tve_notification_box' );
									if ( ! $box.length ) {
										TVE.$notification = $box = $( '<div id="tve_notification_box"></div>' ).appendTo( 'body' );
									}

									if ( error === - 1 ) {
										$box.addClass( 'tve_warning_box' );
									} else if ( error ) {
										$box.addClass( 'tve_error_box' );
									} else {
										$box.removeClass( 'tve_error_box tve_warning_box' );
									}

									$box.html( message ).animate( {left: 350}, 700 );

									setTimeout( function () {
										$box.animate( {left: - 950}, 700 );
									}, duration );

									return this;
								}
							};

							$.fn.extend( {
								tve_draggable: function ( options ) {
									options = options || {};
									options.stepSize = options.stepSize || 1;

									var target, dir, reverse, style,
										originalX, originalY, step,
										disableSelect = false,
										position = {
											x: 0,
											y: 0
										},
										prev = {
											x: 0,
											y: 0
										},
										callbacks = $.extend( {
											start: function ( style, dir ) {
											},
											move: function ( delta, style, dir, step, ctrl, event ) {
											},
											stop: function ( delta, style, dir, step, ctrl, event ) {
											}
										}, options ),
										dirMap = {
											top: 'y',
											right: 'x',
											bottom: 'y',
											left: 'x'
										},
										removeCallbacks = function () {
											TVE.set_event_callback( 'inner', 'mousemove' );
											TVE.set_event_callback( 'inner', 'mouseup' );

											TVE.set_event_callback( 'outer', 'mousemove' );
											TVE.set_event_callback( 'outer', 'mouseup' );
										},
										mouseDown = function ( event ) {
											originalX = event.screenX;
											originalY = event.screenY;
											target = event.currentTarget;
											dir = target.getAttribute( 'data-dir' ) || options.dir;
											style = target.getAttribute( 'data-style' ) || options.style;
											reverse = target.className.indexOf( 'reverse' ) === - 1 ? 1 : - 1;

											prev.x = prev.y = 0;

											callbacks.start( style, dir, event );

											disableSelect = true;

											TVE.set_event_callback( 'inner', 'mousemove', mouseMove );
											TVE.set_event_callback( 'inner', 'mouseup', mouseUp );

											TVE.set_event_callback( 'outer', 'mousemove', mouseMove );
											TVE.set_event_callback( 'outer', 'mouseup', mouseUp );
										},
										mouseMove = function ( event ) {
											position.x = event.screenX - originalX;
											position.y = event.screenY - originalY;
											var distance = Math.sqrt( Math.pow( position.y - prev.y, 2 ) + Math.pow( position.x - prev.x, 2 ) );
											if ( options.stepSize && options.stepSize > 1 && distance < options.stepSize ) {
												return;
											}

											step = ( reverse * (position[dirMap[dir]] - prev[dirMap[dir]] ) ) / options.stepSize;
											callbacks.move( position[dirMap[dir]] * reverse / options.stepSize, style, dir, step, event.ctrlKey, event );

											prev.x = position.x;
											prev.y = position.y;
										},
										mouseUp = function ( event ) {
											removeCallbacks();

											disableSelect = false;

											position.x = event.screenX - originalX;
											position.y = event.screenY - originalY;

											var delta = ( position[dirMap[dir]] * reverse ) / options.stepSize;
											step = reverse * (position[dirMap[dir]] - prev[dirMap[dir]] ) / options.stepSize;

											/* when the user just clicks without dragging, we increase the value by one */
											delta = delta ? delta : 1;

											callbacks.stop( delta, style, dir, step, event.ctrlKey, event );
										};

									this.on( 'mousedown', mouseDown );

									/* disable selection of text on drag */
									TVE.outer.$document.on( 'selectstart', function ( e ) {
										if ( disableSelect ) {
											e.preventDefault();
										}

										return ! disableSelect;
									} );

									return this;
								},
								tve_search: function ( $target ) {
									var bind = 'keydown keypress keyup change',
										self = this;

									this.trigger = function ( search ) {
										$target.hide();

										$target.filter( function () {
											return $( this ).text().toLowerCase().indexOf( search ) >= 0;
										} ).show();
									};

									return this.each( function () {
										$( this ).bind( bind, function () {
											var search = this.value.toLowerCase();
											self.trigger( search );
										} );
									} );
								},
								visible: function () {
									return this.css( 'visibility', 'visible' );
								},
								invisible: function () {
									return this.css( 'visibility', 'hidden' );
								}
							} );

						})( jQuery );
					},
					"collections": {
						"base.js": function (exports, module, require) {
							var BaseModel = require( '../models/base' );

							module.exports = Backbone.Collection.extend( {
								model: BaseModel
							} );
						},
						"gradient.js": function (exports, module, require) {
							var BaseModel = require( '../models/base' ),
								gradient_build = require( '../libs/gradient-builder' );

							module.exports = Backbone.Collection.extend( {
								model: BaseModel,
								/**
								 * Human readable labels for each type of background-image property
								 */
								labels: {
									'url': TVE.t.image,
									'solid': TVE.t.solid_color,
									'pattern': TVE.t.pattern,
									'linear-gradient': TVE.t.lin_grad,
									'repeating-linear-gradient': TVE.t.rep_lin_grad,
									'radial-gradient': TVE.t.rad_grad,
									'repeating-radial-gradient': TVE.t.rep_rad_grad
								},
								prepare_item: function ( item ) {
									if ( item.type === 'repeating-linear-gradient' || item.type === 'repeating-radial-gradient' ) {
										item.real_type = item.type;
										item.type = 'pattern';
									}

									item.label = this.labels[item.type];

									if ( item.type === 'url' ) {
										item.icon = '<span class="tcb-icon-14w">' + TVE.icon( 'img' ) + '</span>';
									} else {
										item.icon = '<span class="tcb-icon-inline" style="background-size:' + item.size + ';background-image:' + gradient_build( item ) + '"></span>';
									}

									return item;
								},
								add: function ( item, options ) {
									options = options || {at: 0};

									return Backbone.Collection.prototype.add.call( this, item, options );
								},
								reset: function ( items ) {
									items = _.map( items, this.prepare_item, this );

									return Backbone.Collection.prototype.reset.call( this, items );
								}
							} );
						}
					},
					"elements": {
						"_base.js": function (exports, module, require) {
							(function ( $ ) {
								module.exports = Backbone.Model.extend( {
									/**
									 * Initializer
									 *
									 * Setup the default configuration for the renderer
									 */
									initialize: function ( attr ) {
										this.key = attr.key;
										this.setup_defaults();
									},
									/**
									 * Should be implemented in extended objects.
									 * Should setup the default element data based on which the element is rendered
									 */
									setup_defaults: function () {
										this.config = {};
									},
									/**
									 * Renders the default element (with no settings applied)
									 * Called when inserting the element into the page
									 *
									 * @returns {*}
									 */
									render_default: function () {
										this.setup_defaults();
										var $element = $( '<div class="thrv_wrapper thrv-' + this.key + '"></div>' );

										this.render_to( $element );

										return $element;
									},
									/**
									 * set the current element
									 * @param $elem
									 * @returns {exports}
									 */
									set_element: function ( $elem ) {
										this.$element = $elem;

										return this;
									},
									/**
									 * Public wrapper over the render_to method: Renders the contents of the element
									 *
									 * @param {jQuery} $element
									 * @param {Boolean} [add_undo_step] whether or not to record an undo step
									 * @returns {*}
									 */
									render_to: function ( $element, add_undo_step ) {
										if ( add_undo_step ) {
											var before = this.__undo_snaphot ? this.__undo_snaphot : this.read_element_props( $element );
											this.clear_undo_snapshot();
										}

										this._render_to.apply( this, arguments );

										if ( add_undo_step ) {
											var after = this.read_element_props( $element );
											TVE.UndoManager.add( {
												undo: function () {
													$element.html( before.html ).attr( before.data ).attr( 'class', before.cls );
												},
												redo: function () {
													$element.html( after.html ).attr( after.data ).attr( 'class', after.cls );
												}
											} );
										}
										return this;
									},
									/**
									 * Private render method. Should not be called directly
									 * Renders the contents of the element
									 *
									 * @param {jQuery} $element
									 * @param {Boolean} [add_undo_step] whether or not to record an undo step
									 * @returns {*}
									 */
									_render_to: function ( $element, add_undo_step ) {

									},
									/**
									 * setter for values
									 * @param obj
									 *
									 * @return {*} allow chained calls
									 */
									set_data: function ( obj ) {
										_.extend( this.data, obj );

										return this;
									},
									/**
									 * Set config data (non-data attributes)
									 *
									 * @param obj
									 * @param {Boolean} deep whether or not use use "deep" extending. Defaults to true
									 */
									set_config: function ( obj, deep ) {
										if ( typeof deep === 'undefined' || deep ) {
											$.extend( true, this.config, obj );
										} else {
											this.config = _.extend( this.config, obj );
										}

										return this;
									},
									/**
									 * Reads html and data-attributes for the element
									 * Uses this.data to get all data- attributes
									 *
									 * @param $element
									 */
									read_element_props: function ( $element ) {
										var prop = {
											html: $element.html(),
											cls: $element.attr( 'class' ),
											style: $element.attr( 'style' ),
											data: {}
										};

										if ( ! this.data ) {
											this.data = $element.data();
										}

										_.each( this.data, function ( value, attr ) {
											prop.data['data-' + attr] = $element.attr( 'data-' + attr );
										} );

										return prop;
									},
									/**
									 * Record element state for undo / redo. Used when previewing stuff from the Style Changer. Only record undo after clicking apply
									 *
									 * @param $element
									 */
									take_undo_snapshot: function ( $element ) {
										this.__undo_snaphot = this.read_element_props( $element );
									},
									/**
									 * Clear out the saved snapshot of the element
									 */
									clear_undo_snapshot: function () {
										delete this.__undo_snaphot;
									}
								} );
							})( jQuery );
						},
						"_renderers.js": function (exports, module, require) {
							var Rating = require( './rating' ),
								Columns = require( './columns' ),
								Social = require( './social' ),
								Credit = require( './credit' ),
								Testimonial = require( './testimonial' ),
								StyledList = require( './styled-list' ),
								Base = require( './_base' );
							module.exports = {
								base: new Base( {key: 'base'} ),
								columns: new Columns( {key: 'columns'} ),
								social: new Social( {key: 'social'} ),
								rating: new Rating( {key: 'rating'} ),
								credit: new Credit( {key: 'credit'} ),
								testimonial: new Testimonial( {key: 'testimonial'} ),
								styledlist: new StyledList( {key: 'styled_list'} ),
								CONSTRUCTORS: {
									social: Social
								}
							};
						},
						"columns.js": function (exports, module, require) {
							module.exports = require( './_base' ).extend( {
								setup_defaults: function () {
									// no data in the element
									this.data = {};

									this.default_format = [];
									this.default_format[2] = [];
								},
								/**
								 * Renders the default element - this is just a placeholder
								 *
								 * @returns {*}
								 */
								render_default: function () {
									this.setup_defaults();

									return jQuery( '<div class="thrv_wrapper tcb-row-empty tcb-elem-placeholder thrv-' + this.key + '"></div>' )
										.html( '<span class="tcb-inline-placeholder-action with-icon">' + TVE.icon( 'column', 'svg', 'editor' ) + TVE.t.column_layout + '</span>' );
								},
								_render_to: function ( $element, add_undo_step, columns, format_index, append_text ) {
									columns = parseInt( columns );

									append_text = typeof append_text === 'undefined' ? false : append_text;
									var html = '';
									if ( typeof format_index === 'undefined' ) {
										_.each( this.format[columns], function ( format, _index ) {
											html += this.get_html( columns, _index, append_text );
										}, this );
									} else {
										html = this.get_html( columns, parseInt( format_index ), append_text );
									}

									$element.html( html );

									return this;
								},
								/**
								 * Get the html for a row
								 *
								 * @param columns
								 * @param format_index
								 */
								get_html: function ( columns, format_index ) {
									var i = 0,
										html = '',
										format = this.format[columns][format_index];

									while ( i < columns ) {
										html += '<div class="tcb-flex-col' + ( format.cls && format.cls[i] ? ' ' + format.cls[i] : '' ) + '"><div class="tcb-col"></div></div>';
										i ++;
									}

									return '<div class="tcb-flex-row tcb--cols--' + columns + '">' + html + '</div>'
								},
								format: [
									'', // 0 -> no option
									'', // 1 -> no option
									[ // 2 columns
										{text: '1/2'},
										{text: ['1/3', '2/3'], cls: ['c-33', 'c-66']},
										{text: ['2/3', '1/3'], cls: ['c-66', 'c-33']}
									],
									[ // 3 columns
										{text: '1/3'},
										{text: ['1/4', '2/4', '1/4'], cls: ['c-25', 'c-50', 'c-25']},
										{text: ['1/4', '1/4', '2/4'], cls: ['c-25', 'c-25', 'c-50']},
										{text: ['2/4', '1/4', '1/4'], cls: ['c-50', 'c-25', 'c-25']}
									],
									[ // 4 columns
										{text: '1/4'}
									]
								]
							} );
						},
						"credit.js": function (exports, module, require) {
							/**
							 * Created by Ovidiu on 4/4/2017.
							 */
							module.exports = require( './_base' ).extend( {
								cards: {
									visa: 'Visa',
									masterCard: 'MasterCard',
									americanExpress: 'American Express',
									payPal: 'PayPal',
									discover: 'Discover'
								},
								setup_defaults: function () {
									var default_cards = JSON.parse( JSON.stringify( this.cards ) );
									delete default_cards.discover;
									this.data = {
										cards: default_cards,
										style: 'style1'
									};
								},
								get_html: function ( cards, style ) {
									style = typeof style === 'undefined' ? this.data.style : style;
									cards = typeof cards === 'undefined' ? this.data.cards : cards;

									var html = '';
									_.each( cards, function ( item, index ) {
										html += '<svg viewBox="0 0 72 52" class="tcb-' + index + '-card">' + this.templates[style][index] + '</svg>';
									}, this );
									return html;
								},
								_render_to: function ( $element, add_undo_step ) {
									$element.attr( {
										'data-style': this.data.style,
										'data-cards': Object.keys( this.data.cards )
									} ).html( this.get_html() );

									return this;
								},
								get_styles: function () {
									var styles = {},
										cards = this.cards;
									_.each( this.templates, function ( style, key ) {
										styles[key] = {label: TVE.firstLetterUppercase( key ), html: this.get_html( cards, key )};
									}, this );

									return styles;
								},
								get_cards: function () {
									var cardsArr = [];
									_.each( this.cards, function ( cardName, key ) {
										cardsArr.push( {identifier: key, label: cardName} );
									}, this );
									return cardsArr;
								},
								get_card_template: function ( card, withSvgTag ) {
									withSvgTag = typeof withSvgTag === 'undefined' ? false : withSvgTag;
									var cardHTML = this.templates[this.data.style][card];
									if ( withSvgTag ) {
										cardHTML = '<svg viewBox="0 0 72 52">' + cardHTML + '</svg>';
									}
									return cardHTML;
								},
								sort_element_cards: function ( corect_order ) {
									this.data.cards = {};
									_.each( corect_order, function ( item, index ) {
										this.data.cards[item] = this.cards[item];
									}, this );
								},
								templates: {
									style1: {
										visa: '<g><path class="visa-style-1-st0" d="M7.6,0.9h56.7c3.7,0,6.6,3,6.6,6.6v36.7c0,3.7-3,6.6-6.6,6.6H7.6c-3.7,0-6.6-3-6.6-6.6V7.5C1,3.9,4,0.9,7.6,0.9z"/><path class="visa-style-1-st1" d="M24.8,33.8h-4.1l-3.1-11.6c-0.1-0.5-0.5-1-0.9-1.2c-1.1-0.6-2.4-1-3.7-1.2v-0.4h6.6c0.9,0,1.6,0.7,1.7,1.5l1.6,8.4l4.1-9.8h4L24.8,33.8z M33.1,33.8h-3.8l3.2-14.5h3.8L33.1,33.8z M41.2,23.3c0.1-0.8,0.8-1.2,1.6-1.2c1.2-0.1,2.6,0.1,3.7,0.7l0.7-3.1c-1.1-0.4-2.4-0.7-3.5-0.7c-3.7,0-6.4,2-6.4,4.8c0,2.1,1.9,3.2,3.3,3.9c1.5,0.7,2,1.1,1.9,1.8c0,1-1.1,1.5-2.3,1.5c-1.4,0-2.7-0.3-4-0.9l-0.7,3.1c1.4,0.6,2.8,0.8,4.2,0.8C44,34,46.6,32,46.6,29C46.6,25.2,41.2,25,41.2,23.3L41.2,23.3z M60,33.8l-3.1-14.5h-3.3c-0.7,0-1.4,0.4-1.6,1.1l-5.6,13.4h4l0.8-2.1H56l0.5,2.1H60z M54.2,23.2l1.1,5.5h-3.2L54.2,23.2z"/></g>',
										masterCard: '<g transform="translate(337.000000, 0.000000)"><path class="masterCard-style-1-st0" d="M-329.4,0.9h56.7c3.7,0,6.6,3,6.6,6.6v36.7c0,3.7-3,6.6-6.6,6.6h-56.7c-3.7,0-6.6-3-6.6-6.6V7.5C-336,3.9-333,0.9-329.4,0.9z"/><g transform="translate(12.526316, 11.194030)"><path class="masterCard-style-1-st1" d="M-313.2,4.5c-2.4-2.1-5.5-3.3-8.8-3.3c-7.5,0-13.6,6.2-13.6,13.8s6.1,13.8,13.6,13.8c3.4,0,6.5-1.2,8.8-3.3c2.4,2.1,5.5,3.3,8.8,3.3c7.5,0,13.6-6.2,13.6-13.8s-6.1-13.8-13.6-13.8C-307.7,1.2-310.8,2.4-313.2,4.5z"/><path class="masterCard-style-1-st2" d="M-313.2,4.5c-2.4-2.1-5.5-3.3-8.8-3.3c-7.5,0-13.6,6.2-13.6,13.8s6.1,13.8,13.6,13.8c3.4,0,6.5-1.2,8.8-3.3c-2.9-2.5-4.8-6.3-4.8-10.5S-316.1,7-313.2,4.5z"/><path class="masterCard-style-1-st3" d="M-313.2,25.5c2.4,2.1,5.5,3.3,8.8,3.3c7.5,0,13.6-6.2,13.6-13.8s-6.1-13.8-13.6-13.8c-3.4,0-6.5,1.2-8.8,3.3c2.9,2.5,4.8,6.3,4.8,10.5S-310.2,23-313.2,25.5z"/></g></g>',
										americanExpress: '<g><g><g transform="translate(169.000000, 0.000000)"><path class="americanExpress-style-1-st0" d="M-161.4,0.9h56.7c3.7,0,6.6,3,6.6,6.6v36.7c0,3.7-3,6.6-6.6,6.6h-56.7c-3.7,0-6.6-3-6.6-6.6V7.5C-168,3.9-165,0.9-161.4,0.9z"/></g></g><path class="americanExpress-style-1-st1" d="M31,28.2l-3.8-8.4h-4.6v11.9l-5.4-11.9h-3.8L8,32.3h3.2l1.1-2.7h6l1.1,2.7h6.2v-9.2l4.1,9.2h2.7l4.1-8.9v8.9h3V20.1h-4.6L31,28.5L31,28.2z M15.4,26.9h-1.9l1.9-4.3l0,0l2,4.3L15.4,26.9z"/><path class="americanExpress-style-1-st1" d="M58.4,26l2.2-2.4l3.2-3.5H60l-3.5,3.8L53,20.1H41.3v12.2H53l3.5-4.1l3.5,4.1h3.8l-3.2-3.8L58.4,26z M51.1,29.8h-6.8v-2.4h6.8V25h-6.8v-2.2h6.8l3.5,3.2L51.1,29.8z"/></g>',
										payPal: '<g><g transform="translate(85.000000, 0.000000)"><path class="payPal-style-1-st0" d="M-77.4,0.9h56.7c3.7,0,6.6,3,6.6,6.6v36.7c0,3.7-3,6.6-6.6,6.6h-56.7c-3.7,0-6.6-3-6.6-6.6V7.5C-84,3.9-81,0.9-77.4,0.9z"/></g><path class="payPal-style-1-st1" d="M34.7,18.3h8.1c4.3,0,6,2.2,5.7,5.4c-0.4,5.3-3.6,8.3-7.9,8.3h-2.2c-0.6,0-1,0.4-1.1,1.4l-0.9,6.1c-0.1,0.4-0.3,0.6-0.6,0.7h-5.1c-0.5,0-0.6-0.4-0.5-1.2l3.1-19.6C33.4,18.7,33.8,18.3,34.7,18.3z"/><path class="payPal-style-1-st2" d="M29.6,11.6h8.1c2.3,0,5,0.1,6.8,1.7c1.2,1.1,1.8,2.8,1.7,4.6c-0.5,6.2-4.2,9.6-9.1,9.6h-4c-0.7,0-1.1,0.4-1.3,1.7l-1.1,7.1C30.6,36.7,30.4,37,30,37h-5c-0.6,0-0.7-0.4-0.6-1.3L28,12.9C28.2,12,28.7,11.6,29.6,11.6z"/></g>',
										discover: '<g transform="translate(253.000000, 0.000000)"><path class="discover-style-1-st0" d="M-245.3,0.9h56.6c3.7,0,6.7,3,6.7,6.7v36.6c0,3.7-3,6.7-6.7,6.7h-56.6c-3.7,0-6.7-3-6.7-6.7V7.6C-252,3.9-249,0.9-245.3,0.9z"/><path class="discover-style-1-st1" d="M-190.8,25.7h-0.5v-2.9h0.5c1.2,0,1.7,0.5,1.7,1.4C-189.1,25.2-189.6,25.7-190.8,25.7L-190.8,25.7z M-187.1,24.1c0-1.8-1.2-2.8-3.4-2.8h-2.7v9.6h1.8V27h0.2l2.5,3.9h2.3l-2.9-4C-188,26.7-187,25.5-187.1,24.1L-187.1,24.1z M-199.6,30.9h5.2v-1.6h-3.4v-2.6h3.3V25h-3.3v-2.1h3.4v-1.6h-5.2V30.9L-199.6,30.9z M-205.1,27.7l-2.5-6.4h-2l4,9.8h1l4-9.8h-2L-205.1,27.7L-205.1,27.7z M-227.1,26.1c0,2.7,2.2,4.9,4.9,4.9c0.9,0,1.6-0.2,2.4-0.5v-2.1c-0.5,0.6-1.3,1.1-2.2,1.1c-1.7,0-3.2-1.3-3.2-3v-0.2c-0.1-1.7,1.3-3.2,3-3.3c0.9,0,1.7,0.4,2.3,1.1v-2.1c-0.7-0.4-1.5-0.5-2.3-0.5C-224.9,21.1-227.1,23.3-227.1,26.1L-227.1,26.1z M-230.5,24.9c-1.1-0.4-1.4-0.6-1.4-1.2c0.1-0.6,0.7-1.2,1.3-1.1c0.5,0,1.1,0.3,1.5,0.8l1-1.3c-0.8-0.6-1.7-1.1-2.7-1.1c-1.5-0.1-2.8,1.1-2.9,2.6v0.1c0,1.3,0.5,2,2.3,2.6c0.4,0.1,0.9,0.3,1.3,0.5c0.3,0.2,0.5,0.5,0.5,1c0,0.8-0.7,1.4-1.3,1.4h-0.1c-0.9,0-1.6-0.5-2-1.3l-1.2,1.2c0.7,1.2,2,1.8,3.3,1.8c1.7,0.1,3.2-1.2,3.3-2.9v-0.3C-227.8,26.4-228.3,25.8-230.5,24.9L-230.5,24.9z M-236.8,30.9h1.8v-9.6h-1.8V30.9L-236.8,30.9z M-240.5,28.5c-0.7,0.5-1.6,0.9-2.5,0.8h-0.5v-6.3h0.5c0.9-0.1,1.8,0.2,2.5,0.8c0.7,0.6,1,1.5,1,2.4C-239.5,27-239.8,27.8-240.5,28.5L-240.5,28.5z M-242.7,21.3h-2.7v9.6h2.7c1.2,0.1,2.4-0.3,3.4-1.1c1.1-1,1.7-2.3,1.7-3.7c0.1-2.6-2-4.7-4.6-4.8H-242.7L-242.7,21.3z M-214.3,21.1c-2.7,0-5,2.1-5,4.9c0,2.7,2.2,4.9,5,5.1c2.8,0.1,5-2.1,5.1-4.9C-209.3,23.3-211.5,21.1-214.3,21.1L-214.3,21.1z"/></g>'
									},
									style2: {
										visa: '<g><path class="visa-style-2-st0" d="M7.6,1h56.7C68,1,71,4,71,7.6v36.7c0,3.7-3,6.6-6.6,6.6H7.6C4,51,1,48,1,44.4V7.6C1,4,4,1,7.6,1z"/><path class="visa-style-2-st1" d="M7.6,1h56.7C68,1,71,4,71,7.6v3.7H1V7.6C1,4,4,1,7.6,1z"/><path class="visa-style-2-st2" d="M71,40.6v3.7c0,3.7-3,6.6-6.6,6.6H7.6C4,51,1,48,1,44.4v-3.7H71z"/><path class="visa-style-2-st1" d="M56.5,33.3l-0.4-2.2h-4.9l-0.8,2.2h-4l5.7-13.5c0,0,0.3-1.1,1.8-1.1H57l3.1,14.5H56.5z M52.3,28.1h3.2l-1.1-5.4L52.3,28.1z"/><path class="visa-style-2-st1" d="M46.7,22.2l0.5-3.1c0,0-1.7-0.6-3.5-0.6c-1.9,0-6.4,0.8-6.4,4.8c0,3.8,5.3,3.8,5.3,5.8c0,2-4.8,1.6-6.3,0.4l-0.6,3.3c0,0,1.7,0.8,4.3,0.8c2.6,0,6.6-1.3,6.6-5c0-3.8-5.4-4.1-5.4-5.8C41.3,21.1,45.1,21.3,46.7,22.2"/><polyline class="visa-style-2-st1" points="33.4,33.3 29.6,33.3 32,18.7 35.8,18.7 33.4,33.3 	"/><path class="visa-style-2-st1" d="M16.1,18.7h-3L13,19c0,0,1.9,0.4,4,1.7l3.3,12.6h4l6.1-14.5h-4.1l-3.7,10l-0.4-2.2v0L20.9,20c0,0-0.2-1.3-1.8-1.3H16.1h-3L13,19c0,0,2.9,0.6,5.7,2.8c2.7,2.1,3.5,4.8,3.5,4.8L20.9,20c0,0-0.2-1.3-1.8-1.3H16.1z"/><path class="visa-style-2-st2" d="M22.2,26.6L20.9,20c0,0-0.2-1.3-1.8-1.3h-6.1L13,19c0,0,2.9,0.6,5.7,2.8C21.4,23.9,22.2,26.6,22.2,26.6"/></g>',
										masterCard: '<g><path class="masterCard-style-2-st0" d="M7.6,1h56.7C68,1,71,4,71,7.6v36.7c0,3.7-3,6.6-6.6,6.6H7.6C4,51,1,48,1,44.4V7.6C1,4,4,1,7.6,1z"/><path class="masterCard-style-2-st1" d="M41.4,26c0,7.7-6.2,13.9-14,13.9c-7.7,0-14-6.2-14-13.9c0-7.7,6.2-13.9,14-13.9C35.1,12.1,41.4,18.3,41.4,26"/><path class="masterCard-style-2-st2" d="M46.1,12.1c-3.6,0-6.9,1.4-9.4,3.6c-0.5,0.5-1,1-1.4,1.5h2.8c0.4,0.5,0.7,1,1.1,1.5h-4.9c-0.3,0.5-0.6,1-0.8,1.5H40c0.2,0.5,0.4,1,0.6,1.5h-7.7c-0.2,0.5-0.3,1-0.4,1.5H41c0.2,1,0.3,1.9,0.3,3c0,1.5-0.3,3-0.7,4.4h-7.7c0.2,0.5,0.4,1,0.6,1.5H40c-0.2,0.5-0.5,1-0.8,1.5h-4.9c0.3,0.5,0.7,1,1.1,1.5h2.8c-0.4,0.5-0.9,1-1.4,1.5c2.5,2.2,5.8,3.6,9.4,3.6c7.7,0,14-6.2,14-13.9C60.1,18.3,53.8,12.1,46.1,12.1"/><path class="masterCard-style-2-st3" d="M57.7,29.7h-1.4l0.1-0.5c-0.4,0.4-0.8,0.6-1.4,0.6c-1.1,0-1.8-0.9-1.8-2.4c0-1.9,1.1-3.5,2.5-3.5c0.6,0,1,0.2,1.4,0.8l0.3-2h1.5L57.7,29.7L57.7,29.7z M55.5,28.4c0.7,0,1.2-0.8,1.2-1.9c0-0.7-0.3-1.1-0.8-1.1c-0.7,0-1.2,0.8-1.2,1.9C54.7,28,55,28.4,55.5,28.4L55.5,28.4z"/><path class="masterCard-style-2-st3" d="M50.9,23.8c-0.2,1.8-0.5,3.6-0.8,5.4L50,29.5h1.5c0.5-3.5,0.7-4.2,1.5-4.1c0.1-0.7,0.4-1.4,0.6-1.7c-0.6-0.1-1,0.2-1.5,0.9c0-0.3,0.1-0.6,0.1-0.9H50.9"/><path class="masterCard-style-2-st3" d="M48.5,27.1c-0.2,0-0.2,0-0.3,0c-0.9,0-1.3,0.3-1.3,0.9c0,0.4,0.2,0.6,0.5,0.6C48,28.5,48.5,27.9,48.5,27.1L48.5,27.1z M49.6,29.6h-1.3l0-0.6c-0.4,0.5-0.9,0.7-1.6,0.7c-0.8,0-1.4-0.6-1.4-1.6c0-1.4,1-2.2,2.7-2.2c0.2,0,0.4,0,0.6,0c0-0.2,0.1-0.3,0.1-0.4c0-0.4-0.3-0.5-1-0.5c-0.7,0-1.4,0.2-1.6,0.3c0-0.1,0.2-1.3,0.2-1.3c0.8-0.2,1.3-0.3,1.8-0.3c1.3,0,2,0.6,2,1.7c0,0.3,0,0.7-0.1,1.1C49.9,27.4,49.7,29.2,49.6,29.6L49.6,29.6z"/><path class="masterCard-style-2-st3" d="M46.1,22.8l-0.2,1.5c-0.5-0.3-0.9-0.4-1.4-0.4c-1.1,0-1.9,1.1-1.9,2.6c0,1.1,0.5,1.7,1.4,1.7c0.4,0,0.8-0.1,1.3-0.4L45,29.6c-0.6,0.2-0.9,0.2-1.3,0.2c-1.6,0-2.6-1.2-2.6-3.1c0-2.5,1.4-4.3,3.4-4.3C45.1,22.4,45.9,22.7,46.1,22.8"/><path class="masterCard-style-2-st3" d="M38.6,23.8c-0.2,1.8-0.5,3.6-0.8,5.4l-0.1,0.4h1.5c0.5-3.5,0.7-4.2,1.5-4.1c0.1-0.7,0.4-1.4,0.6-1.7c-0.6-0.1-1,0.2-1.5,0.9c0-0.3,0.1-0.6,0.1-0.9H38.6"/><path class="masterCard-style-2-st3" d="M37.2,29.5c-0.5,0.2-1,0.2-1.5,0.2c-1.7,0-2.6-0.9-2.6-2.6c0-2,1.1-3.4,2.6-3.4c1.2,0,2,0.8,2,2.1c0,0.4-0.1,0.8-0.2,1.4h-3c-0.1,0.8,0.4,1.2,1.3,1.2c0.5,0,1-0.1,1.6-0.4L37.2,29.5L37.2,29.5z M36.3,26.1c0-0.1,0.2-1-0.7-1c-0.5,0-0.8,0.4-1,1H36.3L36.3,26.1z"/><path class="masterCard-style-2-st3" d="M32.5,29.6c-0.4,0.1-0.7,0.2-1.1,0.2c-0.8,0-1.2-0.4-1.2-1.3c0-0.3,0.1-0.9,0.2-1.5c0.1-0.5,0.7-3.9,0.7-3.9h1.5l-0.2,0.9h0.8L33,25.3h-0.8c-0.2,1.1-0.4,2.5-0.4,2.6c0,0.3,0.2,0.4,0.5,0.4c0.2,0,0.3,0,0.4-0.1L32.5,29.6"/><path class="masterCard-style-2-st3" d="M26.6,25.7c0,0.7,0.4,1.2,1.2,1.6c0.6,0.3,0.7,0.4,0.7,0.6c0,0.4-0.3,0.5-0.9,0.5c-0.5,0-0.9-0.1-1.4-0.2c0,0-0.2,1.3-0.2,1.3c0.3,0.1,0.7,0.1,1.6,0.2c1.6,0,2.3-0.6,2.3-1.9c0-0.8-0.3-1.3-1.1-1.6c-0.6-0.3-0.7-0.4-0.7-0.6c0-0.3,0.3-0.5,0.7-0.5c0.3,0,0.7,0,1.1,0.1l0.2-1.3c-0.4-0.1-1-0.1-1.3-0.1C27.2,23.7,26.6,24.6,26.6,25.7"/><path class="masterCard-style-2-st3" d="M24.7,27.1c-0.2,0-0.2,0-0.3,0c-0.9,0-1.3,0.3-1.3,0.9c0,0.4,0.2,0.6,0.5,0.6C24.2,28.5,24.7,27.9,24.7,27.1L24.7,27.1z M25.8,29.6h-1.3l0-0.6c-0.4,0.5-0.9,0.7-1.6,0.7c-0.8,0-1.4-0.6-1.4-1.6c0-1.4,1-2.2,2.7-2.2c0.2,0,0.4,0,0.6,0c0-0.2,0.1-0.3,0.1-0.4c0-0.4-0.3-0.5-1-0.5c-0.7,0-1.4,0.2-1.6,0.3c0-0.1,0.2-1.3,0.2-1.3c0.8-0.2,1.3-0.3,1.8-0.3c1.3,0,2,0.6,2,1.7c0,0.3,0,0.7-0.1,1.1C26.1,27.4,25.8,29.2,25.8,29.6L25.8,29.6z"/><polyline class="masterCard-style-2-st3" points="20.8,29.7 19.3,29.7 20.2,24.3 18.3,29.7 17.2,29.7 17.1,24.3 16.2,29.7 14.8,29.7 16,22.6 18.1,22.6 18.2,27 19.7,22.6 22,22.6 20.8,29.7"/></g>',
										americanExpress: '<g><path class="americanExpress-style-2-st0" d="M7.6,1h56.7C68,1,71,4,71,7.6v36.7c0,3.7-3,6.6-6.6,6.6H7.6C4,51,1,48,1,44.4V7.6C1,4,4,1,7.6,1z"/><g><path class="americanExpress-style-2-st0" d="M44.1,35.5v-1.8c0-0.1-0.1-0.5-0.7-0.5h-1.2v2.3h-2.7v-3.3c-0.5,0.8-1.5,1.2-3.1,1.2h-1.2v2.2h-3.9l-1.6-1.8l-1.6,1.8H21v-7.7h7l1.8,1.9l1.8-1.9h1l0.5,0h4.2c0,0,0.1,0,0.2,0c0.3,0,0.9,0,1.5,0.4c0.2,0.1,0.4,0.3,0.6,0.6v-1h4.7c0,0,0.1,0,0.2,0c0.9,0,1.8,0.3,2.2,1.2v-1.2H53v1.1c0.5-0.8,1.4-1.1,2.2-1.1l3.9,0v1.1c0.5-0.8,1.4-1.1,2.2-1.1l3.9,0v2.6h-2c1.2,0.2,2.3,0.8,2.3,2.3c0,2.1-1.4,2.9-2.8,2.9c-0.2,0-0.3,0-0.3,0l-3.5,0v-1.1c-0.5,0.8-1.4,1.1-2.3,1.1c-0.2,0-0.3,0-0.3,0l-3.3,0v0h-6.2v0H44.1z M52.8,33v-0.1H56c0.1,0,0.1,0,0.2,0c0.1,0,0.1,0,0.2,0c-0.2,0-0.4-0.1-0.8-0.1c0,0-0.1,0-0.2,0c-0.3,0-1,0-1.6-0.4c-0.3-0.2-0.6-0.4-0.9-0.8v1.3h-3.6V33H52.8z M26.7,33l0.1-0.1h-3V33H26.7z M62.1,32.9c0.1,0,0.1,0,0.2,0c0.1,0,0.1,0,0.2,0c-0.2,0-0.4-0.1-0.8-0.1c0,0-0.1,0-0.2,0c-0.3,0-1,0-1.6-0.4c-0.2-0.1-0.4-0.2-0.6-0.4c0,0.2,0.1,0.4,0.1,0.6c0,0.1,0,0.2,0,0.3H62.1z M32.6,32.7v-2.1l-1,1L32.6,32.7z M46.3,31.8c0.1,0.2,0.3,0.4,0.4,0.6v-1.1C46.5,31.6,46.4,31.7,46.3,31.8z M27.3,32.4l0.6-0.7L27.3,31V32.4z M57.1,30.3c0.6,0.1,1.3,0.3,1.7,0.8c-0.1-0.2-0.1-0.5-0.1-0.8L57.1,30.3z M43.6,30.6c0.3,0,0.4-0.1,0.4-0.2c0,0-0.2-0.1-0.4-0.1h-1.3v0.3H43.6z M36.6,30.6c0.3,0,0.4-0.1,0.4-0.2c0,0-0.2-0.1-0.4-0.1h-1.3v0.3H36.6z M26.7,30.4L26.7,30.4l-2.9,0v0H26.7z M52.6,30.4C52.6,30.4,52.6,30.3,52.6,30.4l-3.2,0v0H52.6z M40,26.3L40,26.3l-2.5,0v-1.8c0-0.1-0.1-0.5-0.7-0.5h-1.2v2.3H23.9v-2.9l-1.3,2.9h-2.1l-1.4-2.9v2.9h-4.2l-0.6-1.4h-2.5l-0.6,1.4h-3l3.3-7.7h3.1l1.8,4.2v-4.2H20l1.6,3.5l1.6-3.5h14.5c0,0,0.1,0,0.2,0c0.9,0,1.8,0.3,2.2,1.2v-1.2h2.7v1.8c0.7-1.6,2.2-1.8,2.7-1.9l2.7,0.1v0.7l0.3-0.8h3.1l1.8,4.1v-4.1h3.2l1.9,3.1v-3.1h2.7v7.7h-3.2l-2-3.2v3.2h-4.2l-0.6-1.4h-2.5l-0.6,1.4h-3c-0.7-0.1-1.8-0.6-2.4-1.8v1.8H40z M32.9,23.8v-0.1h-3.5v0.1H32.9z M45.9,21.1c-0.1,0-0.7,0.1-0.8,1c0,0.1,0,0.3,0,0.4c0,1.2,0.6,1.2,0.8,1.2c0.1,0,0.3,0,0.4,0l1.1-2.6L45.9,21.1z M39.6,22.6c0.1,0.2,0.3,0.4,0.4,0.6v-1.1C39.9,22.3,39.8,22.5,39.6,22.6z M50.1,22.2L50,21.9l-0.1,0.2H50.1z M13.2,22.2l-0.1-0.2L13,22.2H13.2z M36.9,21.4c0.3,0,0.4-0.1,0.4-0.2c0,0-0.2-0.1-0.4-0.1h-1.3v0.3H36.9z M32.9,21.2L32.9,21.2l-3.5,0v0H32.9z"/><path class="americanExpress-style-2-st1" d="M45.5,19l2.1,0.1v1.5l-1.7,0c0,0-1.1,0-1.3,1.5c0,0.2,0,0.3,0,0.5c0,1.4,0.7,1.7,1.3,1.7c0.4,0,0.7-0.1,0.7-0.1l2.1-5h2.4l2.6,6.1v-6.1h2.4l2.7,4.4v-4.4h1.7v6.7h-2.4l-2.7-4.5v4.5h-1.5h-0.3h-1.6l-0.6-1.4h-3.2l-0.6,1.4h-1.6H46h-0.8c0,0-2.3-0.3-2.3-3.2C42.8,18.9,45.5,19,45.5,19 M49.2,22.7h1.7l-0.8-2L49.2,22.7 M37.8,19c0.5,0,2,0.2,2,2c0,1.2-1,1.6-1,1.6s0.8,0.4,0.8,1.5v1.7H38v-1.3c0,0-0.1-1-1.2-1h-1.7v2.3h-1.7v-6.7h4.2C37.6,19.1,37.7,19,37.8,19 M35.1,21.9h1.8c0.5,0,0.9-0.3,0.9-0.6c0-0.4-0.4-0.6-0.9-0.6h-1.8V21.9 M26.2,19.1v6.7h-1.7v-4.6l-2.2,4.6h-1.4l-2.2-4.6v4.6h-1.5h-0.2h-1.7l-0.6-1.4h-3.2l-0.6,1.4H9l2.9-6.7h2.4l2.6,6.2v-6.2h2.7l1.9,4.2l1.9-4.2H26.2 M12.2,22.7h1.7l-0.8-2L12.2,22.7 M32.5,19.1v1.6h-3.6v1h3.6v1.5h-3.6v1.1h3.6v1.5h-5.4v-6.7H32.5 M42.2,19.1v6.7h-1.7v-6.7H42.2 M37.5,28.2c0.5,0,2,0.2,2,2c0,2-0.7,2.6-3,2.6h-1.7V35h-1.7h-1.5l-1.8-2l-1.8,2h-1h-5.4v-6.7h5.4h0.9l2,2.1l2-2.1h1.3v0h4.2C37.3,28.3,37.4,28.2,37.5,28.2 M33.1,34v-4.7L31,31.7L33.1,34 M34.8,31.1h1.8c0.5,0,0.9-0.3,0.9-0.6c0-0.4-0.4-0.6-0.9-0.6h-1.8V31.1 M23.3,30.9h3.5v1.5h-3.5v1.1h3.6l1.7-1.9l-1.7-1.8h-3.6V30.9 M61.3,28.3C61.4,28.3,61.4,28.3,61.3,28.3l3.4,0v1.6H62c0,0-0.1,0-0.3,0c-0.3,0-0.7,0.1-0.7,0.5c0,0.4,0.8,0.5,1.1,0.5c0.1,0,0.2,0,0.2,0s0.1,0,0.2,0c0.6,0,2.5,0.1,2.5,1.8c0,2.2-1.7,2.4-2.3,2.4c-0.1,0-0.2,0-0.2,0h-3.1v-1.5h2.7c0,0,0.1,0,0.2,0c0.3,0,0.8-0.1,0.8-0.5c0-0.5-1.1-0.6-1.4-0.6c0,0-0.1,0-0.1,0s-0.1,0-0.2,0c-0.5,0-2.2-0.1-2.2-2C59.2,28.4,61,28.3,61.3,28.3 M55.2,28.3C55.3,28.3,55.3,28.3,55.2,28.3l3.4,0v1.6h-2.7c0,0-0.1,0-0.3,0c-0.3,0-0.7,0.1-0.7,0.5c0,0.4,0.8,0.5,1.1,0.5c0.1,0,0.2,0,0.2,0s0.1,0,0.2,0c0.6,0,2.5,0.1,2.5,1.8c0,2.2-1.7,2.4-2.3,2.4c-0.1,0-0.2,0-0.2,0h-3.1v-1.5H56c0,0,0.1,0,0.2,0c0.3,0,0.8-0.1,0.8-0.5c0-0.5-1.1-0.6-1.4-0.6c0,0-0.1,0-0.1,0s-0.1,0-0.2,0c-0.5,0-2.2-0.1-2.2-2C53.1,28.4,54.9,28.3,55.2,28.3 M44.5,28.3c0.5,0,2,0.2,2,2c0,1.2-1,1.6-1,1.6s0.8,0.4,0.8,1.5V35h-1.7v-1.3c0,0-0.1-1-1.2-1h-1.7V35h-1.7v-6.7h4.2C44.3,28.3,44.3,28.3,44.5,28.3 M41.8,31.1h1.8c0.5,0,0.9-0.3,0.9-0.6s-0.4-0.6-0.9-0.6h-1.8V31.1 M52.5,28.3v1.6h-3.6v1h3.6v1.5h-3.6v1.1h3.6V35h-5.4v-6.7H52.5 M45.4,18L45.4,18c-0.8,0.1-1.6,0.3-2.2,0.9v-0.8h-1h-1.7h-1v0.4C39,18.2,38.4,18,37.8,18h0c-0.1,0-0.2,0-0.3,0h-4.1h-1v0h-5.2v0h-1h-2.7h-0.6l-0.3,0.6l-1,2.2l-1-2.2l-0.3-0.6h-0.6h-2.7h-1v1v1.3l-0.7-1.7L15,18.1h-0.7h-2.4h-0.7l-0.3,0.6l-2.9,6.7l-0.6,1.4H9h1.9h0.7l0.3-0.6l0.3-0.8H14l0.3,0.8l0.3,0.6h0.7h1.7h0.2h1.5h1v-1v-0.1l0.3,0.6l0.3,0.6h0.6h1.4h0.6l0.3-0.6l0.3-0.6v0.1v1h1h1.7h1v0h5.2v0h1h1.7h1v-1v-1.3h0.7c0.1,0,0.1,0,0.1,0c0,0,0,0.1,0,0.1v1.2v1h1h1.5v0h1h1.7h1v-0.9c0.6,0.5,1.3,0.8,1.8,0.8l0.1,0h0.1H46h0.3h1.6h0.7l0.3-0.6l0.3-0.8h1.8l0.3,0.8l0.3,0.6h0.7h1.6h0.3h1.5h1v-1v-0.9l0.9,1.5l0.3,0.5h0.6h2.4h1v-1v-6.7v-1h-1H59h-1v1v0.9l-0.9-1.4l-0.3-0.5h-0.6h-2.4h-1v1v1.2l-0.7-1.6l-0.3-0.6h-0.7h-2.4h-0.7l0,0l-0.5,0L45.6,18L45.4,18L45.4,18z M46,23.2c-0.2,0-0.3,0-0.3-0.7c0-0.1,0-0.2,0-0.4c0.1-0.5,0.3-0.6,0.3-0.6l0.7,0L46,23.2C46,23.2,46,23.2,46,23.2L46,23.2z M37.5,27.2c-0.1,0-0.2,0-0.2,0h-4.1h-1v0h-0.3h-0.4L31,27.6l-1.3,1.3l-1.3-1.3l-0.3-0.3h-0.4h-0.9h-5.4h-1v1V35v1h1h5.4h1h0.4l0.3-0.3l1.1-1.2l1.1,1.2l0.3,0.3h0.4h1.5h1.7h1v-1v-1.2h0.7c1.1,0,1.9-0.2,2.6-0.5V35v1h1h1.7h1v-1v-1.3h0.7c0.1,0,0.1,0,0.1,0c0,0,0,0.1,0,0.1V35v1h1h1.7h1v0h5.2h1v0h2.8c0.1,0,0.1,0,0.3,0c0.6,0,1.2-0.1,1.8-0.5V36h1h3c0.1,0,0.1,0,0.3,0c1.5,0,3.3-0.9,3.3-3.4c0-0.7-0.2-1.3-0.6-1.8h0.3v-1v-1.6v-1h-1h-3.3c0,0,0,0-0.1,0c-0.6,0-1.2,0.1-1.7,0.4v-0.4h-1h-3.3c0,0,0,0-0.1,0c-0.6,0-1.2,0.1-1.7,0.4v-0.4h-1h-5.4h-1v0.4c-0.5-0.3-1.1-0.4-1.7-0.4c-0.1,0-0.2,0-0.3,0h-4.1h-1v0.4C38.6,27.4,38,27.2,37.5,27.2L37.5,27.2z"/></g></g>',
										payPal: '<g><path class="payPal-style-2-st0" d="M7.6,1h56.7C68,1,71,4,71,7.6v36.7c0,3.7-3,6.6-6.6,6.6H7.6C4,51,1,48,1,44.4V7.6C1,4,4,1,7.6,1z"/><path class="payPal-style-2-st1" d="M61.9,18.9l-1.8,11.2c0,0.2,0.1,0.4,0.4,0.4h1.8c0.3,0,0.5-0.2,0.6-0.5l1.7-11c0-0.2-0.1-0.4-0.4-0.4h-2C62.1,18.6,61.9,18.8,61.9,18.9"/><path class="payPal-style-2-st1" d="M56.6,26.6c-0.2,1.2-1.1,2-2.3,2c-0.6,0-1.1-0.2-1.4-0.6c-0.3-0.4-0.4-0.9-0.3-1.4c0.2-1.2,1.1-2,2.3-2c0.6,0,1.1,0.2,1.4,0.6C56.5,25.5,56.7,26.1,56.6,26.6 M59.4,22.6h-2.1c-0.2,0-0.3,0.1-0.4,0.3l-0.1,0.6l-0.1-0.2c-0.4-0.6-1.4-0.9-2.4-0.9c-2.3,0-4.2,1.7-4.6,4.1c-0.2,1.2,0.1,2.4,0.8,3.2c0.6,0.7,1.5,1,2.6,1c1.8,0,2.9-1.2,2.9-1.2l-0.1,0.6c0,0.2,0.1,0.4,0.4,0.4h1.9c0.3,0,0.5-0.2,0.6-0.5l1.1-7.1C59.8,22.8,59.7,22.6,59.4,22.6"/><path class="payPal-style-2-st1" d="M47,22.7c-0.2,1.5-1.4,1.5-2.6,1.5h-0.7l0.5-2.9c0-0.2,0.2-0.3,0.4-0.3h0.3c0.8,0,1.5,0,1.9,0.4C47.1,21.7,47.1,22.1,47,22.7 M46.5,18.6h-4.3c-0.3,0-0.5,0.2-0.6,0.5l-1.7,11c0,0.2,0.1,0.4,0.4,0.4h2.2c0.2,0,0.4-0.1,0.4-0.4l0.5-3.1c0-0.3,0.3-0.5,0.6-0.5h1.4c2.8,0,4.5-1.4,4.9-4.1c0.2-1.2,0-2.1-0.6-2.8C49.1,19,48,18.6,46.5,18.6"/><path class="payPal-style-2-st2" d="M39.7,22.6h-2.1c-0.2,0-0.4,0.1-0.5,0.3l-2.9,4.2L33,23c-0.1-0.3-0.3-0.4-0.6-0.4h-2c-0.2,0-0.4,0.2-0.3,0.5l2.3,6.7l-2.2,3c-0.2,0.2,0,0.6,0.3,0.6h2.1c0.2,0,0.4-0.1,0.5-0.3l6.9-9.9C40.1,22.9,39.9,22.6,39.7,22.6"/><path class="payPal-style-2-st2" d="M25.8,26.6c-0.2,1.2-1.1,2-2.3,2c-0.6,0-1.1-0.2-1.4-0.6c-0.3-0.4-0.4-0.9-0.3-1.4c0.2-1.2,1.1-2,2.3-2c0.6,0,1.1,0.2,1.4,0.6C25.7,25.5,25.8,26.1,25.8,26.6 M28.6,22.6h-2.1c-0.2,0-0.3,0.1-0.4,0.3l-0.1,0.6L26,23.3c-0.4-0.6-1.4-0.9-2.4-0.9c-2.3,0-4.2,1.7-4.6,4.1c-0.2,1.2,0.1,2.4,0.8,3.2c0.6,0.7,1.5,1,2.6,1c1.8,0,2.9-1.2,2.9-1.2l-0.1,0.6c0,0.2,0.1,0.4,0.4,0.4h1.9c0.3,0,0.5-0.2,0.6-0.5L29,23C29,22.8,28.9,22.6,28.6,22.6"/><path class="payPal-style-2-st2" d="M16.2,22.7c-0.2,1.5-1.4,1.5-2.6,1.5H13l0.5-2.9c0-0.2,0.2-0.3,0.4-0.3h0.3c0.8,0,1.5,0,1.9,0.4C16.2,21.7,16.3,22.1,16.2,22.7 M15.7,18.6h-4.3c-0.3,0-0.5,0.2-0.6,0.5l-1.7,11c0,0.2,0.1,0.4,0.4,0.4h2.1c0.3,0,0.5-0.2,0.6-0.5l0.5-3c0-0.3,0.3-0.5,0.6-0.5h1.4c2.8,0,4.5-1.4,4.9-4.1c0.2-1.2,0-2.1-0.6-2.8C18.3,19,17.2,18.6,15.7,18.6"/></g>',
										discover: '<g><path class="discover-style-2-st0" d="M7.7,1h56.6C68,1,71,4,71,7.7v36.6c0,3.7-3,6.7-6.7,6.7H7.7C4,51,1,48,1,44.3V7.7C1,4,4,1,7.7,1z"/><path class="discover-style-2-st1" d="M71,33.7v10.6c0,3.7-3,6.7-6.7,6.7H19.7C19.7,51,53,47.3,71,33.7z"/><path class="discover-style-2-st2" d="M66,23.9c0-1.9-1.2-3-3.3-3h-2.7v10h1.8v-4H62l2.5,4h2.3l-3-4.2C65.2,26.5,66,25.5,66,23.9L66,23.9zM62.3,25.6h-0.5v-3h0.6c1.1,0,1.8,0.5,1.8,1.5C64.1,25,63.4,25.6,62.3,25.6L62.3,25.6z"/><polyline class="discover-style-2-st2" points="53.4,31 58.7,31 58.7,29.3 55.3,29.3 55.3,26.6 58.5,26.6 58.5,24.9 55.3,24.9 55.3,22.7 58.7,22.7 58.7,21 53.4,21 53.4,31"/><polyline class="discover-style-2-st2" points="48.1,27.7 45.5,21 43.5,21 47.5,31.2 48.5,31.2 52.6,21 50.6,21 48.1,27.7"/><g><path class="discover-style-2-st3" d="M33.8,25.9c0,3,2.2,5.3,5,5.3c2.8,0,5-2.3,5-5.2c0-2.9-2.2-5.2-5-5.2C36.1,20.8,33.8,23.1,33.8,25.9z"/></g><g><path class="discover-style-2-st1" d="M33.8,25.9c0,3,2.2,5.3,5,5.3c2.8,0,5-2.3,5-5.2c0-2.9-2.2-5.2-5-5.2C36.1,20.8,33.8,23.1,33.8,25.9z"/></g><path class="discover-style-2-st2" d="M25.8,26c0,2.9,2.2,5.2,5,5.2c0.8,0,1.5-0.2,2.3-0.6v-2.3c-0.7,0.8-1.4,1.1-2.2,1.1c-1.9,0-3.2-1.4-3.2-3.5c0-1.9,1.4-3.4,3.1-3.4c0.9,0,1.5,0.3,2.3,1.1v-2.3c-0.8-0.4-1.5-0.6-2.3-0.6C28.1,20.8,25.8,23.1,25.8,26"/><path class="discover-style-2-st2" d="M22.5,24.8c-1.1-0.4-1.4-0.7-1.4-1.3c0-0.6,0.6-1.1,1.4-1.1c0.6,0,1,0.2,1.5,0.8l1-1.3c-0.8-0.7-1.7-1.1-2.8-1.1c-1.7,0-2.9,1.2-2.9,2.9c0,1.4,0.6,2.1,2.3,2.7c0.7,0.3,1.1,0.4,1.3,0.6c0.4,0.3,0.6,0.6,0.6,1c0,0.8-0.6,1.4-1.4,1.4c-0.9,0-1.6-0.5-2-1.3l-1.2,1.2c0.8,1.3,1.9,1.9,3.3,1.9c1.9,0,3.3-1.4,3.3-3.3C25.3,26.4,24.6,25.6,22.5,24.8"/><polygon class="discover-style-2-st2" points="16.2,21 18,21 18,31 16.2,31"/><path class="discover-style-2-st2" d="M10.3,21H7.6v10h2.7c1.4,0,2.5-0.4,3.4-1.2c1.1-0.9,1.7-2.4,1.7-3.8C15.4,23,13.3,21,10.3,21L10.3,21zM12.4,28.5c-0.6,0.6-1.3,0.8-2.5,0.8H9.4v-6.6h0.5c1.2,0,1.9,0.2,2.5,0.8c0.6,0.6,1,1.5,1,2.5C13.5,26.9,13.1,27.9,12.4,28.5L12.4,28.5z"/></g>'
									},
									style3: {
										visa: '<g><path class="visa-style-3-st0" d="M5,1h62c2.2,0,4,1.8,4,4v42c0,2.2-1.8,4-4,4H5c-2.2,0-4-1.8-4-4V5C1,2.8,2.8,1,5,1z"/><path class="visa-style-3-st1" d="M15,22h42c2.2,0,4,1.8,4,4v0c0,2.2-1.8,4-4,4H15c-2.2,0-4-1.8-4-4v0C11,23.8,12.8,22,15,22z"/><path class="visa-style-3-st1" d="M5,1h62c2.2,0,4,1.8,4,4v5H1V5C1,2.8,2.8,1,5,1z"/><path class="visa-style-3-st2" d="M71,42v5c0,2.2-1.8,4-4,4H5c-2.2,0-4-1.8-4-4v-5H71z"/></g>',
										masterCard: '<g><path class="masterCard-style-3-st0" d="M5,1h62c2.2,0,4,1.8,4,4v42c0,2.2-1.8,4-4,4H5c-2.2,0-4-1.8-4-4V5C1,2.8,2.8,1,5,1z"/><g transform="translate(12.526316, 11.194030)"><path class="masterCard-style-3-st1" d="M23.8,4.6c-2.4-2.1-5.5-3.3-8.8-3.3C7.5,1.3,1.4,7.4,1.4,15.1S7.5,28.9,15,28.9c3.4,0,6.5-1.2,8.8-3.3c2.4,2.1,5.5,3.3,8.8,3.3c7.5,0,13.6-6.2,13.6-13.8S40.2,1.3,32.7,1.3C29.3,1.3,26.2,2.5,23.8,4.6z"/><path class="masterCard-style-3-st2" d="M23.8,4.6c-2.4-2.1-5.5-3.3-8.8-3.3C7.5,1.3,1.4,7.4,1.4,15.1S7.5,28.9,15,28.9c3.4,0,6.5-1.2,8.8-3.3c-2.9-2.5-4.8-6.3-4.8-10.5S20.9,7.1,23.8,4.6z"/><path class="masterCard-style-3-st3" d="M23.8,25.6c2.4,2.1,5.5,3.3,8.8,3.3c7.5,0,13.6-6.2,13.6-13.8S40.2,1.3,32.7,1.3c-3.4,0-6.5,1.2-8.8,3.3c2.9,2.5,4.8,6.3,4.8,10.5S26.8,23,23.8,25.6z"/></g><path class="masterCard-style-3-st4" d="M24.2,22h25c2.2,0,4,1.8,4,4v0c0,2.2-1.8,4-4,4h-25c-2.2,0-4-1.8-4-4v0C20.2,23.8,22,22,24.2,22z"/></g>',
										americanExpress: '<g><path class="americanExpress-style-3-st0" d="M5,1h62c2.2,0,4,1.8,4,4v42c0,2.2-1.8,4-4,4H5c-2.2,0-4-1.8-4-4V5C1,2.8,2.8,1,5,1z"/><path class="americanExpress-style-3-st1" d="M15.2,21h42c2.2,0,4,1.8,4,4v0c0,2.2-1.8,4-4,4h-42c-2.2,0-4-1.8-4-4v0C11.2,22.8,13,21,15.2,21z"/></g>',
										payPal: '<g><path class="payPal-style-3-st0" d="M5,1h62c2.2,0,4,1.8,4,4v42c0,2.2-1.8,4-4,4H5c-2.2,0-4-1.8-4-4V5C1,2.8,2.8,1,5,1z"/><path class="payPal-style-3-st1" d="M26.4,31.2l3-18.8c0.3-2.2,2.4-3.7,4.6-3.3l0,0c2.2,0.3,3.7,2.4,3.3,4.6l-3,18.8c-0.3,2.2-2.4,3.7-4.6,3.3h0C27.6,35.5,26.1,33.4,26.4,31.2z"/><path class="payPal-style-3-st2" d="M36.7,38.3l3-18.8c0.3-2.2,2.4-3.7,4.6-3.3h0c2.2,0.3,3.7,2.4,3.3,4.6l-3,18.8c-0.3,2.2-2.4,3.7-4.6,3.3h0C37.8,42.5,36.3,40.5,36.7,38.3z"/></g>',
										discover: '<g><path class="discover-style-3-st0" d="M7.7,1h56.6C68,1,71,4,71,7.7v36.6c0,3.7-3,6.7-6.7,6.7H7.7C4,51,1,48,1,44.3V7.7C1,4,4,1,7.7,1z"/><path class="discover-style-3-st1" d="M71,33.7v10.6c0,3.7-3,6.7-6.7,6.7H19.7C19.7,51,53,47.3,71,33.7z"/>	<path class="discover-style-3-st1" d="M33.8,25.9c0,3,2.2,5.3,5,5.3c2.8,0,5-2.3,5-5.2c0-2.9-2.2-5.2-5-5.2C36.1,20.8,33.8,23.1,33.8,25.9z"/><path class="discover-style-3-st2" d="M11.7,21.9h15c2.2,0,4,1.8,4,4v0c0,2.2-1.8,4-4,4h-15c-2.2,0-4-1.8-4-4v0C7.7,23.7,9.5,21.9,11.7,21.9z"/><path class="discover-style-3-st2" d="M51.7,21.9h9c2.2,0,4,1.8,4,4v0c0,2.2-1.8,4-4,4h-9c-2.2,0-4-1.8-4-4v0C47.7,23.7,49.5,21.9,51.7,21.9z"/></g>'
									},
									style4: {
										visa: '<g><polygon class="visa-style-4-st0" points="52.3,28.1 55.5,28.1 54.3,22.7"/><path class="visa-style-4-st0" d="M64.4,1H7.6C4,1,1,4,1,7.6v36.7C1,48,4,51,7.6,51h56.7c3.7,0,6.6-3,6.6-6.6V7.6C71,4,68,1,64.4,1z M20.4,33.3L17,20.6c0,0-0.1,0-0.1,0c-0.2-0.1-0.5-0.3-0.7-0.4c0,0,0,0-0.1,0c-0.2-0.1-0.5-0.2-0.7-0.3c0,0-0.1,0-0.1,0c-0.4-0.2-0.8-0.4-1.2-0.5c0,0,0,0-0.1,0c-0.2-0.1-0.3-0.1-0.5-0.2c0,0,0,0,0,0c-0.1,0-0.3-0.1-0.3-0.1c0,0,0,0,0,0c-0.1,0-0.2,0-0.2-0.1c0,0,0,0,0,0c0,0-0.1,0-0.1,0l0.1-0.2h3h3c1.7,0,1.8,1.3,1.8,1.3l1.3,6.5v0l0.4,2.2l3.7-10h4.1l-6.1,14.5H20.4z M29.6,33.3L32,18.7h3.8l-2.4,14.5H29.6z M40.1,33.5c-2.6,0-4.3-0.8-4.3-0.8l0.6-3.3c1.6,1.2,6.3,1.6,6.3-0.4c0-2-5.3-2-5.3-5.8c0-4,4.5-4.8,6.4-4.8c1.8,0,3.5,0.6,3.5,0.6l-0.5,3.1c-1.6-0.9-5.4-1.1-5.4,0.5c0,1.6,5.4,2,5.4,5.8C46.7,32.2,42.7,33.5,40.1,33.5z M56.5,33.3l-0.4-2.2h-4.9l-0.8,2.2h-4l5.7-13.5c0,0,0.3-1.1,1.8-1.1H57l3.1,14.5H56.5z"/></g>',
										masterCard: '<g><g><path class="masterCard-style-4-st0" d="M39.2,18.6C39.2,18.6,39.2,18.6,39.2,18.6C39.2,18.6,39.2,18.6,39.2,18.6L39.2,18.6z"/><path class="masterCard-style-4-st0" d="M40,31.9C40,31.9,40,31.9,40,31.9L40,31.9C40,31.9,40,31.9,40,31.9z"/><path class="masterCard-style-4-st0" d="M39.2,33.4C39.2,33.4,39.2,33.4,39.2,33.4C39.2,33.4,39.2,33.4,39.2,33.4L39.2,33.4z"/><path class="masterCard-style-4-st0" d="M64.4,1H7.6C4,1,1,4,1,7.6v36.7C1,48,4,51,7.6,51h56.7c3.7,0,6.6-3,6.6-6.6V7.6C71,4,68,1,64.4,1z M46.1,39.9c-3.6,0-6.9-1.4-9.4-3.6c0,0,0,0,0.1-0.1c-2.5,2.3-5.8,3.7-9.4,3.7c-7.7,0-14-6.2-14-13.9c0-7.7,6.2-13.9,14-13.9c3.6,0,6.9,1.4,9.3,3.6c0,0,0,0,0,0c2.5-2.2,5.8-3.6,9.4-3.6c7.7,0,14,6.2,14,13.9C60.1,33.7,53.8,39.9,46.1,39.9z"/><path class="masterCard-style-4-st0" d="M40,20.1C40,20.1,40,20.1,40,20.1C40,20.1,40,20.1,40,20.1L40,20.1z"/></g><path class="masterCard-style-4-st0" d="M57.7,29.7h-1.4l0.1-0.5c-0.4,0.4-0.8,0.6-1.4,0.6c-1.1,0-1.8-0.9-1.8-2.4c0-1.9,1.1-3.5,2.5-3.5c0.6,0,1,0.2,1.4,0.8l0.3-2h1.5L57.7,29.7L57.7,29.7z M55.5,28.4c0.7,0,1.2-0.8,1.2-1.9c0-0.7-0.3-1.1-0.8-1.1c-0.7,0-1.2,0.8-1.2,1.9C54.7,28,55,28.4,55.5,28.4L55.5,28.4z"/><path class="masterCard-style-4-st0" d="M50.9,23.8c-0.2,1.8-0.5,3.6-0.8,5.4L50,29.5h1.5c0.5-3.5,0.7-4.2,1.5-4.1c0.1-0.7,0.4-1.4,0.6-1.7c-0.6-0.1-1,0.2-1.5,0.9c0-0.3,0.1-0.6,0.1-0.9H50.9"/><path class="masterCard-style-4-st0" d="M48.5,27.1c-0.2,0-0.2,0-0.3,0c-0.9,0-1.3,0.3-1.3,0.9c0,0.4,0.2,0.6,0.5,0.6C48,28.5,48.5,27.9,48.5,27.1L48.5,27.1z M49.6,29.6h-1.3l0-0.6c-0.4,0.5-0.9,0.7-1.6,0.7c-0.8,0-1.4-0.6-1.4-1.6c0-1.4,1-2.2,2.7-2.2c0.2,0,0.4,0,0.6,0c0-0.2,0.1-0.3,0.1-0.4c0-0.4-0.3-0.5-1-0.5c-0.7,0-1.4,0.2-1.6,0.3c0-0.1,0.2-1.3,0.2-1.3c0.8-0.2,1.3-0.3,1.8-0.3c1.3,0,2,0.6,2,1.7c0,0.3,0,0.7-0.1,1.1C49.9,27.4,49.7,29.2,49.6,29.6L49.6,29.6z"/><path class="masterCard-style-4-st0" d="M46.1,22.8l-0.2,1.5c-0.5-0.3-0.9-0.4-1.4-0.4c-1.1,0-1.9,1.1-1.9,2.6c0,1.1,0.5,1.7,1.4,1.7c0.4,0,0.8-0.1,1.3-0.4L45,29.6c-0.6,0.2-0.9,0.2-1.3,0.2c-1.6,0-2.6-1.2-2.6-3.1c0-2.5,1.4-4.3,3.4-4.3C45.1,22.4,45.9,22.7,46.1,22.8"/><path class="masterCard-style-4-st0" d="M38.6,23.8c-0.2,1.8-0.5,3.6-0.8,5.4l-0.1,0.4h1.5c0.5-3.5,0.7-4.2,1.5-4.1c0.1-0.7,0.4-1.4,0.6-1.7c-0.6-0.1-1,0.2-1.5,0.9c0-0.3,0.1-0.6,0.1-0.9H38.6"/><path class="masterCard-style-4-st0" d="M37.2,29.5c-0.5,0.2-1,0.2-1.5,0.2c-1.7,0-2.6-0.9-2.6-2.6c0-2,1.1-3.4,2.6-3.4c1.2,0,2,0.8,2,2.1c0,0.4-0.1,0.8-0.2,1.4h-3c-0.1,0.8,0.4,1.2,1.3,1.2c0.5,0,1-0.1,1.6-0.4L37.2,29.5L37.2,29.5z M36.3,26.1c0-0.1,0.2-1-0.7-1c-0.5,0-0.8,0.4-1,1H36.3L36.3,26.1z"/><path class="masterCard-style-4-st0" d="M32.5,29.6c-0.4,0.1-0.7,0.2-1.1,0.2c-0.8,0-1.2-0.4-1.2-1.3c0-0.3,0.1-0.9,0.2-1.5c0.1-0.5,0.7-3.9,0.7-3.9h1.5l-0.2,0.9h0.8L33,25.3h-0.8c-0.2,1.1-0.4,2.5-0.4,2.6c0,0.3,0.2,0.4,0.5,0.4c0.2,0,0.3,0,0.4-0.1L32.5,29.6"/><path class="masterCard-style-4-st0" d="M26.6,25.7c0,0.7,0.4,1.2,1.2,1.6c0.6,0.3,0.7,0.4,0.7,0.6c0,0.4-0.3,0.5-0.9,0.5c-0.5,0-0.9-0.1-1.4-0.2c0,0-0.2,1.3-0.2,1.3c0.3,0.1,0.7,0.1,1.6,0.2c1.6,0,2.3-0.6,2.3-1.9c0-0.8-0.3-1.3-1.1-1.6c-0.6-0.3-0.7-0.4-0.7-0.6c0-0.3,0.3-0.5,0.7-0.5c0.3,0,0.7,0,1.1,0.1l0.2-1.3c-0.4-0.1-1-0.1-1.3-0.1C27.2,23.7,26.6,24.6,26.6,25.7"/><path class="masterCard-style-4-st0" d="M24.7,27.1c-0.2,0-0.2,0-0.3,0c-0.9,0-1.3,0.3-1.3,0.9c0,0.4,0.2,0.6,0.5,0.6C24.2,28.5,24.7,27.9,24.7,27.1L24.7,27.1z M25.8,29.6h-1.3l0-0.6c-0.4,0.5-0.9,0.7-1.6,0.7c-0.8,0-1.4-0.6-1.4-1.6c0-1.4,1-2.2,2.7-2.2c0.2,0,0.4,0,0.6,0c0-0.2,0.1-0.3,0.1-0.4c0-0.4-0.3-0.5-1-0.5c-0.7,0-1.4,0.2-1.6,0.3c0-0.1,0.2-1.3,0.2-1.3c0.8-0.2,1.3-0.3,1.8-0.3c1.3,0,2,0.6,2,1.7c0,0.3,0,0.7-0.1,1.1C26.1,27.4,25.8,29.2,25.8,29.6L25.8,29.6z"/><polyline class="masterCard-style-4-st0" points="20.8,29.7 19.3,29.7 20.2,24.3 18.3,29.7 17.2,29.7 17.1,24.3 16.2,29.7 14.8,29.7 16,22.6 18.1,22.6 18.2,27 19.7,22.6 22,22.6 20.8,29.7"/></g>',
										americanExpress: '<g><path class="americanExpress-style-4-st0" d="M37.5,28.2c-0.1,0-0.2,0-0.2,0h-4.2v0h-1.3l-2,2.1l-2-2.1h-0.9h-5.4V35h5.4h1l1.8-2l1.8,2h1.5h1.7v-2.2h1.7c2.2,0,3-0.6,3-2.6C39.5,28.4,38,28.2,37.5,28.2z M26.9,33.5h-3.6v-1.1h3.5v-1.5h-3.5v-1h3.6l1.7,1.8L26.9,33.5z M33.1,34L31,31.7l2.1-2.3V34z M36.6,31.1h-1.8v-1.3h1.8c0.5,0,0.9,0.3,0.9,0.6C37.5,30.8,37.1,31.1,36.6,31.1z"/><path class="americanExpress-style-4-st0" d="M45.6,22.1c0,0.1,0,0.3,0,0.4c0,0.7,0.2,0.7,0.3,0.7c0,0,0,0,0,0l0.7-1.6l-0.7,0C45.9,21.6,45.7,21.6,45.6,22.1z"/><rect x="40.5" y="19.1" class="americanExpress-style-4-st0" width="1.7" height="6.7"/><polygon class="americanExpress-style-4-st0" points="32.5,24.3 28.9,24.3 28.9,23.2 32.4,23.2 32.4,21.7 28.9,21.7 28.9,20.6 32.5,20.6 32.5,19.1 27.1,19.1 27.1,25.8 32.5,25.8 	"/><path class="americanExpress-style-4-st0" d="M45.1,25.8H46h0.3h1.6l0.6-1.4h3.2l0.6,1.4h1.6h0.3h1.5v-4.5l2.7,4.5h2.4v-6.7H59v4.4l-2.7-4.4h-2.4v6.1l-2.6-6.1h-2.4l-2.1,5c0,0-0.3,0.1-0.7,0.1c-0.6,0-1.3-0.3-1.3-1.7c0-0.1,0-0.3,0-0.5c0.1-1.5,1.3-1.5,1.3-1.5l1.7,0v-1.5L45.5,19c-0.1,0-2.7-0.1-2.7,3.6C42.8,25.4,45.1,25.8,45.1,25.8z M50,20.6l0.8,2h-1.7L50,20.6z"/><path class="americanExpress-style-4-st0" d="M56.5,30.8c-0.1,0-0.2,0-0.2,0s-0.1,0-0.2,0c-0.3,0-1.1,0-1.1-0.5c0-0.4,0.4-0.5,0.7-0.5c0.2,0,0.3,0,0.3,0h2.7v-1.6h-3.3c0,0,0,0-0.1,0c-0.4,0-2.1,0.1-2.1,2.1c0,1.9,1.7,2,2.2,2c0.1,0,0.2,0,0.2,0s0,0,0.1,0c0.3,0,1.4,0,1.4,0.6c0,0.5-0.5,0.5-0.8,0.5c-0.1,0-0.2,0-0.2,0h-2.7V35h3.1c0,0,0.1,0,0.2,0c0.6,0,2.3-0.2,2.3-2.4C58.9,30.9,57,30.8,56.5,30.8z"/><path class="americanExpress-style-4-st0" d="M62.5,30.8c-0.1,0-0.2,0-0.2,0s-0.1,0-0.2,0c-0.3,0-1.1,0-1.1-0.5c0-0.4,0.4-0.5,0.7-0.5c0.2,0,0.3,0,0.3,0h2.7v-1.6h-3.3c0,0,0,0-0.1,0c-0.4,0-2.1,0.1-2.1,2.1c0,1.9,1.7,2,2.2,2c0.1,0,0.2,0,0.2,0s0,0,0.1,0c0.3,0,1.4,0,1.4,0.6c0,0.5-0.5,0.5-0.8,0.5c-0.1,0-0.2,0-0.2,0h-2.7V35h3.1c0,0,0.1,0,0.2,0c0.6,0,2.3-0.2,2.3-2.4C65,30.9,63.1,30.8,62.5,30.8z"/><path class="americanExpress-style-4-st0" d="M46.4,30.2c0-1.8-1.4-2-2-2c-0.1,0-0.2,0-0.2,0h-4.2V35h1.7v-2.3h1.7c1.1,0,1.2,1,1.2,1V35h1.7v-1.7c0-1.1-0.8-1.5-0.8-1.5S46.4,31.4,46.4,30.2z M43.6,31.1h-1.8v-1.3h1.8c0.5,0,0.9,0.3,0.9,0.6S44.1,31.1,43.6,31.1z"/><path class="americanExpress-style-4-st0" d="M64.4,1H7.6C4,1,1,4,1,7.6v36.7C1,48,4,51,7.6,51h56.7c3.7,0,6.6-3,6.6-6.6V7.6C71,4,68,1,64.4,1z M19.9,26.2l-0.3-0.6v0.1v1h-1h-1.5h-0.2h-1.7h-0.7l-0.3-0.6L14,25.4h-1.8l-0.3,0.8l-0.3,0.6h-0.7H9H7.5l0.6-1.4l2.9-6.7l0.3-0.6h0.7h2.4H15l0.3,0.6l0.7,1.7v-1.3v-1h1h2.7h0.6l0.3,0.6l1,2.2l1-2.2l0.3-0.6h0.6h2.7h1v0h5.2v0h1h4.1c0.1,0,0.1,0,0.3,0c0.6,0,1.2,0.1,1.7,0.4v-0.4h1h1.7h1v0.8c0.6-0.5,1.4-0.8,2.2-0.9l0,0l0.1,0l2.1,0.1l0.5,0l0,0h0.7h2.4h0.7l0.3,0.6l0.7,1.6v-1.2v-1h1h2.4h0.6l0.3,0.5l0.9,1.4v-0.9v-1h1h1.7h1v1v6.7v1h-1h-2.4h-0.6l-0.3-0.5l-0.9-1.5v0.9v1h-1h-1.5h-0.3h-1.6h-0.7l-0.3-0.6l-0.3-0.8h-1.8l-0.3,0.8l-0.3,0.6h-0.7h-1.6H46h-0.8h-0.1l-0.1,0c-0.5-0.1-1.2-0.3-1.8-0.8v0.9h-1h-1.7h-1v0H38h-1v-1v-1.2c0,0,0-0.1,0-0.1c0,0,0,0-0.1,0h-0.7v1.3v1h-1h-1.7h-1v0h-5.2v0h-1h-1.7h-1v-1v-0.1l-0.3,0.6l-0.3,0.6h-0.6h-1.4h-0.6L19.9,26.2z M62.7,36c-0.1,0-0.2,0-0.3,0h-3h-1v-0.5c-0.6,0.3-1.2,0.5-1.8,0.5c-0.1,0-0.2,0-0.3,0h-2.8v0h-1h-5.2v0h-1h-1.7h-1v-1v-1.2c0,0,0-0.1,0-0.1c0,0,0,0-0.1,0h-0.7V35v1h-1h-1.7h-1v-1v-1.7c-0.6,0.3-1.5,0.5-2.6,0.5h-0.7V35v1h-1h-1.7h-1.5h-0.4l-0.3-0.3l-1.1-1.2l-1.1,1.2L28.4,36h-0.4h-1h-5.4h-1v-1v-6.7v-1h1h5.4h0.9h0.4l0.3,0.3l1.3,1.4l1.3-1.3l0.3-0.3h0.4h0.3v0h1h4.1c0.1,0,0.1,0,0.2,0c0.5,0,1.1,0.1,1.6,0.4v-0.4h1h4.1c0.1,0,0.1,0,0.3,0c0.6,0,1.2,0.1,1.7,0.4v-0.4h1h5.4h1v0.4c0.5-0.3,1.1-0.4,1.7-0.4c0,0,0.1,0,0.1,0h3.3h1v0.4c0.5-0.3,1.1-0.4,1.7-0.4c0,0,0.1,0,0.1,0h3.3h1v1v1.6v1h-0.3c0.4,0.5,0.6,1.1,0.6,1.8C66,35.1,64.2,36,62.7,36z"/><path class="americanExpress-style-4-st0" d="M35.1,23.4h1.7c1.1,0,1.2,1,1.2,1v1.3h1.7v-1.7c0-1.1-0.8-1.5-0.8-1.5s1-0.4,1-1.6c0-1.8-1.4-2-2-2c-0.1,0-0.2,0-0.2,0h-4.2v6.7h1.7V23.4z M35.1,20.6h1.8c0.5,0,0.9,0.3,0.9,0.6c0,0.4-0.4,0.6-0.9,0.6h-1.8V20.6z"/><path class="americanExpress-style-4-st0" d="M22.2,25.8l2.2-4.6v4.6h1.7v-6.7h-2.7l-1.9,4.2l-1.9-4.2h-2.7v6.2l-2.6-6.2h-2.4L9,25.8h1.9l0.6-1.4h3.2l0.6,1.4h1.7h0.2h1.5v-4.6l2.2,4.6H22.2z M12.2,22.7l0.8-2l0.8,2H12.2z"/><polygon class="americanExpress-style-4-st0" points="47.2,35 52.5,35 52.5,33.5 48.9,33.5 48.9,32.4 52.5,32.4 52.5,30.9 48.9,30.9 48.9,29.8 52.5,29.8 52.5,28.3 47.2,28.3 	"/></g>',
										payPal: '<g><path class="payPal-style-4-st0" d="M54.8,24.6c-1.2,0-2.1,0.8-2.3,2c-0.1,0.6,0,1.1,0.3,1.4c0.3,0.4,0.8,0.6,1.4,0.6c1.2,0,2.1-0.8,2.3-2c0.1-0.6,0-1.1-0.4-1.5C55.9,24.8,55.4,24.6,54.8,24.6z"/><g><path class="payPal-style-4-st0" d="M44.9,21h-0.3c-0.2,0-0.3,0.1-0.4,0.3l-0.5,2.9h0.7c1.1,0,2.3,0,2.6-1.5c0.1-0.5,0-0.9-0.2-1.2C46.4,21,45.7,21,44.9,21z"/><g><g><path class="payPal-style-4-st0" d="M14.1,21h-0.3c-0.2,0-0.3,0.1-0.4,0.3L13,24.2h0.7c1.1,0,2.3,0,2.6-1.5c0.1-0.5,0-0.9-0.2-1.2C15.6,21,14.9,21,14.1,21z"/><path class="payPal-style-4-st0" d="M64.4,1H7.6C4,1,1,4,1,7.6v36.7C1,48,4,51,7.6,51h56.7c3.7,0,6.6-3,6.6-6.6V7.6C71,4,68,1,64.4,1zM14.5,26.6h-1.4c-0.3,0-0.5,0.2-0.6,0.5l-0.5,3c0,0.3-0.3,0.5-0.6,0.5H9.4c-0.2,0-0.4-0.2-0.4-0.4l1.7-11c0-0.3,0.3-0.5,0.6-0.5h4.3c1.4,0,2.5,0.4,3.1,1.1c0.6,0.7,0.7,1.6,0.6,2.8C19,25.2,17.4,26.6,14.5,26.6z M27.9,30.1c0,0.3-0.3,0.5-0.6,0.5h-1.9c-0.2,0-0.4-0.2-0.4-0.4l0.1-0.6c0,0-1,1.2-2.9,1.2c-1.1,0-2-0.3-2.6-1c-0.7-0.8-1-2-0.8-3.2c0.4-2.4,2.3-4.1,4.6-4.1c1,0,2,0.2,2.4,0.9l0.1,0.2l0.1-0.6c0-0.2,0.2-0.3,0.4-0.3h2.1c0.2,0,0.4,0.2,0.4,0.4L27.9,30.1zM32.5,33.4h-2.1c-0.3,0-0.5-0.3-0.3-0.6l2.2-3L30,23.1c-0.1-0.2,0.1-0.5,0.3-0.5h2c0.3,0,0.5,0.2,0.6,0.4l1.2,4l2.9-4.2c0.1-0.2,0.3-0.3,0.5-0.3h2.1c0.3,0,0.5,0.3,0.3,0.6L33,33.1C32.9,33.3,32.7,33.4,32.5,33.4z M45.3,26.6H44c-0.3,0-0.5,0.2-0.6,0.5l-0.5,3.1c0,0.2-0.2,0.4-0.4,0.4h-2.2c-0.2,0-0.4-0.2-0.4-0.4l1.7-11c0-0.3,0.3-0.5,0.6-0.5h4.3c1.4,0,2.5,0.4,3.1,1.1c0.6,0.7,0.7,1.6,0.6,2.8C49.8,25.2,48.2,26.6,45.3,26.6z M58.7,30.1c0,0.3-0.3,0.5-0.6,0.5h-1.9c-0.2,0-0.4-0.2-0.4-0.4l0.1-0.6c0,0-1,1.2-2.9,1.2c-1.1,0-2-0.3-2.6-1c-0.7-0.8-1-2-0.8-3.2c0.4-2.4,2.3-4.1,4.6-4.1c1,0,2,0.2,2.4,0.9l0.1,0.2l0.1-0.6c0-0.2,0.2-0.3,0.4-0.3h2.1c0.2,0,0.4,0.2,0.4,0.4L58.7,30.1z M62.8,30.1c0,0.3-0.3,0.5-0.6,0.5h-1.8c-0.2,0-0.4-0.2-0.4-0.4l1.8-11.2c0-0.2,0.2-0.3,0.4-0.3h2c0.2,0,0.4,0.2,0.4,0.4L62.8,30.1z"/></g><path class="payPal-style-4-st0" d="M24,24.6c-1.2,0-2.1,0.8-2.3,2c-0.1,0.6,0,1.1,0.3,1.4c0.3,0.4,0.8,0.6,1.4,0.6c1.2,0,2.1-0.8,2.3-2c0.1-0.6,0-1.1-0.4-1.5C25.1,24.8,24.6,24.6,24,24.6z"/></g></g></g>',
										discover: '<g><path class="discover-style-4-st0" d="M9.9,22.7H9.4v6.6h0.5c1.2,0,1.9-0.2,2.5-0.8c0.6-0.6,1-1.6,1-2.5c0-1-0.4-1.9-1-2.5C11.8,22.9,11.1,22.7,9.9,22.7z"/><path class="discover-style-4-st0" d="M64.3,1H7.7C4,1,1,4,1,7.7v36.6C1,48,4,51,7.7,51h56.6c3.7,0,6.7-3,6.7-6.7V7.7C71,4,68,1,64.3,1z M13.6,29.8c-0.9,0.8-1.9,1.2-3.4,1.2H7.6V21h2.7c3,0,5.1,2.1,5.1,5C15.4,27.5,14.7,28.9,13.6,29.8z M18,31h-1.8V21H18V31z M22,31.2c-1.4,0-2.4-0.6-3.3-1.9l1.2-1.2c0.4,0.9,1.1,1.3,2,1.3c0.8,0,1.4-0.6,1.4-1.4c0-0.4-0.2-0.8-0.6-1c-0.2-0.1-0.6-0.3-1.3-0.6c-1.7-0.7-2.3-1.4-2.3-2.7c0-1.6,1.3-2.9,2.9-2.9c1,0,2,0.4,2.8,1.1l-1,1.3c-0.5-0.6-0.9-0.8-1.5-0.8c-0.8,0-1.4,0.5-1.4,1.1c0,0.5,0.3,0.8,1.4,1.3c2.1,0.8,2.7,1.5,2.7,3.1C25.3,29.9,23.9,31.2,22,31.2z M33.1,23.7c-0.8-0.8-1.4-1.1-2.3-1.1c-1.7,0-3.1,1.5-3.1,3.4c0,2,1.3,3.5,3.2,3.5c0.8,0,1.5-0.3,2.2-1.1v2.3c-0.8,0.4-1.5,0.6-2.3,0.6c-2.8,0-5-2.3-5-5.2c0-2.9,2.2-5.2,5-5.2c0.8,0,1.5,0.2,2.3,0.6V23.7z M38.9,31.2c-2.9,0-5-2.3-5-5.3c0-2.8,2.3-5.1,5-5.1c2.8,0,5,2.3,5,5.2C43.9,28.9,41.7,31.2,38.9,31.2z M48.5,31.2h-1l-4-10.3h2l2.5,6.7l2.5-6.7h2L48.5,31.2z M58.7,22.7h-3.4v2.2h3.3v1.7h-3.3v2.7h3.4V31h-5.2V21h5.2V22.7z M64.5,31L62,27h-0.2v4h-1.8V21h2.7c2.1,0,3.3,1.1,3.3,3c0,1.5-0.8,2.5-2.2,2.8l3,4.2H64.5z"/><path class="discover-style-4-st0" d="M62.3,22.6h-0.6v3h0.5c1.2,0,1.8-0.5,1.8-1.5C64.1,23.1,63.4,22.6,62.3,22.6z"/></g>'
									}
								}
							} );
						},
						"rating.js": function (exports, module, require) {
							module.exports = require( './_base' ).extend( {
								setup_defaults: function () {
									this.data = {
										value: 2.5,
										max: 5,
										style: 'style1'
									};
								},
								/**
								 * Build the html for the star rating
								 *
								 * @param {Number} [rating] optional
								 * @param {Number} [total] optional
								 * @param {String} [style] optional
								 *
								 * @return {String}
								 */
								get_html: function ( rating, total, style ) {
									rating = typeof rating === 'undefined' ? this.data.value : rating;
									total = typeof total === 'undefined' ? this.data.max : total;
									style = typeof style === 'undefined' ? this.data.style : style;

									var html = '',
										viewbox = this.templates[style].viewbox || '-6 -6 70 70',
										full = Math.floor( rating ),
										half = Math.round( rating - full );

									for ( var i = 1; i <= total; i ++ ) {
										var _type = 'full';
										if ( i > full && i <= full + half ) {
											_type = 'half';
										} else if ( i > full + half ) {
											_type = 'empty';
										}
										html += '<svg viewBox="' + viewbox + '" class="">' + this.templates[style][_type] + '</svg>';
									}

									return html;
								},
								_render_to: function ( $element, add_undo_step ) {
									$element.attr( {
										'data-style': this.data.style,
										'data-max': this.data.max,
										'data-value': this.data.value
									} ).html( this.get_html() );

									return this;
								},
								get_styles: function () {
									var styles = {};
									_.each( this.templates, function ( style, key ) {
										styles[key] = {label: TVE.firstLetterUppercase( key ), html: this.get_html( 2.5, 5, key )};
									}, this );

									return styles;
								},
								templates: {
									style1: {
										empty: '<path class="sr-background" fill="transparent" d="M46.976,57.227c-0.422,0-0.834-0.104-1.228-0.312l-13.167-6.921c-0.663-0.349-1.409-0.533-2.158-0.533s-1.495,0.185-2.158,0.533L15.1,56.915c-0.393,0.208-0.807,0.312-1.229,0.312c-0.765,0-1.524-0.358-2.03-0.958c-0.501-0.595-0.703-1.353-0.569-2.134l2.515-14.661c0.258-1.505-0.241-3.039-1.334-4.105L1.8,24.985c-0.736-0.717-0.985-1.728-0.668-2.704c0.318-0.977,1.114-1.649,2.13-1.796l14.72-2.139c1.512-0.22,2.817-1.168,3.493-2.537L28.059,2.47C28.513,1.55,29.396,1,30.423,1c1.027,0,1.911,0.55,2.365,1.471l6.584,13.339c0.676,1.369,1.98,2.317,3.492,2.537l14.721,2.139c1.016,0.147,1.813,0.819,2.129,1.795c0.317,0.977,0.068,1.988-0.668,2.705L48.394,35.369c-1.092,1.065-1.59,2.6-1.334,4.105l2.516,14.661c0.134,0.781-0.068,1.539-0.569,2.134C48.5,56.869,47.743,57.227,46.976,57.227"/>' +
										       '<path class="sr-outline" fill="#fbb040" d="M30.424,2c0.307,0,1.063,0.089,1.471,0.913l6.582,13.339c0.82,1.664,2.408,2.817,4.246,3.084l14.719,2.139c0.91,0.132,1.229,0.824,1.324,1.115c0.094,0.291,0.242,1.038-0.416,1.679L47.697,34.652c-1.328,1.295-1.934,3.16-1.621,4.99l2.516,14.662c0.105,0.622-0.131,1.061-0.35,1.318c-0.318,0.378-0.791,0.604-1.264,0.604c-0.26,0-0.518-0.066-0.764-0.197l-13.166-6.922c-0.807-0.422-1.715-0.646-2.625-0.646s-1.816,0.225-2.623,0.646l-13.166,6.922c-0.248,0.131-0.504,0.197-0.764,0.197c-0.473,0-0.947-0.226-1.266-0.604c-0.217-0.258-0.455-0.696-0.348-1.318l2.516-14.662c0.313-1.83-0.293-3.695-1.623-4.99L2.498,24.269c-0.656-0.641-0.508-1.388-0.414-1.679c0.096-0.291,0.414-0.983,1.322-1.115l14.721-2.139c1.838-0.267,3.424-1.42,4.246-3.084l6.582-13.339C29.363,2.089,30.117,2,30.424,2 M30.424,0c-1.297,0-2.594,0.676-3.262,2.027l-6.584,13.339c-0.529,1.074-1.553,1.819-2.738,1.99l-14.721,2.14c-2.984,0.434-4.176,4.101-2.016,6.205l10.65,10.383c0.859,0.836,1.25,2.04,1.047,3.221l-2.514,14.66c-0.404,2.352,1.465,4.262,3.584,4.262c0.561,0,1.137-0.134,1.695-0.426l13.166-6.923c0.529-0.278,1.111-0.417,1.691-0.417c0.582,0,1.164,0.139,1.693,0.417l13.166,6.923c0.559,0.293,1.135,0.426,1.695,0.426c2.119,0,3.986-1.91,3.584-4.262l-2.516-14.66c-0.201-1.181,0.189-2.385,1.047-3.221l10.652-10.383c2.158-2.104,0.967-5.771-2.016-6.205l-14.723-2.14c-1.184-0.171-2.209-0.916-2.738-1.99L33.688,2.027C33.02,0.676,31.723,0,30.424,0"/>',
										half: '<path class="sr-background" fill="transparent" d="M46.976,57.227c-0.422,0-0.834-0.104-1.228-0.312l-13.167-6.921c-0.663-0.349-1.409-0.533-2.158-0.533s-1.495,0.185-2.158,0.533L15.1,56.915c-0.393,0.208-0.807,0.312-1.229,0.312c-0.765,0-1.524-0.358-2.03-0.958c-0.501-0.595-0.703-1.353-0.569-2.134l2.515-14.661c0.258-1.505-0.241-3.039-1.334-4.105L1.8,24.985c-0.736-0.717-0.985-1.728-0.668-2.704c0.318-0.977,1.114-1.649,2.13-1.796l14.72-2.139c1.512-0.22,2.817-1.168,3.493-2.537L28.059,2.47C28.513,1.55,29.396,1,30.423,1c1.027,0,1.911,0.55,2.365,1.471l6.584,13.339c0.676,1.369,1.98,2.317,3.492,2.537l14.721,2.139c1.016,0.147,1.813,0.819,2.129,1.795c0.317,0.977,0.068,1.988-0.668,2.705L48.394,35.369c-1.092,1.065-1.59,2.6-1.334,4.105l2.516,14.661c0.134,0.781-0.068,1.539-0.569,2.134C48.5,56.869,47.743,57.227,46.976,57.227"/>' +
										      '<path class="sr-fill" fill="#F0C419" d="M28.731,50.878l-13.166,6.923c-2.67,1.402-5.789-0.863-5.279-3.836l2.517-14.66c0.201-1.181-0.188-2.385-1.047-3.221L1.104,25.701c-2.16-2.104-0.968-5.771,2.016-6.205l14.721-2.139c1.186-0.172,2.209-0.917,2.74-1.991l6.582-13.339C27.829,0.676,29.126,0,30.423,0l0.002,50.461C29.843,50.46,29.261,50.6,28.731,50.878"/>' +
										      '<path class="sr-outline" fill="#FBB040" d="M30.423,2c0.307,0,1.063,0.089,1.471,0.913l6.582,13.339c0.822,1.664,2.408,2.817,4.246,3.084l14.721,2.139c0.908,0.132,1.228,0.824,1.322,1.115c0.094,0.291,0.242,1.038-0.414,1.679L47.698,34.652c-1.33,1.295-1.936,3.16-1.623,4.99l2.517,14.662c0.106,0.622-0.131,1.061-0.349,1.318c-0.319,0.378-0.793,0.604-1.266,0.604c-0.26,0-0.516-0.066-0.764-0.197l-13.166-6.922c-0.807-0.422-1.713-0.646-2.625-0.646c-0.908,0-1.816,0.225-2.623,0.646l-13.166,6.922c-0.248,0.131-0.504,0.197-0.764,0.197c-0.473,0-0.947-0.226-1.264-0.604c-0.22-0.258-0.455-0.696-0.351-1.318l2.517-14.662c0.313-1.83-0.293-3.695-1.621-4.99L2.499,24.269c-0.658-0.641-0.51-1.388-0.416-1.679c0.096-0.291,0.414-0.983,1.322-1.115l14.721-2.139c1.838-0.267,3.424-1.42,4.246-3.084l6.582-13.339C29.362,2.089,30.118,2,30.423,2 M30.423,0c-1.297,0-2.594,0.676-3.262,2.027l-6.582,13.339c-0.531,1.074-1.555,1.819-2.74,1.99l-14.721,2.14c-2.984,0.434-4.174,4.101-2.016,6.205l10.651,10.383c0.856,0.836,1.248,2.04,1.045,3.221l-2.515,14.66c-0.403,2.352,1.466,4.262,3.584,4.262c0.562,0,1.138-0.134,1.695-0.426l13.166-6.923c0.529-0.278,1.109-0.417,1.691-0.417s1.164,0.139,1.693,0.417l13.166,6.923c0.559,0.293,1.135,0.426,1.694,0.426c2.119,0,3.988-1.91,3.584-4.262l-2.514-14.66c-0.203-1.181,0.188-2.385,1.045-3.221l10.651-10.383c2.16-2.104,0.97-5.771-2.016-6.205l-14.721-2.14c-1.186-0.171-2.211-0.916-2.738-1.99L33.683,2.027C33.019,0.676,31.722,0,30.423,0"/>',
										full: '<path class="sr-fill" fill="#F0C419" d="M46.976,57.227c-0.422,0-0.834-0.104-1.228-0.312l-13.167-6.921c-0.663-0.349-1.409-0.533-2.158-0.533s-1.495,0.185-2.158,0.533L15.1,56.915c-0.393,0.208-0.807,0.312-1.229,0.312c-0.765,0-1.524-0.358-2.03-0.958c-0.501-0.595-0.703-1.353-0.569-2.134l2.515-14.661c0.258-1.505-0.241-3.039-1.334-4.105L1.8,24.985c-0.736-0.717-0.985-1.728-0.668-2.704c0.318-0.977,1.114-1.649,2.13-1.796l14.72-2.139c1.512-0.22,2.817-1.168,3.493-2.537L28.059,2.47C28.513,1.55,29.396,1,30.423,1c1.027,0,1.911,0.55,2.365,1.471l6.584,13.339c0.676,1.369,1.98,2.317,3.492,2.537l14.721,2.139c1.016,0.147,1.813,0.819,2.129,1.795c0.317,0.977,0.068,1.988-0.668,2.705L48.394,35.369c-1.092,1.065-1.59,2.6-1.334,4.105l2.516,14.661c0.134,0.781-0.068,1.539-0.569,2.134C48.5,56.869,47.743,57.227,46.976,57.227"/>' +
										      '<path class="sr-outline" fill="#FBB040" d="M30.423,2c0.306,0,1.063,0.089,1.469,0.913l6.584,13.339c0.821,1.664,2.407,2.817,4.244,3.084l14.721,2.139c0.91,0.132,1.228,0.824,1.322,1.115c0.096,0.291,0.243,1.038-0.414,1.679L47.697,34.652c-1.329,1.295-1.936,3.161-1.621,4.991l2.515,14.661c0.106,0.623-0.131,1.061-0.349,1.319c-0.318,0.378-0.791,0.604-1.266,0.604c-0.259,0-0.515-0.067-0.763-0.197l-13.166-6.922c-0.806-0.423-1.713-0.647-2.624-0.647c-0.911,0-1.818,0.224-2.624,0.647L14.633,56.03c-0.248,0.13-0.504,0.197-0.763,0.197c-0.474,0-0.948-0.226-1.266-0.604c-0.218-0.258-0.454-0.696-0.348-1.319l2.515-14.661c0.314-1.83-0.292-3.696-1.621-4.991L2.5,24.269c-0.659-0.641-0.51-1.388-0.415-1.679c0.095-0.291,0.413-0.983,1.322-1.115l14.721-2.139c1.837-0.267,3.423-1.42,4.245-3.084l6.583-13.339C29.361,2.089,30.118,2,30.423,2 M30.423,0c-1.297,0-2.595,0.676-3.262,2.027l-6.584,13.339c-0.53,1.074-1.554,1.819-2.739,1.99l-14.72,2.14c-2.984,0.434-4.175,4.101-2.016,6.205l10.652,10.383c0.857,0.836,1.248,2.04,1.045,3.221l-2.514,14.66c-0.403,2.351,1.465,4.262,3.585,4.262c0.559,0,1.136-0.134,1.694-0.426l13.166-6.923c0.53-0.278,1.111-0.417,1.693-0.417s1.163,0.139,1.693,0.417l13.166,6.923c0.558,0.293,1.135,0.426,1.693,0.426c2.121,0,3.988-1.911,3.586-4.262l-2.515-14.66c-0.202-1.181,0.188-2.385,1.045-3.221l10.652-10.383c2.159-2.104,0.968-5.771-2.017-6.205l-14.72-2.14c-1.185-0.171-2.21-0.916-2.739-1.99L33.687,2.027C33.019,0.676,31.72,0,30.423,0"/>'
									},
									style2: {
										viewbox: '-4 -4 60 60',
										empty: '<path class="sr-outline" fill="#D3DADF" d="M27.999,2.318l5.307,15.909c0.52,1.562,1.977,2.621,3.623,2.633l16.77,0.13l-13.49,9.962c-1.324,0.979-1.881,2.691-1.385,4.261l5.059,15.988L30.239,41.45c-0.658-0.471-1.432-0.719-2.24-0.719s-1.584,0.248-2.24,0.719l-13.643,9.751l5.059-15.988c0.496-1.569-0.061-3.282-1.385-4.261L2.3,20.99l16.77-0.13c1.646-0.012,3.104-1.071,3.623-2.633L27.999,2.318 M27.999,0c-0.738,0-1.477,0.422-1.758,1.266l-5.445,16.328c-0.25,0.751-0.951,1.26-1.742,1.266L1.843,18.993c-1.781,0.015-2.52,2.285-1.086,3.343l13.846,10.226c0.637,0.469,0.904,1.293,0.666,2.047l-5.193,16.412c-0.41,1.295,0.619,2.418,1.773,2.418c0.357,0,0.727-0.107,1.07-0.353l14.004-10.009c0.32-0.23,0.699-0.346,1.076-0.346s0.756,0.115,1.076,0.346l14.004,10.009c0.344,0.245,0.713,0.353,1.07,0.353c1.154,0,2.182-1.125,1.773-2.418l-5.193-16.412c-0.238-0.754,0.029-1.578,0.666-2.047l13.846-10.226c1.434-1.058,0.695-3.328-1.086-3.343L36.944,18.86c-0.791-0.006-1.492-0.515-1.742-1.266L29.757,1.266C29.476,0.422,28.737,0,27.999,0"/>' +
										       '<path class="sr-background" fill="transparent" d="M17.178,35.213L12.12,51.202l13.644-9.752c0.656-0.47,1.432-0.719,2.239-0.719	c0.809,0,1.583,0.249,2.24,0.719l13.644,9.752l-5.059-15.988c-0.497-1.57,0.06-3.282,1.384-4.262l13.49-9.961L36.933,20.86	c-1.647-0.012-3.104-1.07-3.624-2.633L28.002,2.318l-5.306,15.909c-0.521,1.563-1.977,2.621-3.624,2.633L2.304,20.991l13.489,9.961	C17.119,31.931,17.675,33.643,17.178,35.213z"/>',
										half: '<path class="sr-outline" fill="#D3DADF" d="M27.999,2.318l5.307,15.909c0.52,1.562,1.977,2.621,3.623,2.633l16.77,0.13l-13.49,9.962c-1.324,0.979-1.881,2.691-1.385,4.261l5.059,15.988L30.239,41.45c-0.658-0.471-1.432-0.719-2.24-0.719s-1.584,0.248-2.24,0.719l-13.643,9.751l5.059-15.988c0.496-1.569-0.061-3.282-1.385-4.261L2.3,20.99l16.77-0.13c1.646-0.012,3.104-1.071,3.623-2.633L27.999,2.318 M27.999,0c-0.738,0-1.477,0.422-1.758,1.266l-5.445,16.328c-0.25,0.751-0.951,1.26-1.742,1.266L1.843,18.993c-1.781,0.015-2.52,2.285-1.086,3.343l13.846,10.226c0.637,0.469,0.904,1.293,0.666,2.047l-5.193,16.412c-0.41,1.295,0.619,2.418,1.773,2.418c0.357,0,0.727-0.107,1.07-0.353l14.004-10.009c0.32-0.23,0.699-0.346,1.076-0.346s0.756,0.115,1.076,0.346l14.004,10.009c0.344,0.245,0.713,0.353,1.07,0.353c1.154,0,2.182-1.125,1.773-2.418l-5.193-16.412c-0.238-0.754,0.029-1.578,0.666-2.047l13.846-10.226c1.434-1.058,0.695-3.328-1.086-3.343L36.944,18.86c-0.791-0.006-1.492-0.515-1.742-1.266L29.757,1.266C29.476,0.422,28.737,0,27.999,0"/>' +
										      '<path class="sr-background" fill="transparent" d="M17.178,35.213L12.12,51.202l13.644-9.752c0.656-0.47,1.432-0.719,2.239-0.719	c0.809,0,1.583,0.249,2.24,0.719l13.644,9.752l-5.059-15.988c-0.497-1.57,0.06-3.282,1.384-4.262l13.49-9.961L36.933,20.86	c-1.647-0.012-3.104-1.07-3.624-2.633L28.002,2.318l-5.306,15.909c-0.521,1.563-1.977,2.621-3.624,2.633L2.304,20.991l13.489,9.961	C17.119,31.931,17.675,33.643,17.178,35.213z"/>' +
										      '<path class="sr-fill" fill="#EFC319" d="M26.242,1.265l-5.445,16.329c-0.251,0.751-0.951,1.26-1.743,1.266L1.841,18.993c-1.78,0.015-2.518,2.285-1.086,3.343l13.846,10.225c0.638,0.471,0.905,1.293,0.666,2.049l-5.191,16.41c-0.537,1.697,1.395,3.102,2.844,2.066l14.002-10.009c0.32-0.229,0.694-0.343,1.069-0.345V0C27.255,0.003,26.522,0.424,26.242,1.265z"/>',
										full: '<path class="sr-fill" fill="#EFC319" d="M26.921,43.078L12.919,53.086c-1.449,1.035-3.381-0.369-2.844-2.066l5.191-16.41c0.239-0.756-0.028-1.578-0.666-2.049L0.755,22.336c-1.432-1.058-0.694-3.328,1.086-3.343l17.212-0.133c0.792-0.006,1.492-0.515,1.743-1.266l5.445-16.329c0.563-1.688,2.95-1.688,3.514,0l5.446,16.329c0.251,0.751,0.95,1.26,1.742,1.266l17.212,0.133c1.78,0.015,2.518,2.285,1.087,3.343L41.396,32.561c-0.638,0.471-0.904,1.293-0.666,2.049l5.191,16.41c0.538,1.697-1.396,3.102-2.843,2.066L29.076,43.078C28.431,42.617,27.566,42.617,26.921,43.078"/>'
									},
									style3: {
										viewbox: '-6 -6 80 80',
										empty: '<path class="def-shadow" fill="#B9C1C5" d="M14.874,40.174c0.101-0.583-0.094-1.178-0.518-1.591L0.544,25.12	c-0.121-0.118-0.214-0.248-0.293-0.382c-0.308,0.541-0.339,1.225,0,1.798c-0.308,0.54-0.339,1.224,0,1.797	c-0.38,0.667-0.344,1.559,0.293,2.18l13.696,13.35L14.874,40.174z"/>' +
										       '<path class="def-shadow" fill="#B9C1C5" d="M50.038,61.079l-17.071-8.976c-0.524-0.275-1.149-0.275-1.674,0l-17.071,8.976	c-0.98,0.514-2.079,0.027-2.478-0.858l-0.13,0.76c-0.065,0.378-0.008,0.73,0.13,1.038l-0.13,0.76	c-0.065,0.377-0.008,0.73,0.13,1.037l-0.13,0.76c-0.252,1.469,1.289,2.589,2.608,1.896l17.071-8.976	c0.524-0.275,1.149-0.275,1.674,0l17.071,8.976c1.318,0.693,2.86-0.427,2.608-1.896l-0.13-0.76c0.138-0.307,0.195-0.659,0.13-1.037	l-0.13-0.761c0.138-0.307,0.195-0.659,0.13-1.037l-0.13-0.761C52.116,61.106,51.017,61.593,50.038,61.079z"/>' +
										       '<path class="def-shadow" fill="#B9C1C5" d="M64.008,24.738c-0.079,0.134-0.172,0.264-0.293,0.382L49.903,38.583	c-0.424,0.413-0.617,1.008-0.517,1.591l0.632,3.688l13.696-13.349c0.637-0.621,0.673-1.513,0.293-2.18	c0.339-0.573,0.308-1.257,0-1.797C64.347,25.962,64.316,25.278,64.008,24.738z"/>' +
										       '<path class="sr-background" fill="#D3DADF" d="M49.386,40.174c-0.101-0.583,0.093-1.178,0.517-1.591L63.714,25.12	c0.121-0.118,0.214-0.248,0.293-0.382c0.622-1.05,0.017-2.495-1.29-2.684L43.63,19.28c-0.586-0.085-1.092-0.453-1.354-0.983	L33.742,1.001c-0.66-1.335-2.564-1.335-3.224,0l-8.537,17.296c-0.261,0.53-0.767,0.898-1.354,0.983L1.542,22.054	c-1.308,0.189-1.912,1.634-1.291,2.684c0.079,0.134,0.173,0.265,0.293,0.382l13.812,13.463c0.424,0.413,0.618,1.008,0.518,1.591	l-0.633,3.688l-2.628,15.321c-0.065,0.378-0.008,0.73,0.13,1.038c0.399,0.885,1.498,1.372,2.478,0.858l17.071-8.976	c0.524-0.275,1.149-0.275,1.674,0l17.071,8.976c0.979,0.514,2.079,0.027,2.478-0.858c0.138-0.307,0.195-0.659,0.13-1.037	l-2.627-15.322L49.386,40.174z"/>',
										half: '<path class="sr-outline" fill="#F2A261" d="M31.163,55.698C31.425,55.561,32,55.492,32,55.492v-1.797c0,0-0.575,0.069-0.837,0.207	C31.425,53.764,32,53.694,32,53.694v-1.797c0,0-0.51,0.069-0.772,0.207l-17.04,8.975c-0.979,0.515-2.062,0.028-2.461-0.857	l-0.123,0.76c-0.065,0.378-0.003,0.73,0.135,1.038l-0.128,0.76c-0.065,0.377-0.007,0.73,0.131,1.037l-0.13,0.76	c-0.252,1.469,1.289,2.589,2.607,1.896l17.073-8.976c0.262-0.138,0.485-0.206,0.772-0.206l-0.065,0v-1.797	C32,55.492,31.425,55.561,31.163,55.698z"/>' +
										      '<path class="sr-outline" fill="#F2A261" d="M14.874,40.174c0.1-0.583-0.094-1.178-0.519-1.591L0.545,25.12	c-0.121-0.118-0.214-0.248-0.294-0.382c-0.308,0.541-0.339,1.225,0,1.798c-0.308,0.54-0.339,1.224,0,1.797	c-0.38,0.667-0.344,1.559,0.294,2.18l13.696,13.351L14.874,40.174z"/>' +
										      '<path class="def-shadow" fill="#B9C1C5" d="M64.008,24.737c-0.08,0.135-0.173,0.265-0.294,0.383L49.903,38.583	c-0.425,0.413-0.617,1.008-0.518,1.591l0.632,3.688l13.696-13.35c0.638-0.621,0.674-1.513,0.294-2.18	c0.34-0.573,0.308-1.257,0-1.797C64.348,25.962,64.316,25.278,64.008,24.737z"/>' +
										      '<path class="def-shadow" fill="#B9C1C5" d="M50.038,61.079l-17.137-8.976C32.639,51.966,32,51.897,32,51.897v1.797c0,0-0.575,0.069-0.837,0.207	C31.425,53.764,32,53.695,32,53.695v1.797c0,0-0.575,0.068-0.837,0.206C31.425,55.561,32,55.492,32,55.492v1.797	c0,0,0.639,0.069,0.901,0.207l17.105,8.976c1.317,0.693,2.875-0.427,2.624-1.896l-0.123-0.76c0.138-0.307,0.2-0.659,0.135-1.037	l-0.128-0.761c0.138-0.307,0.196-0.659,0.131-1.037l-0.13-0.761C52.115,61.106,51.017,61.593,50.038,61.079z"/>' +
										      '<path class="sr-background" fill="#D3DADF" d="M49.386,40.174c-0.1-0.583,0.093-1.178,0.518-1.591L63.714,25.12	c0.121-0.118,0.215-0.248,0.294-0.383c0.622-1.05,0.017-2.494-1.291-2.684L43.631,19.28c-0.586-0.085-1.092-0.453-1.354-0.983	L33.742,1.001c-0.413-0.834-1.376-1.147-2.153-0.938C31.744,0.021,32,0,32,0v51.896c0,0-0.51,0.069-0.772,0.207	c0.262-0.138,0.583-0.207,0.87-0.207s0.59,0.069,0.852,0.207l17.08,8.976c0.979,0.514,2.082,0.027,2.481-0.858	c0.138-0.307,0.197-0.659,0.132-1.037l-2.626-15.321L49.386,40.174z"/>' +
										      '<path class="sr-fill" fill="#EFC319" d="M14.221,61.078l17.007-8.975C31.49,51.966,32,51.896,32,51.896V0c0,0-0.256,0.021-0.411,0.063	c-0.466,0.125-0.856,0.438-1.104,0.938l-8.521,17.296c-0.261,0.53-0.758,0.898-1.344,0.983L1.538,22.054	c-1.308,0.189-1.911,1.634-1.289,2.684c0.08,0.134,0.174,0.265,0.295,0.382l13.811,13.463c0.425,0.413,0.618,1.008,0.519,1.591	l-0.632,3.689l-2.628,15.32c-0.065,0.378-0.008,0.73,0.13,1.038C12.143,61.106,13.242,61.593,14.221,61.078z"/>',
										full: '<path class="sr-outline" fill="#F2A261" d="M14.874,40.174c0.1-0.583-0.094-1.178-0.518-1.591L0.544,25.12	c-0.121-0.118-0.214-0.248-0.294-0.382c-0.308,0.541-0.339,1.225,0,1.798c-0.308,0.54-0.339,1.224,0,1.797	c-0.38,0.667-0.344,1.559,0.293,2.18l13.696,13.35L14.874,40.174z"/>' +
										      '<path class="sr-outline" fill="#F2A261" d="M50.037,61.078l-17.071-8.975c-0.524-0.275-1.149-0.275-1.674,0L14.22,61.078	c-0.979,0.515-2.079,0.028-2.478-0.857l-0.13,0.76c-0.065,0.378-0.008,0.73,0.13,1.037l-0.13,0.761	c-0.065,0.377-0.008,0.73,0.13,1.037l-0.13,0.76c-0.252,1.469,1.289,2.589,2.608,1.896l17.072-8.976	c0.524-0.275,1.149-0.275,1.674,0l17.071,8.976c1.318,0.693,2.86-0.427,2.608-1.896l-0.13-0.76c0.138-0.307,0.195-0.659,0.13-1.037	l-0.13-0.761c0.138-0.307,0.195-0.659,0.13-1.037l-0.13-0.761C52.116,61.106,51.016,61.593,50.037,61.078z"/>' +
										      '<path class="sr-outline" fill="#F2A261" d="M64.008,24.738c-0.08,0.134-0.173,0.264-0.294,0.382L49.902,38.583	c-0.424,0.413-0.617,1.008-0.517,1.591l0.632,3.688l13.696-13.349c0.637-0.621,0.674-1.513,0.293-2.18	c0.339-0.573,0.308-1.257,0-1.797C64.347,25.962,64.315,25.278,64.008,24.738z"/>' +
										      '<path class="sr-fill" fill="#EFC319" d="M49.386,40.174c-0.101-0.583,0.093-1.178,0.517-1.591L63.714,25.12	c0.121-0.118,0.214-0.248,0.294-0.382c0.621-1.05,0.017-2.495-1.29-2.684L43.631,19.28c-0.586-0.085-1.093-0.453-1.354-0.983	L33.741,1.001c-0.66-1.335-2.564-1.335-3.224,0L21.98,18.297c-0.261,0.53-0.767,0.898-1.353,0.983L1.542,22.054	c-1.308,0.189-1.913,1.634-1.291,2.684c0.08,0.134,0.173,0.264,0.294,0.382l13.811,13.463c0.424,0.413,0.618,1.008,0.518,1.591	l-0.633,3.689l-2.628,15.321c-0.065,0.378-0.008,0.73,0.13,1.038c0.399,0.885,1.498,1.372,2.478,0.857l17.072-8.975	c0.524-0.275,1.149-0.275,1.674,0l17.071,8.975c0.979,0.515,2.079,0.028,2.478-0.857c0.138-0.307,0.195-0.659,0.13-1.037	l-2.627-15.322L49.386,40.174z"/>'
									},
									style4: {
										viewbox: '-6 -6 68 68',
										empty: '<path class="sr-background" fill="#D3DADF" d="M29.322,0C13.127,0,0,13.129,0,29.323c0,16.195,13.127,29.323,29.322,29.323s29.324-13.128,29.324-29.323C58.646,13.129,45.518,0,29.322,0 M46.717,26.696l-7.082,6.902c-0.346,0.337-0.504,0.822-0.422,1.298l1.672,9.747c0.205,1.199-1.051,2.111-2.127,1.546l-8.754-4.602c-0.426-0.225-0.936-0.225-1.363,0l-8.754,4.602c-1.074,0.565-2.334-0.347-2.127-1.546l1.672-9.747c0.08-0.476-0.076-0.961-0.422-1.298l-7.082-6.902c-0.869-0.849-0.391-2.326,0.813-2.501l9.787-1.422c0.477-0.069,0.891-0.369,1.104-0.802l4.377-8.868c0.537-1.09,2.092-1.09,2.629,0l4.377,8.868c0.215,0.433,0.627,0.732,1.104,0.802l9.787,1.422C47.107,24.37,47.586,25.848,46.717,26.696"/>',
										half: '<path class="sr-background" fill="#D3DADF" d="M29.322,0C13.127,0,0,13.129,0,29.323c0,16.195,13.127,29.323,29.322,29.323s29.324-13.128,29.324-29.323C58.646,13.129,45.518,0,29.322,0 M46.717,26.696l-7.082,6.902c-0.346,0.337-0.504,0.822-0.422,1.298l1.672,9.747c0.205,1.199-1.051,2.111-2.127,1.546l-8.754-4.602c-0.426-0.225-0.936-0.225-1.363,0l-8.754,4.602c-1.074,0.565-2.334-0.347-2.127-1.546l1.672-9.747c0.08-0.476-0.076-0.961-0.422-1.298l-7.082-6.902c-0.869-0.849-0.391-2.326,0.813-2.501l9.787-1.422c0.477-0.069,0.891-0.369,1.104-0.802l4.377-8.868c0.537-1.09,2.092-1.09,2.629,0l4.377,8.868c0.215,0.433,0.627,0.732,1.104,0.802l9.787,1.422C47.107,24.37,47.586,25.848,46.717,26.696"/>' +
										      '<path class="sr-fill" fill="#EFC319" d="M29.324,41.419c-0.236,0-0.469,0.056-0.684,0.169l-8.754,4.602c-1.074,0.565-2.332-0.348-2.127-1.546l1.672-9.747c0.082-0.476-0.076-0.961-0.422-1.298l-7.082-6.902c-0.869-0.849-0.389-2.326,0.814-2.501l9.785-1.423c0.479-0.068,0.891-0.368,1.104-0.801l4.377-8.868c0.27-0.545,0.791-0.817,1.314-0.817L29.324,0C13.129,0,0,13.129,0,29.323c0,16.195,13.129,29.323,29.324,29.323V41.419z"/>',
										full: '<path class="sr-fill" fill="#EFC319" d="M29.322,0C13.128,0,0,13.129,0,29.323c0,16.195,13.128,29.323,29.322,29.323c16.195,0,29.324-13.128,29.324-29.323C58.646,13.129,45.517,0,29.322,0 M46.717,26.696l-7.082,6.902c-0.345,0.337-0.503,0.822-0.421,1.298l1.671,9.747c0.206,1.199-1.051,2.111-2.127,1.546l-8.753-4.602c-0.427-0.225-0.938-0.225-1.365,0l-8.753,4.602c-1.075,0.565-2.333-0.347-2.127-1.546l1.672-9.747c0.081-0.476-0.076-0.961-0.422-1.298l-7.082-6.902c-0.87-0.849-0.39-2.326,0.813-2.501l9.787-1.422c0.477-0.069,0.89-0.369,1.104-0.802l4.376-8.868c0.538-1.09,2.092-1.09,2.629,0l4.377,8.868c0.214,0.433,0.626,0.732,1.104,0.802l9.786,1.422C47.107,24.37,47.587,25.848,46.717,26.696"/>'
									}
								}
							} );
						},
						"social.js": function (exports, module, require) {
							(function ( $ ) {
								module.exports = require( './_base' ).extend( {
									get_styles: function () {
										return {};
									},
									setup_defaults: function () {
										this.config = {
											show_count: false,
											style: 'tve_style_1',
											button_type: 'tve_social_itb',
											selected: ['fb_share', 'g_share', 't_share'],
											share_url: '{tcb_post_url}',
											min_shares: 0,
											t_share: {
												label: 'Tweet'
											},
											g_share: {
												label: 'Share +1'
											},
											pin_share: {
												label: 'Pin'
											}
										};
									},
									label: function ( network ) {
										return this.config[network] && this.config[network].label ? this.config[network].label : TVE.t.share;
									},
									/**
									 * Renders the default element (with no settings applied)
									 * Called when inserting the element into the page
									 *
									 * @returns {*}
									 */
									render_default: function () {
										this.setup_defaults();
										var $element = jQuery( '<div class="thrv_wrapper thrv_social_custom thrv_' + this.key + '"></div>' );

										this.render_to( $element );

										return $element;
									},
									/**
									 * Private render method. Should not be called directly
									 * Renders the contents of the element
									 *
									 * @param {jQuery} $element
									 * @param {Boolean} [add_undo_step] whether or not to record an undo step
									 * @returns {*}
									 */
									_render_to: function ( $element, add_undo_step ) {
										var counts = {};
										$element.find( '.tve_s_count' ).each( function () {
											var $this = $( this );
											counts[$this.closest( '.tve_s_item' ).attr( 'data-s' )] = $this.text();
										} );
										counts.total = {
											value: 0,
											formatted: 0
										};
										if ( TVE.inner.window.TCB_Front.total_share_counts && TVE.inner.window.TCB_Front.total_share_counts[this.config.share_url] ) {
											counts.total = TVE.inner.window.TCB_Front.total_share_counts[this.config.share_url];
										}
										$element.html( TVE.tpl( 'elements/social' )( {r: this, config: this.config, counts: counts} ) );
										var config = this.config;
										$element.find( '.tve_s_item' ).each( function () {
											var k = this.getAttribute( 'data-s' ),
												elem = this;
											_.each( config[k], function ( value, field ) {
												if ( value && field !== 'href' ) { // href defined globally
													elem.setAttribute( 'data-' + field, value );
												}
											} );
										} );
										$element.attr( 'data-counts', this.config.show_count ? '1' : '' );
										$element.attr( 'data-min_shares', this.config.min_shares );
										TVE.Editor_Page.reposition_icons( $element );
									}
								} );
							})( jQuery );
						},
						"styled-list.js": function (exports, module, require) {
							/**
							 * Created by Ovidiu on 5/9/2017.
							 */

							module.exports = require( './_base' ).extend( {
								setup_defaults: function () {
									this.data = {
										items: 3,
										text: 'List Element',
										icon_code: 'icon-check'
									}
								},
								_render_to: function ( $element, add_undo_step ) {
									$element.html( this.get_html() ).attr( 'data-icon-code', this.data.icon_code );

									return this;
								},

								/**
								 * Build the list item default HTML
								 *
								 * @returns {string}
								 */
								get_html: function () {
									var html = '<ul class="tcb-styled-list">';

									for ( var i = 0; i < this.data.items; i ++ ) {
										html += this.create_default_list_item();
									}

									html += '</ul>';

									return html;
								},

								/**
								 * Creates a default list item
								 *
								 * @returns {string}
								 */
								create_default_list_item: function ( icon_code ) {
									icon_code = typeof icon_code === 'undefined' ? this.data.icon_code : icon_code;

									var html = '';
									html += '<li class="thrv-styled-list-item">';
									html += '<div class="tcb-styled-list-icon"><div class="thrv_wrapper thrv_icon tve_no_drag tcb-no-delete tcb-no-clone tcb-icon-inherit-style">';
									var $symbol = jQuery( 'symbol#' + icon_code );
									if ( $symbol.length ) {
										html += TVE.svg_icon( {
											path: $symbol.html(),
											viewBox: $symbol[0].getAttribute( 'viewBox' ),
											name: $symbol.find( '> title' ).text()
										} );
									} else {
										html += '<span data-name="' + icon_code.replace( 'icon-', '' ) + '" class="tve_sc_icon ' + icon_code + '"></span>';
									}

									html += '</div></div>';

									html += '<span class="thrv-inline-text tve_editable tcb-styled-list-icon-text tcb-no-delete">' + this.data.text + '</span>';
									html += '</li>';

									return html;
								},

								/**
								 * Returns the icon (as string) corresponding to a list item
								 *
								 * @param $listItem - jQuery Object
								 * @returns {string}
								 */
								get_icon: function ( $listItem ) {

									return $listItem.find( '.thrv_icon' ).html();
								},

								/**
								 * Returns the text corresponding to a list item
								 *
								 * @param $listItem - jQuery Object
								 * @returns {string}
								 */
								get_text: function ( $listItem ) {
									return $listItem.find( '.tcb-styled-list-icon-text' ).text().substring( 0, 20 );
								}
							} );
						},
						"testimonial.js": function (exports, module, require) {
							module.exports = require( './_base' ).extend( {
								setup_defaults: function () {
									this.config = {
										name: 'TestName',
										title: 'TestLabel',
										image: 'TestImage',
										text: 'TestText'
									};
								},
								_render_to: function ( $element, add_undo_step ) {
									$element.removeClass( 'tcb-elem-placeholder' ).addClass( 'thrv-columns tve-draggable tve-droppable' );
									$element.attr( 'data-template', this.config.template );
									$element.html( this.get_html() );
									return this;
								},
								render_default: function () {
									return jQuery( TVE.tpl( 'testimonial/testimonial' )() );
								},
								get_html: function () {
									return TVE.tpl( 'testimonial/styles/' + this.config.key )( {item: this.config} );
								}
							} );
						}
					},
					"libs": {
						"element-snapshot.js": function (exports, module, require) {
							/**
							 * Undo / redo helper for element html - cases where the HTML structure of the element changes
							 */

							/**
							 * Take element snapshot
							 * @param $element
							 * @returns {{html, cls: *, style: *, data: {}}}
							 */
							function take( $element ) {
								var prop = {
									html: $element.html(),
									cls: $element.attr( 'class' ),
									style: $element.attr( 'style' ),
									data: {}
								};

								if ( $element.length && $element[0].dataset ) {
									jQuery.each( $element[0].dataset, function ( attr, value ) {
										prop.data[attr] = value;
									} );
								}

								return prop;
							}

							/**
							 * Restores element snapshot
							 *
							 * @param $element
							 * @param snapshot
							 * @returns {restore}
							 */
							function restore( $element, snapshot ) {
								if ( ! $element.length || ! snapshot ) {
									return this;
								}
								$element.html( snapshot.html ).attr( 'class', snapshot.cls ).attr( 'style', snapshot.stlye );
								jQuery.each( $element.data(), function ( k, v ) {
									$element.removeAttr( 'data-' + k );
								} );
								jQuery.each( snapshot.data, function ( attr, value ) {
									$element[0].dataset[attr] = value;
								} );

								return this;
							}

							/**
							 * apply a function that modifies an element, adding the step to the undo manager
							 *
							 * @param callback
							 * @param $element
							 */
							module.exports = function ( callback, $element ) {
								var before = take( $element );
								callback();
								var after = take( $element );

								TVE.UndoManager.add( {
									undo: function () {
										restore( $element, before );
									},
									redo: function () {
										restore( $element, after );
									}
								} );
							};
						},
						"event-manager.js": function (exports, module, require) {
							(function ( $ ) {
								module.exports = {
									D_s: '__TCB_EVENT_',
									D_e: '_TNEVE_BCT__',
									read: function ( element ) {
										if ( ! element ) {
											return [];
										}
										var config = element.jquery ? element.attr( 'data-tcb-events' ) : element.getAttribute( 'data-tcb-events' );
										config = config ? JSON.parse( config.replace( this.D_s, '' ).replace( this.D_e, '' ) ) : [];

										return config;
									},
									/**
									 * Get an event by trigger
									 *
									 * @param {jQuery|Element} element
									 * @param {string} trigger
									 *
									 * @return {Boolean|Object} false if not found
									 */
									get: function ( element, trigger ) {
										var events = this.read( element ),
											found = false;

										$.each( events, function ( i, evt ) {
											if ( evt.t === trigger ) {
												found = evt;
												return false;
											}
										} );

										return found;
									},
									/**
									 * Removes an event identified by trigger
									 *
									 * @param {jQuery|Element} element
									 * @param {string} trigger
									 *
									 * @return EventManger
									 */
									remove: function ( element, trigger ) {
										var config = this.read( element );
										if ( ! config.length ) {
											return this;
										}
										$.each( config, function ( i, evt ) {
											if ( evt.t === trigger ) {
												config.splice( i, 1 );
												return false;
											}
										} );

										this.write( config, element );

										return this;

									},
									/**
									 * Replace an existing event. Identification is done with the trigger.
									 * Ex. replace a "click" event with a new one
									 *
									 * @param {jQuery|Element} element
									 * @param {String} trigger
									 * @param {object} new_event
									 */
									replace: function ( element, trigger, new_event ) {
										var current = this.read( element ),
											found = false;
										if ( ! new_event.t ) {
											new_event.t = trigger;
										}
										$.each( current, function ( i, evt ) {
											if ( evt.t === trigger ) {
												current[i] = new_event;
												found = true;
												return false;
											}
										} );
										if ( ! found ) {
											current.push( new_event );
										}

										this.write( current, element );
									},
									write: function ( config, element ) {
										if ( ! element ) {
											return;
										}
										/**
										 * do not save links
										 */
										config = _.filter( config, function ( item ) {
											return item.a !== 'link';
										} );
										element = element.jquery ? element[0] : element;
										if ( config.length ) {
											element.setAttribute( 'data-tcb-events', this.D_s + JSON.stringify( config ) + this.D_e );
											element.classList.add( 'tve_evt_manager_listen' );
										} else {
											element.classList.remove( 'tve_evt_manager_listen' );
											element.removeAttribute( 'data-tcb-events' );
										}

										var trigger_target = element.jquery ? element : jQuery( element ),
											action_target = trigger_target.closest( '.thrv_wrapper' );

										/* at first, reset everything - remove all classes that might have been previously added */
										trigger_target.removeClass( this.remove_classes );
										action_target.removeClass( this.remove_classes );

										/* add specific classes for each trigger and action */
										for ( var i = 0, evt; evt = config[i ++]; ) {
											trigger_target.addClass( 'tve_et_' + evt.t );
											action_target.addClass( 'tve_ea_' + evt.a );
											if ( evt.a === 'thrive_animation' ) {
												action_target.addClass( 'tve_anim_' + evt.config.anim );
											}
										}
									},
									/**
									 * Helper function to remove all evt-manager-related classes
									 *
									 * @param {Number} i
									 * @param {String} className
									 */
									remove_classes: function ( i, className ) {
										var cls_list = className.split( ' ' ),
											to_remove = [];
										_.each( cls_list, function ( cls ) {
											if ( cls.indexOf( 'tve_et_' ) === 0 || cls.indexOf( 'tve_ea_' ) === 0 || cls.indexOf( 'tve_anim' ) === 0 ) {
												to_remove.push( cls );
											}
										} );

										return to_remove.join( ' ' );
									}
								};
							})( jQuery );
						},
						"favorite-colors.js": function (exports, module, require) {
							var base = require( '../views/base' ),
								tinycolor = require( './tinycolor' ),
								/** @var {TCBStorage} storage */
								storage = require( './storage' );

							module.exports = base.base_view.extend( {
								template: TVE.tpl( 'util/favorite-colors' ),
								className: 'tcb-fav-colors',
								attr: {
									expanded: storage.get( 'tcb_fav_expanded' ) || false,
									colors: TVE.CONST.colors.favorites || [],
									color_sets: TVE.CONST.colors.color_sets || []
								},
								/**
								 * Renders a row of colors - <span> elements that can be selected
								 *
								 * @param {Array} [colors] optional, Array of colors to be rendered
								 */
								render_colors: function ( colors ) {
									colors = colors || this.attr.colors;
									var _html = '';
									_.each( colors, function ( color ) {
										_html += '<span class="p-thumb click" data-fn="color_click" data-color="' + tinycolor( color ).toRgbString() + '"><span class="p-thumb-inner" style="background-color:' + color + '"></span></span>';
									} );

									return _html ? _html : '<span style="font-style: italic; font-size:10px">no color available</span>';
								},
								/**
								 * Gets the most recent colors
								 *
								 * @param {Number} [limit]
								 */
								get_recent: function ( limit ) {
									limit = limit || 5;
									if ( this.attr.colors.length < limit ) {
										return this.attr.colors;
									}

									return this.attr.colors.slice( 0, limit );
								},
								/**
								 * Toggle expand / collapsed state
								 *
								 * @returns {boolean}
								 */
								toggle: function () {
									this.$( '.tcb-favorites' ).toggleClass( 'expanded' );
									this.attr.expanded = ! this.attr.expanded;
									if ( this.attr.expanded ) {
										storage.set( 'tcb_fav_expanded', '1' );
									} else {
										storage.unset( 'tcb_fav_expanded' );
									}
									this.$( '.recent' ).html( this.render_colors( this.get_recent() ) );

									return false;
								},
								/**
								 * Triggers a change event with the selected color
								 *
								 * @param e
								 * @param thumb
								 */
								color_click: function ( e, thumb ) {
									this.trigger( 'select', thumb.getAttribute( 'data-color' ) );

									return false;
								},
								/**
								 * Adds a new color to the palette - only if it doesn't exist
								 *
								 * @param color
								 *
								 * @returns {Object} allows chained calls
								 */
								add_color: function ( color ) {
									if ( ! color ) {
										return this;
									}
									color = typeof color.toString === 'function' ? color.toString() : color;
									if ( this.attr.colors.indexOf( color ) !== - 1 ) {
										return this;
									}

									this.$( '.remove-color' ).removeClass( 'tcb-hide' );

									this.attr.colors.unshift( color );
									this.$( '.recent' ).html( this.render_colors( this.get_recent() ) );
									this.$( '.colors' ).html( this.render_colors() );

									return this;
								},
								/**
								 * Selects a color
								 * @param color
								 */
								select: function ( color ) {
									var $thumbs = this.$( '.p-thumb' ).removeClass( 'active' );
									if ( ! color ) {
										return;
									}
									if ( typeof color === 'string' ) {
										color = tinycolor( color );
									}

									this.$selected = $thumbs.filter( '[data-color="' + color.toRgbString() + '"]' ).addClass( 'active' ).filter( '.colors .p-thumb' );

									return this;
								},
								/**
								 * Deselects any possibly selected color thumb
								 */
								deselect: function () {
									if ( ! this.$selected || ! this.$selected.length ) {
										return this;
									}
									this.$( '.p-thumb.active' ).removeClass( 'active' );
									delete this.$selected;

									return this;
								},
								/**
								 * Removes the currently selected color and re-renders the palette
								 *
								 * @returns {boolean}
								 */
								remove_color: function ( e, btn ) {
									if ( ! this.$selected || ! this.$selected.length ) {
										return false;
									}

									this.attr.colors.splice( this.$selected.index(), 1 );
									this.$selected.remove();

									if ( ! this.attr.colors.length ) {
										btn.classList.add( 'tcb-hide' );
									}

									delete this.$selected;

									return false;
								}
							} );
						},
						"file-picker.js": function (exports, module, require) {
							/**
							 * Image Picker library.
							 * Wraps over the wordpress media manager
							 */
							var ImageFrame = wp.media.view.MediaFrame.Post.extend( {
								createStates: function () {
									wp.media.view.MediaFrame.Post.prototype.createStates.apply( this, arguments );
									this.states.remove( 'gallery' );
									this.states.remove( 'gallery-edit' );
									this.states.remove( 'gallery-add' );
									this.states.remove( 'playlist' );
									this.states.remove( 'video-playlist' );
									this.states.remove( 'audio-playlist' );

									if ( this.options.library.type !== 'image' ) {
										this.states.remove( 'embed' );
									}

									this.states.get( 'insert' ).set( 'title', this.options.title );
								},
								activate: function () {
									this.menuItemVisibility( 'gallery', 'hide' );
									this.menuItemVisibility( 'playlist', 'hide' );
									this.menuItemVisibility( 'video-playlist', 'hide' );
									this.menuItemVisibility( 'audio-playlist', 'hide' );

									if ( this.options.library.type !== 'image' ) {
										this.menuItemVisibility( 'embed', 'hide' );
									}
								}
							} );

							function ImagePicker( opts ) {
								var defaults = {
										title: TVE.t.ChooseImage,
										multiple: false,
										library: {
											type: 'image'
										}
									},
									self = this;
								opts = _.defaults( opts || {}, defaults );
								this.frame = new ImageFrame( opts );

								this.frame.on( 'insert', function ( selection ) {
									self.image_selected = true;
									var state = self.frame.state();
									selection = selection || state.get( 'selection' );
									if ( ! selection ) {
										return;
									}

									var attachment = state.get( 'selection' ).first(),
										display = state.display( attachment ).toJSON();

									self.update_link_url( display, attachment );

									self.send_image( display, attachment.toJSON() );
								} );

								this.frame.on( 'select', function () {
									var state = self.frame.state(),
										display = state.props.toJSON();

									self.send_image( null, display );
								} );

								this.frame.on( 'close', function () {
									if ( typeof self.cancel_callback === 'function' ) {
										/**
										 * WP media frame always triggers the close callback before the insert callback
										 * This timeout ensures that the cancel callback will not be applied if the user selected an image
										 */
										setTimeout( function () {
											if ( ! self.image_selected ) {
												self.cancel_callback.call( self.cancel_scope );
											}
										}, 10 );
									}
								} );
							}

							ImagePicker.prototype.update_link_url = function ( display, attachment ) {
								if ( ! display || ! attachment ) {
									return;
								}

								switch ( display.link ) {
									case 'file':
										display.link_url = attachment.get( 'url' );
										break;
									case 'post':
										display.link_url = attachment.get( 'link' );
										break;
									case 'none':
										display.link_url = '';
										break;
								}
							};

							/**
							 * Apply the callback when selecting an image
							 * It will take into account thumbnails for the main attachment
							 *
							 * @param display
							 * @param attachment
							 * @returns {*}
							 */
							ImagePicker.prototype.send_image = function ( display, attachment ) {
								if ( typeof this.select_callback !== 'function' ) {
									return this;
								}

								/**
								 * in case the user selected a different size for the image.
								 */
								var thumb = _.extend( {}, attachment );

								if ( display && display.size && attachment.sizes && attachment.sizes[display.size] ) {
									attachment.size = thumb.size = display.size;
									var prop = attachment.sizes[display.size];
									/**
									 * User selected a different size for the image. use that instead
									 */
									thumb.url = prop.url;
									thumb.width = prop.width;
									thumb.height = prop.height;
								}

								if ( display && display.link_url ) {
									thumb.link_url = display.link_url;
								}

								if ( ! thumb.title ) {
									thumb.title = thumb.url.replace( /\/$/, '' ).split( '/' ).pop();
								}

								/**
								 * Callback receives the thumbnail as the first parameter, and the original attachment as the second one
								 */
								return this.select_callback.call( this.cb_scope, thumb, attachment );
							};

							/**
							 * open frame
							 *
							 * @returns {ImagePicker}
							 */
							ImagePicker.prototype.open = function () {
								delete self.image_selected;
								this.frame.open();

								return this;
							};

							/**
							 * Select callback
							 *
							 * @param {Function} callback select callback
							 * @param {Object} [scope] scope in which to call the select callback
							 */
							ImagePicker.prototype.on_select = function ( callback, scope ) {
								this.select_callback = callback;
								this.cb_scope = scope || this;

								return this;
							};

							/**
							 * Set the onclose callback - this will only be called when the media frame is closed using the "x" button.
							 * It won't be called when the user inserts an image
							 *
							 * @param {Function} callback
							 * @param {Object} [scope] scope in which to call the callback
							 *
							 * @return {ImagePicker}
							 */
							ImagePicker.prototype.on_cancel = function ( callback, scope ) {
								this.cancel_callback = callback;
								this.cancel_scope = scope || this;

								return this;
							};

							/**
							 * get the URL without protocol
							 *
							 * @var {String|undefined|Object} param
							 */
							ImagePicker.prototype.clean_url = function ( param ) {
								if ( ! param ) {
									return '';
								}
								var url = '';
								if ( _.isObject( param ) && param.url ) {
									url = param.url;
								} else if ( param.length ) {
									url = param;
								}

								return url.replace ? url.replace( /^http(s)?:\/\//g, '//' ) : '';
							};

							module.exports = ImagePicker;
						},
						"gradient-builder.js": function (exports, module, require) {
							/**
							 * The MIT License (MIT)

							 Copyright (c) 2014 Rafael Carcio

							 Permission is hereby granted, free of charge, to any person obtaining a copy
							 of this software and associated documentation files (the "Software"), to deal
							 in the Software without restriction, including without limitation the rights
							 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
							 copies of the Software, and to permit persons to whom the Software is
							 furnished to do so, subject to the following conditions:

							 The above copyright notice and this permission notice shall be included in all
							 copies or substantial portions of the Software.

							 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
							 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
							 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
							 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
							 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
							 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
							 SOFTWARE.
							 */
							var visitor = {

								'visit_linear-gradient': function ( node ) {
									return visitor.visit_gradient( node );
								},

								'visit_repeating-linear-gradient': function ( node ) {
									return visitor.visit_gradient( node );
								},

								'visit_radial-gradient': function ( node ) {
									return visitor.visit_gradient( node );
								},

								'visit_repeating-radial-gradient': function ( node ) {
									return visitor.visit_gradient( node );
								},

								'visit_gradient': function ( node ) {
									var orientation = visitor.visit( node.orientation );
									if ( orientation ) {
										orientation += ', ';
									}

									return ( node.real_type ? node.real_type : node.type ) + '(' + orientation + visitor.visit( node.colorStops ) + ')';
								},

								'visit_shape': function ( node ) {
									var result = node.value,
										at = visitor.visit( node.at ),
										style = visitor.visit( node.style );

									if ( style ) {
										result += ' ' + style;
									}

									if ( at ) {
										result += ' at ' + at;
									}

									return result;
								},

								'visit_default-radial': function ( node ) {
									var result = '',
										at = visitor.visit( node.at );

									if ( at ) {
										result += at;
									}
									return result;
								},

								'visit_extent-keyword': function ( node ) {
									var result = node.value,
										at = visitor.visit( node.at );

									if ( at ) {
										result += ' at ' + at;
									}

									return result;
								},

								'visit_position-keyword': function ( node ) {
									return node.value;
								},

								'visit_position': function ( node ) {
									return visitor.visit( node.value.x ) + ' ' + visitor.visit( node.value.y );
								},

								'visit_%': function ( node ) {
									return node.value + '%';
								},

								'visit_em': function ( node ) {
									return node.value + 'em';
								},

								'visit_px': function ( node ) {
									return node.value + 'px';
								},

								'visit_literal': function ( node ) {
									return visitor.visit_color( node.value, node );
								},

								'visit_hex': function ( node ) {
									return visitor.visit_color( '#' + node.value, node );
								},

								'visit_rgb': function ( node ) {
									return visitor.visit_color( 'rgb(' + node.value.join( ', ' ) + ')', node );
								},

								'visit_rgba': function ( node ) {
									return visitor.visit_color( 'rgba(' + node.value.join( ', ' ) + ')', node );
								},

								'visit_color': function ( resultColor, node ) {
									var result = resultColor,
										length = visitor.visit( node.length );

									if ( length ) {
										result += ' ' + length;
									}
									return result;
								},

								'visit_angular': function ( node ) {
									return node.value + 'deg';
								},

								'visit_directional': function ( node ) {
									return 'to ' + node.value;
								},

								'visit_array': function ( elements ) {
									var result = '',
										size = elements.length;

									elements.forEach( function ( element, i ) {
										result += visitor.visit( element );
										if ( i < size - 1 ) {
											result += ', ';
										}
									} );

									return result;
								},

								'visit': function ( element ) {
									if ( ! element ) {
										return '';
									}

									if ( element instanceof Array ) {
										return visitor.visit_array( element );
									} else if ( element.type ) {
										var nodeVisitor = visitor['visit_' + element.type] || visitor['visit_' + element.real_type];
										if ( nodeVisitor ) {
											return nodeVisitor( element );
										}
										throw Error( 'Missing visitor visit_' + element.type );

									} else if ( typeof element === 'string' ) {
										return element;
									} else {
										throw Error( 'Invalid node.' );
									}
								}
							};

							visitor['visit_solid'] = function ( node ) {
								node.real_type = 'linear-gradient';

								return visitor.visit_gradient( node );
							};
							visitor['visit_url'] = function ( node ) {
								return 'url("' + node.value + '")';
							};

							module.exports = function ( ast ) {
								if ( ! ast ) {
									return 'none';
								}
								if ( ast instanceof Array && ! ast.length ) {
									return 'none';
								}
								return visitor.visit( ast );
							};
						},
						"gradient-parser.js": function (exports, module, require) {
							/**
							 * The MIT License (MIT)

							 Copyright (c) 2014 Rafael Carcio

							 Permission is hereby granted, free of charge, to any person obtaining a copy
							 of this software and associated documentation files (the "Software"), to deal
							 in the Software without restriction, including without limitation the rights
							 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
							 copies of the Software, and to permit persons to whom the Software is
							 furnished to do so, subject to the following conditions:

							 The above copyright notice and this permission notice shall be included in all
							 copies or substantial portions of the Software.

							 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
							 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
							 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
							 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
							 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
							 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
							 SOFTWARE.
							 */
							var tinycolor = require( './tinycolor' );

							module.exports = (function () {

								var tokens = {
									url: /^url(\s*)\(('|"|)(.+?)(\2)\)/i,
									linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,
									repeatingLinearGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,
									radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,
									repeatingRadialGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,
									sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,
									extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
									positionKeywords: /^(left|center|right|top|bottom)/i,
									pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
									percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
									emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
									angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
									startCall: /^\(/,
									endCall: /^\)/,
									comma: /^,/,
									hexColor: /^\#([0-9a-fA-F]+)/,
									literalColor: /^([a-zA-Z]+)/,
									rgbaColor: /^rgba?/i,
									number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
								};

								var input = '';

								function error( msg ) {
									var err = new Error( input + ': ' + msg );
									err.source = input;
									throw err;
								}

								function getAST() {
									var ast = matchListDefinitions();

									if ( input.length > 0 ) {
										error( 'Invalid input not EOF' );
									}

									return ast;
								}

								function matchListDefinitions() {
									return matchListing( matchDefinition );
								}

								function matchDefinition() {

									return matchURL() ||

									       matchGradient(
										       'linear-gradient',
										       tokens.linearGradient,
										       matchLinearOrientation ) ||

									       matchGradient(
										       'repeating-linear-gradient',
										       tokens.repeatingLinearGradient,
										       matchLinearOrientation ) ||

									       matchGradient(
										       'radial-gradient',
										       tokens.radialGradient,
										       matchListRadialOrientations ) ||

									       matchGradient(
										       'repeating-radial-gradient',
										       tokens.repeatingRadialGradient,
										       matchListRadialOrientations );
								}

								function matchURL() {
									var captures = scan( tokens.url );
									if ( ! captures ) {
										return false;
									}
									return {
										type: 'url',
										value: captures[3]
									};
								}

								function is_solid( item ) {
									if ( item.type != 'linear-gradient' ) {
										return false;
									}

									return item.colorStops.length === 2 && tinycolor.equals( item.colorStops[0].value, item.colorStops[1].value );
								}

								function matchGradient( gradientType, pattern, orientationMatcher ) {
									return matchCall( pattern, function ( captures ) {

										var orientation = orientationMatcher();
										if ( orientation ) {
											if ( ! scan( tokens.comma ) ) {
												error( 'Missing comma before color stops' );
											}
										}

										var _item = {
											type: gradientType,
											orientation: orientation,
											colorStops: matchListing( matchColorStop )
										};

										if ( is_solid( _item ) ) {
											_item.type = 'solid';
										}

										return _item;
									} );
								}

								function matchCall( pattern, callback ) {
									var captures = scan( pattern );

									if ( captures ) {
										if ( ! scan( tokens.startCall ) ) {
											error( 'Missing (' );
										}

										var result = callback( captures );

										if ( ! scan( tokens.endCall ) ) {
											error( 'Missing )' );
										}

										return result;
									}
								}

								function matchLinearOrientation() {
									return matchSideOrCorner() ||
									       matchAngle();
								}

								function matchSideOrCorner() {
									return match( 'directional', tokens.sideOrCorner, 1 );
								}

								function matchAngle() {
									var captures = scan( tokens.angleValue );
									if ( captures ) {
										return captures[1] + 'deg';
									}
								}

								function matchListRadialOrientations() {
									var radialOrientations,
										radialOrientation = matchRadialOrientation(),
										lookaheadCache;

									if ( radialOrientation ) {
										radialOrientations = [];
										radialOrientations.push( radialOrientation );

										lookaheadCache = input;
										if ( scan( tokens.comma ) ) {
											radialOrientation = matchRadialOrientation();
											if ( radialOrientation ) {
												radialOrientations.push( radialOrientation );
											} else {
												input = lookaheadCache;
											}
										}
									}

									return radialOrientations;
								}

								function matchRadialOrientation() {
									var radialType = matchCircle() ||
									                 matchEllipse();

									if ( radialType ) {
										radialType.at = matchAtPosition();
									} else {
										var extent = matchExtentKeyword();
										if ( extent ) {
											radialType = extent;
											var positionAt = matchAtPosition();
											if ( positionAt ) {
												radialType.at = positionAt;
											}
										} else {
											var defaultPosition = matchPositioning();
											if ( defaultPosition ) {
												radialType = {
													type: 'default-radial',
													at: defaultPosition
												};
											}
										}
									}

									return radialType;
								}

								function matchCircle() {
									var circle = match( 'shape', /^(circle)/i, 0 );

									if ( circle ) {
										circle.style = matchLength() || matchExtentKeyword();
									}

									return circle;
								}

								function matchEllipse() {
									var ellipse = match( 'shape', /^(ellipse)/i, 0 );

									if ( ellipse ) {
										ellipse.style = matchDistance() || matchExtentKeyword();
									}

									return ellipse;
								}

								function matchExtentKeyword() {
									return match( 'extent-keyword', tokens.extentKeywords, 1 );
								}

								function matchAtPosition() {
									if ( match( 'position', /^at/, 0 ) ) {
										var positioning = matchPositioning();

										if ( ! positioning ) {
											error( 'Missing positioning value' );
										}

										return positioning;
									}
								}

								function matchPositioning() {
									var location = matchCoordinates();

									if ( location.x || location.y ) {
										return {
											type: 'position',
											value: location
										};
									}
								}

								function matchCoordinates() {
									return {
										x: matchDistance(),
										y: matchDistance()
									};
								}

								function matchListing( matcher ) {
									var captures = matcher(),
										result = [];

									if ( captures ) {
										result.push( captures );
										while ( scan( tokens.comma ) ) {
											captures = matcher();
											if ( captures ) {
												result.push( captures );
											} else {
												error( 'One extra comma' );
											}
										}
									}

									return result;
								}

								function matchColorStop() {
									var color = matchColor();

									if ( ! color ) {
										error( 'Expected color definition' );
									}

									color.length = matchDistance();
									return color;
								}

								function matchColor() {
									return matchHexColor() ||
									       matchRGBAColor() ||
									       matchLiteralColor();
								}

								function matchLiteralColor() {
									var captures = scan( tokens.literalColor );
									if ( captures ) {
										return {
											type: 'literal',
											transparent: captures[0] === 'transparent' ? 'transparent' : false,
											value: new tinycolor( captures[0] )
										};
									}
								}

								function matchHexColor() {
									var captures = scan( tokens.hexColor );
									if ( captures ) {
										return {
											type: 'literal',
											value: new tinycolor( captures[1] )
										};
									}
								}

								function matchRGBAColor() {
									return matchCall( tokens.rgbaColor, function () {
										var parts = matchListing( matchNumber );
										return {
											type: 'literal',
											value: new tinycolor( ( parts.length === 4 ? 'rgba(' : 'rgb(' ) + parts.join( ',' ) + ')' )
										};
									} );
								}

								function matchNumber() {
									return scan( tokens.number )[1];
								}

								function matchDistance() {
									return match( '%', tokens.percentageValue, 1 ) ||
									       matchPositionKeyword() ||
									       matchLength();
								}

								function matchPositionKeyword() {
									return match( 'position-keyword', tokens.positionKeywords, 1 );
								}

								function matchLength() {
									return match( 'px', tokens.pixelValue, 1 ) ||
									       match( 'em', tokens.emValue, 1 );
								}

								function match( type, pattern, captureIndex ) {
									var captures = scan( pattern );
									if ( captures ) {
										return {
											type: type,
											value: captures[captureIndex]
										};
									}
								}

								function scan( regexp ) {
									var captures,
										blankCaptures;

									blankCaptures = /^[\n\r\t\s]+/.exec( input );
									if ( blankCaptures ) {
										consume( blankCaptures[0].length );
									}

									captures = regexp.exec( input );
									if ( captures ) {
										consume( captures[0].length );
									}

									return captures;
								}

								function consume( size ) {
									input = input.substr( size );
								}

								return function ( value ) {
									if ( typeof value === 'undefined' ) {
										return [];
									}
									input = value.toString();
									if ( ! input || input === 'none' ) {
										return [];
									}
									return getAST();
								};
							})();
						},
						"gradient-picker.js": function (exports, module, require) {
							(function ( $ ) {

								var gradient_parse = require( './gradient-parser' ),
									gradient_build = require( './gradient-builder' ),
									ColorPicker = require( '../views/controls/color-picker' ),
									base = require( '../views/base' ),
									Knob = require( '../views/controls/knob' );

								/* ################################ GRADIENT PICKER ################################ */
								function pointComparator( l, r ) {
									return l.position - r.position;
								}

								var bind = _.bind;

								function GradientSelection( $el, opts ) {
									this.$el = $el;
									this.$el.css( 'position', 'relative' );

									/* Spectrum colorpicker control */
									this.color_picker = opts.color_picker;
									delete opts.color_picker;
									this.color_picker.on_change = bind( this.colorPickerChange, this );

									this.opts = $.extend( true, {}, opts );
									this.original_opts = $.extend( true, this.opts, {} );

									this.colorStops = [];

									this.$pointsContainer = this.$el.find( '.gradient-picker-points' );

									this.updatePreview = bind( this.updatePreview, this );
									this.previewClicked = bind( this.previewClicked, this );

									var $preview = this.$el.find( '.gradient-picker-preview' );
									this.g2d = $preview[0].getContext( '2d' );
									$preview.click( this.previewClicked );

									this.addPoints( opts.colorStops );
									this.updatePreview( false );
								}

								GradientSelection.prototype = {
									/**
									 * Add one color point to the gradient
									 * @param pointSetup
									 * @param active
									 * @returns {ColorStop}
									 */
									createPoint: function ( pointSetup, active ) {
										return new ColorStop( this.$pointsContainer, pointSetup, this, active )
									},

									/**
									 * Add more color points to the gradient
									 * @param points
									 */
									addPoints: function ( points ) {
										points = (typeof points !== 'undefined') ? points : this.opts.colorStops;
										/**
										 * Figure out the length of the colorStop. If not defined, the rule is (for a 4-color gradient) :
										 * color1  |  color2  |  color3  |  color4
										 * 0       |  33.33%  |  66.67%  |  100%
										 *
										 * General rule (n = number of colors, index = color index):
										 * every other color:           index * ( 100 / n - 1 )
										 *
										 */
										var length = 100 / ( points.length - 1 );
										points.forEach( function ( point, index ) {
											if ( ! point.length ) {
												point.length = {type: '%', value: index * length};
											}

											this.colorStops.push( this.createPoint( point ) );
										}, this );

										this.colorStops[0].select();

										return this;
									},
									/**
									 * Method called when the color picker changes
									 * @param color
									 */
									colorPickerChange: function ( color ) {
										if ( this.cp ) {
											this.cp.colorChanged( color );
										}
									},

									/**
									 * Update gradient picker options
									 * @param opts
									 * @param {Boolean} [trigger_changes] whether or not to trigger changes
									 */
									updateOptions: function ( opts, trigger_changes ) {
										this.opts = $.extend( true, {}, this.opts, opts );
										this.updatePreview( trigger_changes );
									},
									/**
									 * Resets both this.opts and this.original_opts to the values sent as parameter
									 *
									 * @param {Object} opts
									 */
									resetOptions: function ( opts ) {
										this.original_opts = $.extend( true, {}, opts );
										this.reset();
									},
									/**
									 * Update gradient picker preview
									 *
									 * @param {Boolean} [trigger_change] whether or not to trigger the change event. Defaults to true
									 */
									updatePreview: function ( trigger_change ) {

										trigger_change = ( typeof trigger_change !== 'undefined' ) ? trigger_change : true;
										this.g2d.clearRect( 0, 0, this.g2d.canvas.width, this.g2d.canvas.height );
										var grad = this.g2d.createLinearGradient( 0, 0, this.g2d.canvas.width, 0 );
										this.colorStops.sort( pointComparator );

										this.colorStops.forEach( function ( point ) {
											grad.addColorStop( point.position, point.color );
										} );

										this.g2d.fillStyle = grad;
										this.g2d.fillRect( 0, 0, this.g2d.canvas.width, this.g2d.canvas.height );

										if ( trigger_change ) {
											this.opts.change( this.getValue() );
										}
									},

									/**
									 * Get the full gradient node represented as an object
									 *
									 * @return {Object}
									 */
									getValue: function () {
										var node = {
											type: this.opts.type,
											orientation: (this.opts.type === 'linear-gradient' ? this.opts.orientation : ''),
											colorStops: []
										};
										this.colorStops.forEach( function ( point ) {
											node.colorStops.push( {
												type: 'literal',
												value: point.color,
												length: {type: '%', value: ( point.position * 100 | 0 )}
											} );
										} );

										return node;
									},

									/**
									 * Remove one color point from gradient
									 * @param point
									 */
									removeColorStop: function ( point ) {
										var point_id = this.colorStops.indexOf( point );

										if ( point_id != - 1 ) {
											this.colorStops.splice( point_id, 1 );
											point.$el.remove();
										}
									},

									/**
									 * Remove all color points from the gradient
									 */
									removeAllColorStops: function () {
										this.$pointsContainer.empty();
										delete this.colorStops;
										this.colorStops = [];
										return this;
									},

									/**
									 * Method called when the gradient preview is clicked => a new color point is created based on the color that was clicked
									 * @param e
									 */
									previewClicked: function ( e ) {

										this.$pointsContainer.find( '.gradient-picker-point' ).removeClass( 'active' );

										var offset = $( e.target ).offset(),
											x = e.pageX - offset.left,
											y = e.pageY - offset.top,
											imgData = this.g2d.getImageData( x, y, 1, 1 ),
											cp = this.createPoint( {
												position: x / this.g2d.canvas.offsetWidth,
												value: 'rgb(' + imgData.data[0] + ',' + imgData.data[1] + ',' + imgData.data[2] + ')'
											}, true );

										this.cp = cp;

										this.colorStops.push( cp );
										this.colorStops.sort( pointComparator );

										/* Update the preview with the new color points */
										this.updatePreview( true );
									},
									/**
									 * Reset the current gradient picker - remove all points, add the new ones and update the options to their original values
									 */
									reset: function () {
										this.removeAllColorStops();
										this.addPoints( this.original_opts.colorStops );
										this.updateOptions( this.original_opts, false );
									}
								};

								/**
								 * Gradient color point
								 * @param $parentEl jQuery container for the points
								 * @param initialState point data - position and color
								 * @param gradient {GradientSelection} - main GradientSelection object
								 * @param active if the current point should have the active class
								 * @constructor
								 */
								function ColorStop( $parentEl, initialState, gradient, active ) {
									this.$el = $( '<div>', {'class': 'gradient-picker-point'} );
									this.$el.append( '<div class="pt-color"></div>' );
									this.$el.append( '<span class="pt-text"></span>' );
									this.$info = this.$el.find( '.pt-text' );

									$parentEl.append( this.$el );
									this.$parentEl = $parentEl;

									/**
									 * @see gradient-parser.js
									 */
									this.color = initialState.value;
									this.position = typeof initialState.position === 'undefined' ? parseFloat( initialState.length.value || 0 ) / 100 : initialState.position;

									this.gradient = gradient;
									/* If the picker is hidden when loaded, widths are not available */
									this.width = this.$el.outerWidth() || 12;
									this.parentWidth = $parentEl.outerWidth() || 236;

									this.$el.find( '.pt-color' ).css( 'background-color', this.color );

									this.$el.css( 'left', (this.parentWidth - this.width) * (this.position) );

									this.colorChanged = bind( this.colorChanged, this );
									this.start = bind( this.start, this );
									this.move = bind( this.move, this );
									this.stop = bind( this.stop, this );

									var self = this;
									this.$el.tve_draggable( {
										start: bind( self.start, self ),
										move: bind( self.move, self ),
										stop: bind( self.stop, self ),
										dir: 'right'
									} );

									this.max = this.parentWidth - this.width;
									this.min = 0;

									this.info();
									if ( active ) {
										this.select();
									}
								}

								ColorStop.prototype = {
									/**
									 * Updates the text node with this point's current position
									 */
									info: function () {
										this.$info.text( Math.round( ( this.position || 0 ) * 100 ) + '%' );
									},
									/**
									 * Called when the color from the color picker changes
									 * We update the control point color and we update the gradient preview
									 *
									 * @param color
									 */
									colorChanged: function ( color ) {
										this.color = color;
										this.$el.find( '.pt-color' ).css( 'background-color', this.color );
										this.gradient.updatePreview();
									},
									/**
									 * Mark this point (colorStop) as the single selected one
									 */
									select: function () {
										this.gradient.cp = this;

										/* set the color picker the current color that was selected */
										this.gradient.color_picker.setValue( this.color );

										/* mark the current point as active */
										this.$parentEl.find( '.gradient-picker-point' ).removeClass( 'active' );
										this.$el.addClass( 'active' );
									},
									/**
									 * Called when the user clicks on a control point and he starts dragging
									 */
									start: function () {
										/* mark the start position so we now how to calculate the distance for dragging */
										this.startPosition = parseInt( this.$el.css( 'left' ) );
										this.select();
									},

									/**
									 * Method called when we drag the gradient color point
									 * @param delta
									 */
									move: function ( delta ) {
										var position = this.startPosition + delta;

										/* make sure that the point remains inside min,max interval */
										position = position > this.max ? this.max : position;
										position = position < this.min ? this.min : position;

										/* update the point position in the preview */
										this.$el.css( 'left', position );
										this.position = (position / (this.parentWidth - this.width));
										this.info();
										/* update gradient preview */
										this.gradient.updatePreview();
									},
									/**
									 * Method called when we finish moving the gradient color point
									 */
									stop: function () {
										/* update the preview of the gradient */
										this.gradient.updatePreview();
									}
								};

								$.fn.gradientPicker = function ( opts ) {
									var picker;

									opts = $.extend( {change: $.noop}, opts );
									if ( ! this.data( 'gradient-picker' ) ) {
										this.data( 'gradient-picker', picker = new GradientSelection( this, opts ) )
									}
									return picker;
								};

								module.exports = base.base_view.extend( {
									template: TVE.tpl( 'controls/gradient-picker' ),
									initialize: function ( attr ) {
										var self = this;
										this.render();
										this.angle = new Knob( {
											el: this.$( '.tve-gradient-angle' ),
											template: TVE.tpl( 'controls/gradient/knob' ),
											model: {
												config: {
													um: ['DEG'],
													min: 0,
													max: 360,
													type: 'number',
													default: 90
												}
											}
										} );

										this.color_picker = new ColorPicker( {
											el: this.$( '.gradient-color-picker' )[0],
											model: {
												config: {
													options: {
														move: bind( function ( color ) {
															return this.color_picker.on_change( color );
														}, this ),
														change: bind( function ( color ) {
															return this.color_picker.on_change( color );
														}, this ),
														output: 'object',
														flat: true,
														showButtons: false,
														allowEmpty: false,
														showInput: true,
														showAlpha: true
													}
												}
											}
										} );

										this.angle.input = this.angle.change = function ( $element, dom ) {
											self.picker.updateOptions( {orientation: dom.value + 'deg'} );
										};

										this.picker = this.$el.gradientPicker( $.extend( true, {}, this.defaults(), {change: bind( this.trigger_change, this ), color_picker: this.color_picker} ) );
									},
									/**
									 * Get a default gradient node object (2 colors, 90deg, white - black)
									 * @returns {{}}
									 */
									defaults: function () {
										return {
											type: 'linear-gradient',
											orientation: '90deg',
											colorStops: [{type: 'literal', value: '#ffffff'}, {type: 'literal', value: '#000000'}]
										};
									},
									/**
									 * Spectrum - update measurements
									 */
									reflow: function () {
										this.color_picker.reflow();
									},
									/**
									 * Called each time a value has changed in the gradient
									 *
									 * @param gradient_node
									 */
									trigger_change: function ( gradient_node ) {
										this.trigger( 'change', gradient_node );
									},
									/**
									 *
									 * @param $element
									 * @param dom
									 */
									gradient_type: function ( $element, dom ) {
										this.picker.updateOptions( {type: dom.value} );
										this.$( '.gradient-orientation' )[dom.value === 'linear-gradient' ? 'show' : 'hide']();
									},
									/**
									 * Return the gradient picker to its default state
									 */
									reset: function () {
										this.setValue( this._orig );
										this.trigger_change( this.picker.getValue() );

										return false;
									},
									/**
									 * Update the gradient picker by resetting its options to the default values
									 *
									 * @param {String|Object} prop can either be a string (background-image property value) or an object returned by the gradient parser lib
									 */
									setValue: function ( prop ) {
										var node = prop;
										if ( typeof prop === 'string' ) {
											node = gradient_parse( prop );
											if ( ! node || ! node.length ) {
												node = [this.defaults()]
											}
										}
										this._orig = $.extend( true, {}, prop );
										this.picker.resetOptions( node );
										this.angle.setValue( node.orientation ? parseInt( node.orientation ) : 90 );
										this.$( '.gradient-style' ).val( node.type );
										this.$( '.gradient-orientation' )[node.type === 'linear-gradient' ? 'show' : 'hide']();
									},
									/**
									 *
									 * @returns {*|Object}
									 */
									getValue: function () {
										return this.picker.getValue();
									},
									/**
									 * get the configured gradient as a CSS property value
									 */
									getCss: function () {
										return gradient_build( this.picker.getValue() );
									},
									render_favorites: function () {
										this.color_picker.render_favorites();
									}
								} );
							})( jQuery );
						},
						"remove-border-classes.js": function (exports, module, require) {
							/**
							 *
							 * Removes TCB1-style border classes from an element
							 *
							 * @param {jquery} $element
							 */
							module.exports = function ( $element ) {
								$element.removeClass( function ( index, className ) {
									if ( className.match( /tve_brdr_([^\s'"]+)/ ) ) {
										return 'tve_brdr_' + RegExp.$1;
									}
									return '';
								} );
							};
						},
						"shortcode-manager.js": function (exports, module, require) {
							module.exports = function ( $config, key ) {
								var _configKey = '__CONFIG_' + key + '__';
								return {
									update: function ( value, property ) {
										var _data = this.get();
										_data[property] = value;
										this.save( _data );
									},
									save: function ( data ) {
										$config.html( _configKey + JSON.stringify( data ).replace( /\\"/g, '_tve_quote_' ) + _configKey );
									},
									get: function () {
										var replace = new RegExp( _configKey, 'g' );
										return JSON.parse( $config.html().replace( /_tveutf8_/g, '\\u' ).replace( replace, '' ).replace( /\\\'/g, "'" ).replace( /_tve_quote_/g, '\\"' ) );
									}
								}
							};
						},
						"spectrum.js": function (exports, module, require) {
							// Spectrum Colorpicker v1.8.0
							// https://github.com/bgrins/spectrum
							// Author: Brian Grinstead
							// License: MIT
							(function ( $, undefined ) {

								var defaultOpts = {

										// Callbacks
										beforeShow: noop,
										move: noop,
										change: noop,
										show: noop,
										hide: noop,
										saveFavorite: noop,

										// Options
										color: false,
										flat: false,
										showInput: false,
										allowEmpty: false,
										showButtons: true,
										clickoutFiresChange: true,
										showInitial: false,
										showPalette: false,
										showPaletteOnly: false,
										hideAfterPaletteSelect: false,
										togglePaletteOnly: false,
										showSelectionPalette: true,
										localStorageKey: false,
										appendTo: "body",
										maxSelectionSize: 7,
										cancelText: "cancel",
										chooseText: "choose",
										togglePaletteMoreText: "more",
										togglePaletteLessText: "less",
										clearText: "Clear Color Selection",
										noColorSelectedText: "No Color Selected",
										preferredFormat: false,
										className: "", // Deprecated - use containerClassName and replacerClassName instead.
										containerClassName: "",
										replacerClassName: "",
										showAlpha: false,
										theme: "sp-light",
										palette: [["#ffffff", "#000000", "#ff0000", "#ff8000", "#ffff00", "#008000", "#4b0082", "#9400d3", "#0000ff", "#4b0082", "#9400d3", "rgba(0,0,0,.5)"]],
										selectionPalette: [],
										disabled: false,
										offset: null,
										showSaveButton: false
									},
									tinycolor = require( './tinycolor' ),
									spectrums = [],
									IE = ! ! /msie/i.exec( window.navigator.userAgent ),
									rgbaSupport = (function () {
										function contains( str, substr ) {
											return ! ! ~ ('' + str).indexOf( substr );
										}

										var elem = document.createElement( 'div' );
										var style = elem.style;
										style.cssText = 'background-color:rgba(0,0,0,.5)';
										return contains( style.backgroundColor, 'rgba' ) || contains( style.backgroundColor, 'hsla' );
									})(),
									replaceInput = [
										"<div class='sp-replacer'>",
										"<div class='sp-preview'><div class='sp-preview-inner'></div></div>",
										"<div class='sp-dd'>&#9660;</div>",
										"</div>"
									].join( '' ),
									markup = (function () {

										return [
											"<div class='sp-container sp-hidden'>",
											"<div class='sp-top sp-cf'>",
											"<div class='sp-col col-hue'><div class='sp-hue'><div class='sp-slider'></div></div></div>",
											"<div class='sp-picker-container'>",
											"<div class='sp-col col-color'>",
											"<div class='sp-color'>",
											"<div class='sp-sat'>",
											"<div class='sp-val'>",
											"<div class='sp-dragger'></div>",
											"</div>",
											"</div>",
											"</div>",
											"</div>",
											"</div>",
											"<div class='sp-col col-alpha sp-alpha'><div class='sp-transparent'><div class='sp-alpha-inner'><div class='sp-alpha-handle'></div></div></div></div>",
											"</div>",

											/* Color preview / input + opacity functionality */
											"<div class='row middle-xs between-xs sp-extra-controls'>",
											"<div class='col-xs-5 sp-ctrl-color sp-padded-top sp-input-container'><div class='sp-preview-color'></div><input class='sp-input' type='text' spellcheck='false' /></div>",
											"<div class='col-xs-7 sp-ctrl-opacity sp-padded-top'></div>",
											"</div>",
											/* End color preview / input + opacity functionality */

											/* clear / save color functionality */
											"<div class='row middle-xs between-xs sp-action-buttons'>",
											"<div class='col-xs-5 w-47 sp-padded-top'><div class='sp-clear tve-button lightgrey sp-clear-display'>CLEAR</div></div>",
											"<div class='col-xs-5 w-47 sp-padded-top'><div class='tve-button lightgrey sp-save-fav'>SAVE COLOR</div></div>",
											"</div>",
											/* end clear / save row */

											"<div class='sp-palette-container margin-top-10 padding-top-10'>",
											"<div class='sp-palette sp-thumb dark-box sp-cf clearfix'></div>",
											"<div class='sp-palette-button-container sp-cf'>",
											"<button type='button' class='sp-palette-toggle'></button>",
											"</div>",
											"</div>",

											"<div class='sp-initial sp-thumb sp-cf'></div>",
											"<div class='sp-button-container action-buttons row between-xs'>",
											"<div class='click sp-cancel tcb-btn tve-button'></div>",
											"<div class='click sp-choose tcb-btn tve-button'></div>",
											"</div>",
											"</div>",
											"</div>"
										].join( "" );
									})();

								function paletteTemplate( p, color, className, opts ) {
									var html = [];
									for ( var i = 0; i < p.length; i ++ ) {
										var current = p[i];
										if ( current ) {
											var tiny = tinycolor( current );
											var c = tiny.toHsl().l < 0.5 ? "sp-thumb-el sp-thumb-dark" : "sp-thumb-el sp-thumb-light";
											c += (tinycolor.equals( color, current )) ? " sp-thumb-active" : "";
											var formattedString = tiny.toString( opts.preferredFormat || "rgb" );
											var swatchStyle = rgbaSupport ? ("background-color:" + tiny.toRgbString()) : "filter:" + tiny.toFilter();
											html.push( '<span title="' + formattedString + '" data-color="' + tiny.toRgbString() + '" class="' + c + '"><span class="sp-thumb-inner" style="' + swatchStyle + ';" /></span>' );
										} else {
											var cls = 'sp-clear-display';
											html.push( $( '<div />' )
												.append( $( '<span data-color="" style="background-color:transparent;" class="' + cls + '"></span>' )
													.attr( 'title', opts.noColorSelectedText )
												)
												.html()
											);
										}
									}
									return "<div class='sp-cf " + className + "'>" + html.join( '' ) + "</div>";
								}

								function hideAll() {
									for ( var i = 0; i < spectrums.length; i ++ ) {
										if ( spectrums[i] ) {
											spectrums[i].hide();
										}
									}
								}

								function instanceOptions( o, callbackContext ) {
									var opts = $.extend( {}, defaultOpts, o );
									opts.callbacks = {
										'move': bind( opts.move, callbackContext ),
										'change': bind( opts.change, callbackContext ),
										'show': bind( opts.show, callbackContext ),
										'hide': bind( opts.hide, callbackContext ),
										'cancel': bind( opts.cancel, callbackContext ),
										'beforeShow': bind( opts.beforeShow, callbackContext ),
										'saveFavorite': bind( opts.saveFavorite, callbackContext )
									};

									return opts;
								}

								function spectrum( element, o ) {

									var opts = instanceOptions( o, element ),
										flat = opts.flat,
										showSelectionPalette = opts.showSelectionPalette,
										localStorageKey = opts.localStorageKey,
										theme = opts.theme,
										callbacks = opts.callbacks,
										resize = throttle( reflow, 10 ),
										visible = false,
										isDragging = false,
										dragWidth = 0,
										dragHeight = 0,
										dragHelperHeight = 0,
										slideHeight = 0,
										slideWidth = 0,
										alphaHeight = 0,
										alphaSlideHelperHeight = 0,
										slideHelperHeight = 0,
										currentHue = 0,
										currentSaturation = 0,
										currentValue = 0,
										currentAlpha = 1,
										palette = [],
										paletteArray = [],
										paletteLookup = {},
										selectionPalette = opts.selectionPalette.slice( 0 ),
										maxSelectionSize = opts.maxSelectionSize,
										draggingClass = "sp-dragging",
										shiftMovementDirection = null;

									var doc = element.ownerDocument,
										body = doc.body,
										boundElement = $( element ),
										disabled = false,
										container = $( markup, doc ).addClass( theme ),
										pickerContainer = container.find( ".sp-picker-container" ),
										dragger = container.find( ".sp-color" ),
										dragHelper = container.find( ".sp-dragger" ),
										slider = container.find( ".sp-hue" ),
										slideHelper = container.find( ".sp-slider" ),
										alphaSliderInner = container.find( ".sp-alpha-inner" ),
										alphaSlider = container.find( ".sp-alpha" ),
										alphaSlideHelper = container.find( ".sp-alpha-handle" ),
										textInput = container.find( ".sp-input" ),
										paletteContainer = container.find( ".sp-palette" ),
										initialColorContainer = container.find( ".sp-initial" ),
										cancelButton = container.find( ".sp-cancel" ),
										clearButton = container.find( ".sp-clear" ),
										chooseButton = container.find( ".sp-choose" ),
										toggleButton = container.find( ".sp-palette-toggle" ),
										previewColor = container.find( '.sp-preview-color' ),
										saveFavButton = container.find( '.sp-save-fav' ),
										isInput = boundElement.is( "input" ),
										isInputTypeColor = isInput && boundElement.attr( "type" ) === "color" && inputTypeColorSupport(),
										shouldReplace = isInput && ! flat,
										replacer = (shouldReplace) ? $( replaceInput ).addClass( theme ).addClass( opts.className ).addClass( opts.replacerClassName ) : $( [] ),
										offsetElement = (shouldReplace) ? replacer : boundElement,
										previewElement = replacer.find( ".sp-preview-inner" ),
										initialColor = opts.color || (isInput && boundElement.val()),
										colorOnShow = false,
										currentPreferredFormat = opts.preferredFormat,
										clickoutFiresChange = false, // ! opts.showButtons || opts.clickoutFiresChange, /* commented this out, it was causing all sorts of unexpected behaviors for hidden pickers */
										isEmpty = ! initialColor,
										allowEmpty = opts.allowEmpty && ! isInputTypeColor;

									function applyOptions() {

										if ( opts.showPaletteOnly ) {
											opts.showPalette = true;
										}

										toggleButton.text( opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText );

										if ( opts.palette ) {
											palette = opts.palette.slice( 0 );
											paletteArray = $.isArray( palette[0] ) ? palette : [palette];
											paletteLookup = {};
											for ( var i = 0; i < paletteArray.length; i ++ ) {
												for ( var j = 0; j < paletteArray[i].length; j ++ ) {
													var rgb = tinycolor( paletteArray[i][j] ).toRgbString();
													paletteLookup[rgb] = true;
												}
											}
										}

										container.toggleClass( "sp-flat", flat );
										container.toggleClass( "sp-input-disabled", ! opts.showInput );
										container.toggleClass( "sp-alpha-enabled", opts.showAlpha );
										container.toggleClass( "sp-clear-enabled", allowEmpty );
										container.toggleClass( "sp-buttons-disabled", ! opts.showButtons );
										container.toggleClass( "sp-palette-buttons-disabled", ! opts.togglePaletteOnly );
										container.toggleClass( "sp-palette-disabled", ! opts.showPalette );
										container.toggleClass( "sp-palette-only", opts.showPaletteOnly );
										container.toggleClass( "sp-initial-disabled", ! opts.showInitial );
										container.toggleClass( 'sp-save-disabled', ! opts.showSaveButton );
										container.addClass( opts.className ).addClass( opts.containerClassName );

										if ( ! opts.flat ) {
											container.addClass( 'drop-panel panel-dark' ).append( '<div class="tcb-panel-arrow"></div>' );
										}

										if ( opts.showAlpha && opts.alpha_input ) {
											container.find( '.sp-ctrl-opacity' ).append( opts.alpha_input.$el );
											opts.alpha_input.change = function () {
												currentAlpha = parseFloat( this.$input.val() ) / 100;

												move();
											};
										}

										reflow();
									}

									function initialize() {

										if ( IE ) {
											container.find( "*:not(input)" ).attr( "unselectable", "on" );
										}

										applyOptions();

										if ( shouldReplace ) {
											boundElement.after( replacer ).hide();
										}

										if ( ! allowEmpty ) {
											clearButton.hide();
										}

										if ( flat ) {
											boundElement.after( container ).hide();
										}
										else {

											var appendTo = opts.appendTo === "parent" ? boundElement.parent() : $( opts.appendTo );
											if ( appendTo.length !== 1 ) {
												appendTo = $( "body" );
											}

											appendTo.append( container );
										}

										updateSelectionPaletteFromStorage();

										offsetElement.bind( "click.spectrum touchstart.spectrum", function ( e ) {
											if ( ! disabled ) {
												toggle();
											}

											e.stopPropagation();

											if ( ! $( e.target ).is( "input" ) ) {
												e.preventDefault();
											}
										} );

										if ( boundElement.is( ":disabled" ) || (opts.disabled === true) ) {
											disable();
										}

										// Prevent clicks from bubbling up to document.  This would cause it to be hidden.
										container.click( stopPropagation );

										// Handle user typed input
										textInput.change( setFromTextInput );
										textInput.bind( "paste", function () {
											setTimeout( setFromTextInput, 1 );
										} );
										textInput.keydown( function ( e ) {
											if ( e.keyCode == 13 ) {
												setFromTextInput();
											}
										} );

										cancelButton.text( opts.cancelText );
										cancelButton.bind( "click.spectrum", function ( e ) {
											e.stopPropagation();
											e.preventDefault();
											revert();
											hide();
											/* canceling the selection triggers move so we can see the event */
											callbacks.move( get() );
											callbacks.cancel && callbacks.cancel();
										} );

										clearButton.attr( "title", opts.clearText );
										clearButton.bind( "click.spectrum", function ( e ) {
											e.stopPropagation();
											e.preventDefault();
											isEmpty = true;
											move();

											if ( flat ) {
												//for the flat style, this is a change event
												updateOriginalInput( true );
											}
										} );

										chooseButton.text( opts.chooseText );
										chooseButton.bind( "click.spectrum", function ( e ) {
											e.stopPropagation();
											e.preventDefault();

											if ( IE && textInput.is( ":focus" ) ) {
												textInput.trigger( 'change' );
											}

											if ( isValid() ) {
												updateOriginalInput( true );
												hide();
											}
										} );

										saveFavButton.on( 'click.spectrum', function ( e ) {
											e.stopPropagation();
											e.preventDefault();
											callbacks.saveFavorite( get() );
										} );

										toggleButton.text( opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText );
										toggleButton.bind( "click.spectrum", function ( e ) {
											e.stopPropagation();
											e.preventDefault();

											opts.showPaletteOnly = ! opts.showPaletteOnly;

											// To make sure the Picker area is drawn on the right, next to the
											// Palette area (and not below the palette), first move the Palette
											// to the left to make space for the picker, plus 5px extra.
											// The 'applyOptions' function puts the whole container back into place
											// and takes care of the button-text and the sp-palette-only CSS class.
											if ( ! opts.showPaletteOnly && ! flat ) {
												container.css( 'left', '-=' + (pickerContainer.outerWidth( true ) + 5) );
											}
											applyOptions();
										} );

										draggable( alphaSlider, function ( dragX, dragY, e ) {
											currentAlpha = (1 - (dragY / alphaHeight));
											isEmpty = false;
											if ( e.shiftKey ) {
												currentAlpha = Math.round( currentAlpha * 10 ) / 10;
											}

											move();
										}, dragStart, dragStop );

										draggable( slider, function ( dragX, dragY ) {
											currentHue = parseFloat( dragY / slideHeight );
											isEmpty = false;
											if ( ! opts.showAlpha ) {
												currentAlpha = 1;
											}
											move();
										}, dragStart, dragStop );

										draggable( dragger, function ( dragX, dragY, e ) {

											// shift+drag should snap the movement to either the x or y axis.
											if ( ! e.shiftKey ) {
												shiftMovementDirection = null;
											}
											else if ( ! shiftMovementDirection ) {
												var oldDragX = currentSaturation * dragWidth;
												var oldDragY = dragHeight - (currentValue * dragHeight);
												var furtherFromX = Math.abs( dragX - oldDragX ) > Math.abs( dragY - oldDragY );

												shiftMovementDirection = furtherFromX ? "x" : "y";
											}

											var setSaturation = ! shiftMovementDirection || shiftMovementDirection === "x";
											var setValue = ! shiftMovementDirection || shiftMovementDirection === "y";

											if ( setSaturation ) {
												currentSaturation = parseFloat( dragX / dragWidth );
											}
											if ( setValue ) {
												currentValue = parseFloat( (dragHeight - dragY) / dragHeight );
											}

											isEmpty = false;
											if ( ! opts.showAlpha ) {
												currentAlpha = 1;
											}

											move();

										}, dragStart, dragStop );

										if ( ! ! initialColor ) {
											set( initialColor );

											// In case color was black - update the preview UI and set the format
											// since the set function will not run (default color is black).
											updateUI();
											currentPreferredFormat = opts.preferredFormat || tinycolor( initialColor ).format;

											addColorToSelectionPalette( initialColor );
										}
										else {
											updateUI();
										}

										if ( flat ) {
											show();
										}

										function paletteElementClick( e ) {
											if ( e.data && e.data.ignore ) {
												set( $( e.target ).closest( ".sp-thumb-el" ).data( "color" ) );
												move();
											}
											else {
												set( $( e.target ).closest( ".sp-thumb-el" ).data( "color" ) );
												move();
												updateOriginalInput( true );
												if ( opts.hideAfterPaletteSelect ) {
													hide();
												}
											}

											return false;
										}

										var paletteEvent = IE ? "mousedown.spectrum" : "click.spectrum touchstart.spectrum";
										paletteContainer.delegate( ".sp-thumb-el", paletteEvent, paletteElementClick );
										initialColorContainer.delegate( ".sp-thumb-el:nth-child(1)", paletteEvent, {ignore: true}, paletteElementClick );
									}

									function updateSelectionPaletteFromStorage() {

										if ( localStorageKey && window.localStorage ) {

											// Migrate old palettes over to new format.  May want to remove this eventually.
											try {
												var oldPalette = window.localStorage[localStorageKey].split( ",#" );
												if ( oldPalette.length > 1 ) {
													delete window.localStorage[localStorageKey];
													$.each( oldPalette, function ( i, c ) {
														addColorToSelectionPalette( c );
													} );
												}
											}
											catch ( e ) {
											}

											try {
												selectionPalette = window.localStorage[localStorageKey].split( ";" );
											}
											catch ( e ) {
											}
										}
									}

									function addColorToSelectionPalette( color ) {
										if ( showSelectionPalette ) {
											var rgb = tinycolor( color ).toRgbString();
											if ( ! paletteLookup[rgb] && $.inArray( rgb, selectionPalette ) === - 1 ) {
												selectionPalette.push( rgb );
												while ( selectionPalette.length > maxSelectionSize ) {
													selectionPalette.shift();
												}
											}

											if ( localStorageKey && window.localStorage ) {
												try {
													window.localStorage[localStorageKey] = selectionPalette.join( ";" );
												}
												catch ( e ) {
												}
											}
										}
									}

									function getUniqueSelectionPalette() {
										var unique = [];
										if ( opts.showPalette ) {
											for ( var i = 0; i < selectionPalette.length; i ++ ) {
												var rgb = tinycolor( selectionPalette[i] ).toRgbString();

												if ( ! paletteLookup[rgb] ) {
													unique.push( selectionPalette[i] );
												}
											}
										}

										return unique.reverse().slice( 0, opts.maxSelectionSize );
									}

									function drawPalette() {

										var currentColor = get();

										var html = $.map( paletteArray, function ( palette, i ) {
											return paletteTemplate( palette, currentColor, "sp-palette-row sp-palette-row-" + i, opts );
										} );

										updateSelectionPaletteFromStorage();

										if ( selectionPalette ) {
											html.push( paletteTemplate( getUniqueSelectionPalette(), currentColor, "sp-palette-row sp-palette-row-selection", opts ) );
										}

										paletteContainer.html( html.join( "" ) );
									}

									function drawInitial() {
										if ( opts.showInitial ) {
											var initial = colorOnShow;
											var current = get();
											initialColorContainer.html( paletteTemplate( [initial, current], current, "sp-palette-row-initial", opts ) );
										}
									}

									function dragStart() {
										if ( dragHeight <= 0 || dragWidth <= 0 || slideHeight <= 0 ) {
											reflow();
										}
										isDragging = true;
										container.addClass( draggingClass );
										shiftMovementDirection = null;
										boundElement.trigger( 'dragstart.spectrum', [get()] );
									}

									function dragStop() {
										isDragging = false;
										container.removeClass( draggingClass );
										boundElement.trigger( 'dragstop.spectrum', [get()] );
									}

									function setFromTextInput() {

										var value = textInput.val();

										if ( (value === null || value === "") && allowEmpty ) {
											set( null );
											updateOriginalInput( true );
										}
										else {
											var tiny = tinycolor( value );
											if ( tiny.isValid() ) {
												set( tiny );
												updateOriginalInput( true );
											}
											else {
												textInput.addClass( "has-error" );
											}
										}
									}

									function toggle() {
										if ( visible ) {
											hide();
										}
										else {
											show();
										}
									}

									function show() {
										var event = $.Event( 'beforeShow.spectrum' );

										if ( visible ) {
											reflow();
											return;
										}

										boundElement.trigger( event, [get()] );

										if ( callbacks.beforeShow( get() ) === false || event.isDefaultPrevented() ) {
											return;
										}

										hideAll();
										visible = true;

										$( doc ).bind( "keydown.spectrum", onkeydown );
										$( doc ).bind( "click.spectrum", clickout );
										$( window ).bind( "resize.spectrum", resize );
										replacer.addClass( "sp-active" );
										container.removeClass( "sp-hidden" );

										reflow();
										updateUI();

										colorOnShow = get();

										drawInitial();
										callbacks.show( colorOnShow );
										boundElement.trigger( 'show.spectrum', [colorOnShow] );
									}

									function onkeydown( e ) {
										// Close on ESC
										if ( e.keyCode === 27 ) {
											hide();
										}
									}

									function clickout( e ) {
										// Return on right click.

										//todo: discuss if clicking out should or not apply the selected color?
										return;
										if ( e.button == 2 ) {
											return;
										}

										// If a drag event was happening during the mouseup, don't hide
										// on click.
										if ( isDragging ) {
											return;
										}

										if ( clickoutFiresChange ) {
											updateOriginalInput( true );
										}
										else {
											revert();
										}
										hide();
									}

									function hide() {
										// Return if hiding is unnecessary
										if ( ! visible || flat ) {
											return;
										}
										visible = false;

										$( doc ).unbind( "keydown.spectrum", onkeydown );
										$( doc ).unbind( "click.spectrum", clickout );
										$( window ).unbind( "resize.spectrum", resize );

										replacer.removeClass( "sp-active" );
										container.addClass( "sp-hidden" );

										callbacks.hide( get() );
										boundElement.trigger( 'hide.spectrum', [get()] );
									}

									function revert() {
										set( colorOnShow, true );
									}

									function set( color, ignoreFormatChange ) {
										if ( tinycolor.equals( color, get() ) ) {
											// Update UI just in case a validation error needs
											// to be cleared.
											updateUI();
											return;
										}

										var newColor, newHsv;
										if ( ! color && allowEmpty ) {
											isEmpty = true;
										} else {
											isEmpty = false;
											newColor = tinycolor( color );
											newHsv = newColor.toHsv();

											currentHue = (newHsv.h % 360) / 360;
											currentSaturation = newHsv.s;
											currentValue = newHsv.v;
											currentAlpha = newHsv.a;
										}
										updateUI();

										if ( newColor && newColor.isValid() && ! ignoreFormatChange ) {
											currentPreferredFormat = opts.preferredFormat || newColor.getFormat();
										}
									}

									function get( opts ) {
										opts = opts || {};

										if ( allowEmpty && isEmpty ) {
											return null;
										}

										return tinycolor.fromRatio( {
											h: currentHue,
											s: currentSaturation,
											v: currentValue,
											a: Math.round( currentAlpha * 100 ) / 100
										}, {format: opts.format || currentPreferredFormat} );
									}

									function isValid() {
										return ! textInput.hasClass( "has-error" );
									}

									function move() {
										updateUI();

										callbacks.move( get() );
										boundElement.trigger( 'move.spectrum', [get()] );
									}

									function updateUI() {

										textInput.removeClass( "has-error" );

										updateHelperLocations();

										// Update dragger background color (gradients take care of saturation and value).
										var flatColor = tinycolor.fromRatio( {h: currentHue, s: 1, v: 1} );
										dragger.css( "background-color", flatColor.toHexString() );

										// Get a format that alpha will be included in (hex and names ignore alpha)
										var format = currentPreferredFormat;
										if ( currentAlpha < 1 && ! (currentAlpha === 0 && format === "name") ) {
											if ( format === "hex" || format === "hex3" || format === "hex6" || format === "name" ) {
												format = "rgb";
											}
										}

										var realColor = get( {format: format} ),
											displayColor = '';

										//reset background info for preview element
										previewElement.removeClass( "sp-clear-display" );
										previewElement.css( 'background', 'transparent' );
										previewColor.removeClass( 'sp-transparent' );

										if ( ! realColor && allowEmpty ) {
											// Update the replaced elements background with icon indicating no color selection
											previewElement.addClass( "sp-clear-display" );
											previewColor.addClass( 'sp-transparent' );
										}
										else {
											var realHex = realColor.toHexString(),
												realRgb = realColor.toRgbString();

											// Update the replaced elements background color (with actual selected color)
											if ( rgbaSupport || realColor.alpha === 1 ) {
												previewElement.css( "background", realRgb );
											}
											else {
												previewElement.css( "background", "transparent" );
												previewElement.css( "filter", realColor.toFilter() );
											}
											previewColor.css( 'background-color', realHex );

											if ( opts.showAlpha ) {
												var rgb = realColor.toRgb();
												rgb.a = 0;
												var realAlpha = tinycolor( rgb ).toRgbString();
												var gradient = "linear-gradient(left, " + realAlpha + ", " + realHex + ")";
												// Use current syntax gradient on unprefixed property.
												alphaSliderInner.css( "background-image", "linear-gradient(to top, " + realAlpha + ", " + realHex + ")" );
												if ( opts.alpha_input ) {
													var _alpha = ( currentAlpha * 100 );
													_alpha = _alpha != parseInt( _alpha ) ? _alpha.toFixed( 1 ) : _alpha;
													opts.alpha_input.setValueDirectly( _alpha );
												}
											}

											displayColor = realColor.toString( format );
										}

										// Update the text entry input as it changes happen
										if ( opts.showInput ) {
											/* changed this to always display hex colors */
											textInput.val( realHex );
										}

										if ( opts.showPalette ) {
											drawPalette();
										}

										drawInitial();
									}

									function updateHelperLocations() {
										var s = currentSaturation;
										var v = currentValue;

										if ( allowEmpty && isEmpty ) {
											//if selected color is empty, hide the helpers
											alphaSlideHelper.hide();
											slideHelper.hide();
											dragHelper.hide();
										}
										else {
											//make sure helpers are visible
											alphaSlideHelper.show();
											slideHelper.show();
											dragHelper.show();

											// Where to show the little circle in that displays your current selected color
											var dragX = s * dragWidth;
											var dragY = dragHeight - (v * dragHeight);
											dragX = Math.max(
												- dragHelperHeight / 2,
												Math.min( dragWidth - dragHelperHeight / 2, dragX - dragHelperHeight / 2 )
											);
											dragY = Math.max(
												- dragHelperHeight / 2,
												Math.min( dragHeight - dragHelperHeight / 2, dragY - dragHelperHeight / 2 )
											);
											dragHelper.css( {
												"top": dragY + "px",
												"left": dragX + "px"
											} );

											var alphaY = ( 1 - currentAlpha ) * alphaHeight;
											alphaSlideHelper.css( {
												"top": ( alphaY - ( alphaSlideHelperHeight / 2 ) ) + "px"
											} );

											// Where to show the bar that displays your current selected hue
											var slideY = (currentHue) * slideHeight;
											slideHelper.css( {
												"top": (slideY - ( slideHelperHeight / 2 ) ) + "px"
											} );
										}
									}

									function updateOriginalInput( fireCallback ) {
										var color = get();
										if ( ! color && ! colorOnShow ) {
											return;
										}
										var displayColor = '',
											hasChanged = ! tinycolor.equals( color, colorOnShow );

										if ( color ) {
											displayColor = color.toString( currentPreferredFormat );
											// Update the selection palette with the current color
											addColorToSelectionPalette( color );
										}

										if ( isInput ) {
											boundElement.val( displayColor );
										}
										if ( fireCallback && hasChanged ) {
											callbacks.change( color );
											boundElement.trigger( 'change', [color] );
										}
									}

									function reflow() {
										if ( ! visible ) {
											return; // Calculations would be useless and wouldn't be reliable anyways
										}
										dragWidth = dragger.width();
										dragHeight = dragger.height();
										dragHelperHeight = dragHelper.outerHeight();
										slideWidth = slider.width();
										slideHeight = slider.height();
										slideHelperHeight = slideHelper.outerHeight();
										alphaHeight = alphaSlider.height();
										alphaSlideHelperHeight = alphaSlideHelper.outerHeight();

										if ( ! flat ) {
											container.css( "position", "absolute" );
											if ( opts.offset ) {
												container.offset( opts.offset );
											} else {
												var _o = getOffset( container, offsetElement );
												if ( ! _o.above ) {
													_o.top += 10; // account for the the drop-panel arrow
												} else {
													_o.top -= 20;
												}
												container.find( '.tcb-panel-arrow' )
													.css( 'left', ( offsetElement.outerWidth() / 2 + _o.left - TVE.panel_offset.left ) + 'px' );

												container.offset( _o );
											}
										}

										updateHelperLocations();

										if ( opts.showPalette ) {
											drawPalette();
										}

										boundElement.trigger( 'reflow.spectrum' );
									}

									function destroy() {
										boundElement.show();
										offsetElement.unbind( "click.spectrum touchstart.spectrum" );
										container.remove();
										replacer.remove();
										spectrums[spect.id] = null;
									}

									function option( optionName, optionValue ) {
										if ( optionName === undefined ) {
											return $.extend( {}, opts );
										}
										if ( optionValue === undefined ) {
											return opts[optionName];
										}

										opts[optionName] = optionValue;

										if ( optionName === "preferredFormat" ) {
											currentPreferredFormat = opts.preferredFormat;
										}
										applyOptions();
									}

									function enable() {
										disabled = false;
										boundElement.attr( "disabled", false );
										offsetElement.removeClass( "sp-disabled" );
									}

									function disable() {
										hide();
										disabled = true;
										boundElement.attr( "disabled", true );
										offsetElement.addClass( "sp-disabled" );
									}

									function setOffset( coord ) {
										opts.offset = coord;
										reflow();
									}

									initialize();

									var spect = {
										show: show,
										hide: hide,
										toggle: toggle,
										reflow: reflow,
										option: option,
										enable: enable,
										disable: disable,
										offset: setOffset,
										set: function ( c, fireChange ) {
											set( c );
											updateOriginalInput( fireChange );
										},
										get: get,
										destroy: destroy,
										container: container
									};

									spect.id = spectrums.push( spect ) - 1;

									return spect;
								}

								/**
								 * checkOffset - get the offset below/above and left/right element depending on screen position
								 * Thanks https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.datepicker.js
								 */
								function getOffset( picker, input ) {
									var extraY = 0;
									var dpWidth = picker.outerWidth();
									var dpHeight = picker.outerHeight();
									var inputHeight = input.outerHeight();
									var doc = picker[0].ownerDocument;
									var docElem = doc.documentElement;
									var viewWidth = docElem.clientWidth + $( doc ).scrollLeft();
									var viewHeight = docElem.clientHeight + $( doc ).scrollTop();
									var offset = input.offset();
									offset.top += inputHeight;

									/**
									 * Commented this out - the picker will always fit into the panel
									 *
									 */
									/*
									 offset.left -=
									 Math.min( offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
									 Math.abs( offset.left + dpWidth - viewWidth ) : 0 );
									 */

									/* update: always position the colorpicker below the element */
									/*
									 offset.top -=
									 Math.min( offset.top, ((offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
									 Math.abs( dpHeight + inputHeight - extraY ) : extraY) );

									 offset.above = ( offset.top < input.offset().top );
									 */

									return offset;
								}

								/**
								 * noop - do nothing
								 */
								function noop() {

								}

								/**
								 * stopPropagation - makes the code only doing this a little easier to read in line
								 */
								function stopPropagation( e ) {
									e.stopPropagation();
								}

								/**
								 * Create a function bound to a given object
								 * Thanks to underscore.js
								 */
								function bind( func, obj ) {
									var slice = Array.prototype.slice;
									var args = slice.call( arguments, 2 );
									return function () {
										return func.apply( obj, args.concat( slice.call( arguments ) ) );
									};
								}

								/**
								 * Lightweight drag helper.  Handles containment within the element, so that
								 * when dragging, the x is within [0,element.width] and y is within [0,element.height]
								 */
								function draggable( element, onmove, onstart, onstop ) {
									onmove = onmove || function () {
										};
									onstart = onstart || function () {
										};
									onstop = onstop || function () {
										};
									var doc = document;
									var dragging = false;
									var offset = {};
									var maxHeight = 0;
									var maxWidth = 0;
									var hasTouch = ('ontouchstart' in window);

									var duringDragEvents = {};
									duringDragEvents["selectstart"] = prevent;
									duringDragEvents["dragstart"] = prevent;
									duringDragEvents["touchmove mousemove"] = move;
									duringDragEvents["touchend mouseup"] = stop;

									function prevent( e ) {
										if ( e.stopPropagation ) {
											e.stopPropagation();
										}
										if ( e.preventDefault ) {
											e.preventDefault();
										}
										e.returnValue = false;
									}

									function move( e ) {
										if ( dragging ) {
											// Mouseup happened outside of window
											if ( IE && doc.documentMode < 9 && ! e.button ) {
												return stop();
											}

											var t0 = e.originalEvent && e.originalEvent.touches && e.originalEvent.touches[0];
											var pageX = t0 && t0.pageX || e.pageX;
											var pageY = t0 && t0.pageY || e.pageY;

											var dragX = Math.max( 0, Math.min( pageX - offset.left, maxWidth ) );
											var dragY = Math.max( 0, Math.min( pageY - offset.top, maxHeight ) );

											if ( hasTouch ) {
												// Stop scrolling in iOS
												prevent( e );
											}

											onmove.apply( element, [dragX, dragY, e] );
										}
									}

									function start( e ) {
										var rightclick = (e.which) ? (e.which == 3) : (e.button == 2);

										if ( ! rightclick && ! dragging ) {
											if ( onstart.apply( element, arguments ) !== false ) {
												dragging = true;
												maxHeight = $( element ).height();
												maxWidth = $( element ).width();
												offset = $( element ).offset();

												$( doc ).bind( duringDragEvents );
												$( doc.body ).addClass( "sp-dragging" );

												move( e );

												prevent( e );
											}
										}
									}

									function stop() {
										if ( dragging ) {
											$( doc ).unbind( duringDragEvents );
											$( doc.body ).removeClass( "sp-dragging" );

											// Wait a tick before notifying observers to allow the click event
											// to fire in Chrome.
											setTimeout( function () {
												onstop.apply( element, arguments );
											}, 0 );
										}
										dragging = false;
									}

									$( element ).bind( "touchstart mousedown", start );
								}

								function throttle( func, wait, debounce ) {
									var timeout;
									return function () {
										var context = this, args = arguments;
										var throttler = function () {
											timeout = null;
											func.apply( context, args );
										};
										if ( debounce ) {
											clearTimeout( timeout );
										}
										if ( debounce || ! timeout ) {
											timeout = setTimeout( throttler, wait );
										}
									};
								}

								function inputTypeColorSupport() {
									return $.fn.spectrum.inputTypeColorSupport();
								}

								/**
								 * Define a jQuery plugin
								 */
								var dataID = "spectrum.id";
								$.fn.spectrum = function ( opts, extra ) {

									if ( typeof opts == "string" ) {

										var returnValue = this;
										var args = Array.prototype.slice.call( arguments, 1 );

										this.each( function () {
											var spect = spectrums[$( this ).data( dataID )];
											if ( spect ) {
												var method = spect[opts];
												if ( ! method ) {
													throw new Error( "Spectrum: no such method: '" + opts + "'" );
												}

												switch ( opts ) {
													case 'get':
														returnValue = spect.get();
														break;
													case 'container':
														returnValue = spect.container;
														break;
													case 'option':
														returnValue = spect.option.apply( spect, args );
														break;
													case 'destroy':
														spect.destroy();
														$( this ).removeData( dataID );
														break;
													default:
														method.apply( spect, args );
														break;
												}
											}
										} );

										return returnValue;
									}

									// Initializing a new instance of spectrum
									return this.spectrum( "destroy" ).each( function () {
										var options = $.extend( {}, opts, $( this ).data() ),
											spect = spectrum( this, options );
										$( this ).data( dataID, spect.id );
									} );
								};

								$.fn.spectrum.load = true;
								$.fn.spectrum.loadOpts = {};
								$.fn.spectrum.draggable = draggable;
								$.fn.spectrum.defaults = defaultOpts;

								$.spectrum = {};
								$.spectrum.localization = {};
								$.spectrum.palettes = {};

							})( jQuery );
						},
						"state-manager.js": function (exports, module, require) {
							var state_manager;

							(function ( $ ) {

								/**
								 *
								 * @param {ElementStates} dropdown backbone view
								 * @returns {Object}
								 */
								state_manager = function ( dropdown ) {

									dropdown.on( 'state_change', function ( state ) {
										manager.change( state );
									} );

									dropdown.on( 'done', function () {
										manager.reset();
									} );

									var manager = {
										/* default state */
										default: 'default',
										_parent: null,
										_element: null,
										_state: 'default',

										set_state: function ( state ) {
											if ( ! state ) {
												state = this.default;
											}
											this._state = state;
										},

										get_state: function () {
											return this._state;
										},

										get_pseudo: function () {
											var pseudo = '';

											if ( ! this.is_default() ) {
												pseudo = ':' + this.get_state();
											}

											return pseudo;
										},

										is_default: function () {
											return this.get_state() === this.default;
										},

										css_class: function () {
											var _class = '';
											if ( ! this.is_default() ) {
												_class = 'tve-state-' + this.get_state();
											}

											return _class;
										},

										set_parent: function ( $parent ) {
											this._parent = $parent;
										},

										get_parent: function () {
											return this._parent;
										},

										set_element: function ( $element ) {
											this._element = $element;
											var state = this.get_state();

											/* change each component state */
											$.each( TVE.Elements[TVE._type( $element )].components, function ( component, options ) {
												var comp = TVE.Components[component];
												comp.$el.toggleClass( 'tcb-hidden', state !== 'default' && ! comp.extra_states );
											} );

											TVE.main.$cpanel.toggleClass( 'hide-extra-states', state !== 'default' );
										},

										get_element: function () {
											return this._element;
										},

										is_child: function ( $element ) {
											if ( ! $element ) {
												$element = this.get_element();
											}

											if ( this.get_parent() === null || this.get_element() === null ) {
												return false;
											}

											return this.get_parent().has( $element ) && ! this.get_parent().is( $element );
										},

										change: function ( state ) {
											var $element = TVE.ActiveElement;

											/* if we select an element that has a parent, then we will change the state for that parent */
											if ( this.get_parent() && ! $element.is( this.get_parent() ) ) {
												$element = this.get_parent();
											}

											/* remove the old state class */
											$element.removeClass( this.css_class() );

											/* store the current state */
											this.set_state( state );

											/* save the current element */
											this.set_element( $element );

											if ( this.is_default() ) {
												TVE.prevent_blur = false;
												TVE.Editor_Page.editor.find( '.tve-state-default,.tve-state-hover,.tve-state-active' ).removeClass( 'tve-state-default tve-state-hover tve-state-active' );

												this.set_state();
												this.set_parent( null );

												/* when we switch back to default, we destroy the parent */
												this.set_parent( null );
												TVE.remove_overlay();
												TVE.inner.$body.removeClass( 'tcb-states' );
											} else {
												TVE.prevent_blur = true;
												/* for non-default states add the specific class so it will help us with the preview. */
												$element.addClass( this.css_class() );

												/* on non-default states, the current element is the parent of all of his children */
												this.set_parent( $element );

												/* add background overlay */
												$element.tve_overlay();
												TVE.inner.$body.addClass( 'tcb-states' );
											}

											TVE.main.update_components();
											TVE.main.active_element_navigation();
										},

										reset: function () {
											this.change( 'default' );
										}
									};

									return manager;
								};

							})( jQuery );

							module.exports = state_manager;
						},
						"storage.js": function (exports, module, require) {
							/**
							 * Storage handler when localStorage is not available
							 */
							var FallbackStorage = {
								setItem: function ( key, value ) {
								},
								getItem: function ( key ) {
								},
								removeItem: function ( key ) {
								}
							};

							/**
							 * Main object constructor
							 *
							 * @constructor
							 */
							function TCBStorage() {
								this.api = window.localStorage || FallbackStorage;
								this.listening = false;
								this.listeners = {};
							}

							/**
							 * Persist a value in a key
							 *
							 * @param {String} key
							 * @param {*} value
							 * @returns {TCBStorage}
							 */
							TCBStorage.prototype.set = function ( key, value ) {
								if ( ! key || typeof value === 'undefined' || value === null ) {
									return this;
								}

								if ( typeof value === 'object' ) {
									value = JSON.stringify( value );
								}
								try {
									this.api.setItem( key, value );
								} catch ( e ) {
								}

								return this;
							};

							/**
							 *
							 * @param {String} key
							 * @returns {*|undefined}
							 */
							TCBStorage.prototype.get = function ( key ) {
								if ( ! key ) {
									return undefined;
								}

								var value = this.api.getItem( key );
								if ( ! value ) {
									return value;
								}
								try {
									return JSON.parse( value );
								} catch ( e ) {
									return value;
								}
							};

							/**
							 * Removes an item from storage
							 *
							 * @param {String} key
							 *
							 * @return {TCBStorage} allow chained calls
							 */
							TCBStorage.prototype.unset = function ( key ) {
								if ( ! key ) {
									return this;
								}
								try {
									this.api.removeItem( key );
								} catch ( e ) {

								}

								return this;
							};

							TCBStorage.prototype._listen = function () {

								var self = this,
									change = function ( e ) {
										if ( ! e ) {
											e = window.event;
										}

										var all = self.listeners[e.key];

										if ( all && all.length ) {
											all.forEach( function ( listener ) {
												listener( JSON.parse( e.newValue ), JSON.parse( e.oldValue ) );
											} );
										}
									};

								if ( window.addEventListener ) {
									window.addEventListener( 'storage', change, false );
								} else if ( window.attachEvent ) {
									window.attachEvent( 'onstorage', change );
								} else {
									window.onstorage = change;
								}
							};


							TCBStorage.prototype.on = function ( key, fn ) {
								if ( this.listeners[key] ) {
									this.listeners[key].push( fn );
								} else {
									this.listeners[key] = [fn];
								}

								if ( this.listening === false ) {
									this._listen();
									this.listening = true;
								}
							};

							TCBStorage.prototype.off = function ( key, fn ) {
								var listener = listeners[key];
								if ( listener.length > 1 ) {
									listener.splice( listener.indexOf( fn ), 1 );
								} else {
									listeners[key] = [];
								}
							};

							/**
							 *
							 * @param {String} type
							 * @param {String} component
							 * @param {String} field
							 * @param {Boolean|Number|Object|String} value
							 */
							TCBStorage.prototype.setComponentMeta = function ( type, component, field, value ) {

								var meta = this.get( 'tcb-components' ) || {};

								meta[type] = meta[type] || {};
								meta[type][component] = meta[type][component] || {};
								meta[type][component][field] = value;

								this.set( 'tcb-components', meta );
							};

							/**
							 *
							 * @returns {TCBStorage} a storage instance
							 */
							TCBStorage.instance = function () {
								if ( ! this._instance ) {
									this._instance = new TCBStorage();
								}

								return this._instance;
							};

							module.exports = TCBStorage.instance();
						},
						"tinycolor.js": function (exports, module, require) {
							// TinyColor v1.1.2
							// https://github.com/bgrins/TinyColor
							// Brian Grinstead, MIT License

							(function () {

								var trimLeft = /^[\s,#]+/,
									trimRight = /\s+$/,
									tinyCounter = 0,
									math = Math,
									mathRound = math.round,
									mathMin = math.min,
									mathMax = math.max,
									mathRandom = math.random;

								var tinycolor = function ( color, opts ) {

									color = (color) ? color : '';
									opts = opts || {};

									// If input is already a tinycolor, return itself
									if ( color instanceof tinycolor ) {
										return color;
									}
									// If we are called as a function, call using new instead
									if ( ! (this instanceof tinycolor) ) {
										return new tinycolor( color, opts );
									}

									var rgb = inputToRGB( color );
									this._originalInput = color,
										this._r = rgb.r,
										this._g = rgb.g,
										this._b = rgb.b,
										this._a = rgb.a,
										this._roundA = mathRound( 100 * this._a ) / 100,
										this._format = opts.format || rgb.format;
									this._gradientType = opts.gradientType;

									// Don't let the range of [0,255] come back in [0,1].
									// Potentially lose a little bit of precision here, but will fix issues where
									// .5 gets interpreted as half of the total, instead of half of 1
									// If it was supposed to be 128, this was already taken care of by `inputToRgb`
									if ( this._r < 1 ) {
										this._r = mathRound( this._r );
									}
									if ( this._g < 1 ) {
										this._g = mathRound( this._g );
									}
									if ( this._b < 1 ) {
										this._b = mathRound( this._b );
									}

									this._ok = rgb.ok;
									this._tc_id = tinyCounter ++;
								};

								tinycolor.prototype = {
									isDark: function () {
										return this.getBrightness() < 128;
									},
									isLight: function () {
										return ! this.isDark();
									},
									isValid: function () {
										return this._ok;
									},
									getOriginalInput: function () {
										return this._originalInput;
									},
									getFormat: function () {
										return this._format;
									},
									getAlpha: function () {
										return this._a;
									},
									getBrightness: function () {
										var rgb = this.toRgb();
										return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
									},
									setAlpha: function ( value ) {
										this._a = boundAlpha( value );
										this._roundA = mathRound( 100 * this._a ) / 100;
										return this;
									},
									toHsv: function () {
										var hsv = rgbToHsv( this._r, this._g, this._b );
										return {h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a};
									},
									toHsvString: function () {
										var hsv = rgbToHsv( this._r, this._g, this._b );
										var h = mathRound( hsv.h * 360 ), s = mathRound( hsv.s * 100 ), v = mathRound( hsv.v * 100 );
										return (this._a == 1) ?
											"hsv(" + h + ", " + s + "%, " + v + "%)" :
											"hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
									},
									toHsl: function () {
										var hsl = rgbToHsl( this._r, this._g, this._b );
										return {h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a};
									},
									toHslString: function () {
										var hsl = rgbToHsl( this._r, this._g, this._b );
										var h = mathRound( hsl.h * 360 ), s = mathRound( hsl.s * 100 ), l = mathRound( hsl.l * 100 );
										return (this._a == 1) ?
											"hsl(" + h + ", " + s + "%, " + l + "%)" :
											"hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
									},
									toHex: function ( allow3Char ) {
										return rgbToHex( this._r, this._g, this._b, allow3Char );
									},
									toHexString: function ( allow3Char ) {
										return '#' + this.toHex( allow3Char );
									},
									toHex8: function () {
										return rgbaToHex( this._r, this._g, this._b, this._a );
									},
									toHex8String: function () {
										return '#' + this.toHex8();
									},
									toRgb: function () {
										return {r: mathRound( this._r ), g: mathRound( this._g ), b: mathRound( this._b ), a: this._a};
									},
									toRgbString: function () {
										return (this._a == 1) ?
											"rgb(" + mathRound( this._r ) + ", " + mathRound( this._g ) + ", " + mathRound( this._b ) + ")" :
											"rgba(" + mathRound( this._r ) + ", " + mathRound( this._g ) + ", " + mathRound( this._b ) + ", " + this._roundA + ")";
									},
									toPercentageRgb: function () {
										return {
											r: mathRound( bound01( this._r, 255 ) * 100 ) + "%",
											g: mathRound( bound01( this._g, 255 ) * 100 ) + "%",
											b: mathRound( bound01( this._b, 255 ) * 100 ) + "%",
											a: this._a
										};
									},
									toPercentageRgbString: function () {
										return (this._a == 1) ?
											"rgb(" + mathRound( bound01( this._r, 255 ) * 100 ) + "%, " + mathRound( bound01( this._g, 255 ) * 100 ) + "%, " + mathRound( bound01( this._b, 255 ) * 100 ) + "%)" :
											"rgba(" + mathRound( bound01( this._r, 255 ) * 100 ) + "%, " + mathRound( bound01( this._g, 255 ) * 100 ) + "%, " + mathRound( bound01( this._b, 255 ) * 100 ) + "%, " + this._roundA + ")";
									},
									toName: function () {
										if ( this._a === 0 ) {
											return "transparent";
										}

										if ( this._a < 1 ) {
											return false;
										}

										return hexNames[rgbToHex( this._r, this._g, this._b, true )] || false;
									},
									toFilter: function ( secondColor ) {
										var hex8String = '#' + rgbaToHex( this._r, this._g, this._b, this._a );
										var secondHex8String = hex8String;
										var gradientType = this._gradientType ? "GradientType = 1, " : "";

										if ( secondColor ) {
											var s = tinycolor( secondColor );
											secondHex8String = s.toHex8String();
										}

										return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
									},
									toString: function ( format ) {
										var formatSet = ! ! format;
										format = format || this._format;

										var formattedString = false;
										var hasAlpha = this._a < 1 && this._a >= 0;
										var needsAlphaFormat = ! formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");

										if ( needsAlphaFormat ) {
											// Special case for "transparent", all other non-alpha formats
											// will return rgba when there is transparency.
											if ( format === "name" && this._a === 0 ) {
												return this.toName();
											}
											return this.toRgbString();
										}
										if ( format === "rgb" ) {
											formattedString = this.toRgbString();
										}
										if ( format === "prgb" ) {
											formattedString = this.toPercentageRgbString();
										}
										if ( format === "hex" || format === "hex6" ) {
											formattedString = this.toHexString();
										}
										if ( format === "hex3" ) {
											formattedString = this.toHexString( true );
										}
										if ( format === "hex8" ) {
											formattedString = this.toHex8String();
										}
										if ( format === "name" ) {
											formattedString = this.toName();
										}
										if ( format === "hsl" ) {
											formattedString = this.toHslString();
										}
										if ( format === "hsv" ) {
											formattedString = this.toHsvString();
										}

										return formattedString || this.toHexString();
									},

									_applyModification: function ( fn, args ) {
										var color = fn.apply( null, [this].concat( [].slice.call( args ) ) );
										this._r = color._r;
										this._g = color._g;
										this._b = color._b;
										this.setAlpha( color._a );
										return this;
									},
									lighten: function () {
										return this._applyModification( lighten, arguments );
									},
									brighten: function () {
										return this._applyModification( brighten, arguments );
									},
									darken: function () {
										return this._applyModification( darken, arguments );
									},
									desaturate: function () {
										return this._applyModification( desaturate, arguments );
									},
									saturate: function () {
										return this._applyModification( saturate, arguments );
									},
									greyscale: function () {
										return this._applyModification( greyscale, arguments );
									},
									spin: function () {
										return this._applyModification( spin, arguments );
									},

									_applyCombination: function ( fn, args ) {
										return fn.apply( null, [this].concat( [].slice.call( args ) ) );
									},
									analogous: function () {
										return this._applyCombination( analogous, arguments );
									},
									complement: function () {
										return this._applyCombination( complement, arguments );
									},
									monochromatic: function () {
										return this._applyCombination( monochromatic, arguments );
									},
									splitcomplement: function () {
										return this._applyCombination( splitcomplement, arguments );
									},
									triad: function () {
										return this._applyCombination( triad, arguments );
									},
									tetrad: function () {
										return this._applyCombination( tetrad, arguments );
									}
								};

								// If input is an object, force 1 into "1.0" to handle ratios properly
								// String input requires "1.0" as input, so 1 will be treated as 1
								tinycolor.fromRatio = function ( color, opts ) {
									if ( typeof color == "object" ) {
										var newColor = {};
										for ( var i in color ) {
											if ( color.hasOwnProperty( i ) ) {
												if ( i === "a" ) {
													newColor[i] = color[i];
												}
												else {
													newColor[i] = convertToPercentage( color[i] );
												}
											}
										}
										color = newColor;
									}

									return tinycolor( color, opts );
								};

								// Given a string or object, convert that input to RGB
								// Possible string inputs:
								//
								//     "red"
								//     "#f00" or "f00"
								//     "#ff0000" or "ff0000"
								//     "#ff000000" or "ff000000"
								//     "rgb 255 0 0" or "rgb (255, 0, 0)"
								//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
								//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
								//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
								//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
								//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
								//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
								//
								function inputToRGB( color ) {

									var rgb = {r: 0, g: 0, b: 0};
									var a = 1;
									var ok = false;
									var format = false;

									if ( typeof color == "string" ) {
										color = stringInputToObject( color );
									}

									if ( typeof color == "object" ) {
										if ( color.hasOwnProperty( "r" ) && color.hasOwnProperty( "g" ) && color.hasOwnProperty( "b" ) ) {
											rgb = rgbToRgb( color.r, color.g, color.b );
											ok = true;
											format = String( color.r ).substr( - 1 ) === "%" ? "prgb" : "rgb";
										}
										else if ( color.hasOwnProperty( "h" ) && color.hasOwnProperty( "s" ) && color.hasOwnProperty( "v" ) ) {
											color.s = convertToPercentage( color.s );
											color.v = convertToPercentage( color.v );
											rgb = hsvToRgb( color.h, color.s, color.v );
											ok = true;
											format = "hsv";
										}
										else if ( color.hasOwnProperty( "h" ) && color.hasOwnProperty( "s" ) && color.hasOwnProperty( "l" ) ) {
											color.s = convertToPercentage( color.s );
											color.l = convertToPercentage( color.l );
											rgb = hslToRgb( color.h, color.s, color.l );
											ok = true;
											format = "hsl";
										}

										if ( color.hasOwnProperty( "a" ) ) {
											a = color.a;
										}
									}

									a = boundAlpha( a );

									return {
										ok: ok,
										format: color.format || format,
										r: mathMin( 255, mathMax( rgb.r, 0 ) ),
										g: mathMin( 255, mathMax( rgb.g, 0 ) ),
										b: mathMin( 255, mathMax( rgb.b, 0 ) ),
										a: a
									};
								}


								// Conversion Functions
								// --------------------

								// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
								// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

								// `rgbToRgb`
								// Handle bounds / percentage checking to conform to CSS color spec
								// <http://www.w3.org/TR/css3-color/>
								// *Assumes:* r, g, b in [0, 255] or [0, 1]
								// *Returns:* { r, g, b } in [0, 255]
								function rgbToRgb( r, g, b ) {
									return {
										r: bound01( r, 255 ) * 255,
										g: bound01( g, 255 ) * 255,
										b: bound01( b, 255 ) * 255
									};
								}

								// `rgbToHsl`
								// Converts an RGB color value to HSL.
								// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
								// *Returns:* { h, s, l } in [0,1]
								function rgbToHsl( r, g, b ) {

									r = bound01( r, 255 );
									g = bound01( g, 255 );
									b = bound01( b, 255 );

									var max = mathMax( r, g, b ), min = mathMin( r, g, b );
									var h, s, l = (max + min) / 2;

									if ( max == min ) {
										h = s = 0; // achromatic
									}
									else {
										var d = max - min;
										s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
										switch ( max ) {
											case r:
												h = (g - b) / d + (g < b ? 6 : 0);
												break;
											case g:
												h = (b - r) / d + 2;
												break;
											case b:
												h = (r - g) / d + 4;
												break;
										}

										h /= 6;
									}

									return {h: h, s: s, l: l};
								}

								// `hslToRgb`
								// Converts an HSL color value to RGB.
								// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
								// *Returns:* { r, g, b } in the set [0, 255]
								function hslToRgb( h, s, l ) {
									var r, g, b;

									h = bound01( h, 360 );
									s = bound01( s, 100 );
									l = bound01( l, 100 );

									function hue2rgb( p, q, t ) {
										if ( t < 0 ) {
											t += 1;
										}
										if ( t > 1 ) {
											t -= 1;
										}
										if ( t < 1 / 6 ) {
											return p + (q - p) * 6 * t;
										}
										if ( t < 1 / 2 ) {
											return q;
										}
										if ( t < 2 / 3 ) {
											return p + (q - p) * (2 / 3 - t) * 6;
										}
										return p;
									}

									if ( s === 0 ) {
										r = g = b = l; // achromatic
									}
									else {
										var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
										var p = 2 * l - q;
										r = hue2rgb( p, q, h + 1 / 3 );
										g = hue2rgb( p, q, h );
										b = hue2rgb( p, q, h - 1 / 3 );
									}

									return {r: r * 255, g: g * 255, b: b * 255};
								}

								// `rgbToHsv`
								// Converts an RGB color value to HSV
								// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
								// *Returns:* { h, s, v } in [0,1]
								function rgbToHsv( r, g, b ) {

									r = bound01( r, 255 );
									g = bound01( g, 255 );
									b = bound01( b, 255 );

									var max = mathMax( r, g, b ), min = mathMin( r, g, b );
									var h, s, v = max;

									var d = max - min;
									s = max === 0 ? 0 : d / max;

									if ( max == min ) {
										h = 0; // achromatic
									}
									else {
										switch ( max ) {
											case r:
												h = (g - b) / d + (g < b ? 6 : 0);
												break;
											case g:
												h = (b - r) / d + 2;
												break;
											case b:
												h = (r - g) / d + 4;
												break;
										}
										h /= 6;
									}
									return {h: h, s: s, v: v};
								}

								// `hsvToRgb`
								// Converts an HSV color value to RGB.
								// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
								// *Returns:* { r, g, b } in the set [0, 255]
								function hsvToRgb( h, s, v ) {

									h = bound01( h, 360 ) * 6;
									s = bound01( s, 100 );
									v = bound01( v, 100 );

									var i = math.floor( h ),
										f = h - i,
										p = v * (1 - s),
										q = v * (1 - f * s),
										t = v * (1 - (1 - f) * s),
										mod = i % 6,
										r = [v, q, p, p, t, v][mod],
										g = [t, v, v, q, p, p][mod],
										b = [p, p, t, v, v, q][mod];

									return {r: r * 255, g: g * 255, b: b * 255};
								}

								// `rgbToHex`
								// Converts an RGB color to hex
								// Assumes r, g, and b are contained in the set [0, 255]
								// Returns a 3 or 6 character hex
								function rgbToHex( r, g, b, allow3Char ) {

									var hex = [
										pad2( mathRound( r ).toString( 16 ) ),
										pad2( mathRound( g ).toString( 16 ) ),
										pad2( mathRound( b ).toString( 16 ) )
									];

									// Return a 3 character hex if possible
									if ( allow3Char && hex[0].charAt( 0 ) == hex[0].charAt( 1 ) && hex[1].charAt( 0 ) == hex[1].charAt( 1 ) && hex[2].charAt( 0 ) == hex[2].charAt( 1 ) ) {
										return hex[0].charAt( 0 ) + hex[1].charAt( 0 ) + hex[2].charAt( 0 );
									}

									return hex.join( "" );
								}

								// `rgbaToHex`
								// Converts an RGBA color plus alpha transparency to hex
								// Assumes r, g, b and a are contained in the set [0, 255]
								// Returns an 8 character hex
								function rgbaToHex( r, g, b, a ) {

									var hex = [
										pad2( convertDecimalToHex( a ) ),
										pad2( mathRound( r ).toString( 16 ) ),
										pad2( mathRound( g ).toString( 16 ) ),
										pad2( mathRound( b ).toString( 16 ) )
									];

									return hex.join( "" );
								}

								// `equals`
								// Can be called with any tinycolor input
								tinycolor.equals = function ( color1, color2 ) {
									if ( ! color1 || ! color2 ) {
										return false;
									}
									return tinycolor( color1 ).toRgbString() == tinycolor( color2 ).toRgbString();
								};
								tinycolor.random = function () {
									return tinycolor.fromRatio( {
										r: mathRandom(),
										g: mathRandom(),
										b: mathRandom()
									} );
								};


								// Modification Functions
								// ----------------------
								// Thanks to less.js for some of the basics here
								// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

								function desaturate( color, amount ) {
									amount = (amount === 0) ? 0 : (amount || 10);
									var hsl = tinycolor( color ).toHsl();
									hsl.s -= amount / 100;
									hsl.s = clamp01( hsl.s );
									return tinycolor( hsl );
								}

								function saturate( color, amount ) {
									amount = (amount === 0) ? 0 : (amount || 10);
									var hsl = tinycolor( color ).toHsl();
									hsl.s += amount / 100;
									hsl.s = clamp01( hsl.s );
									return tinycolor( hsl );
								}

								function greyscale( color ) {
									return tinycolor( color ).desaturate( 100 );
								}

								function lighten( color, amount ) {
									amount = (amount === 0) ? 0 : (amount || 10);
									var hsl = tinycolor( color ).toHsl();
									hsl.l += amount / 100;
									hsl.l = clamp01( hsl.l );
									return tinycolor( hsl );
								}

								function brighten( color, amount ) {
									amount = (amount === 0) ? 0 : (amount || 10);
									var rgb = tinycolor( color ).toRgb();
									rgb.r = mathMax( 0, mathMin( 255, rgb.r - mathRound( 255 * - (amount / 100) ) ) );
									rgb.g = mathMax( 0, mathMin( 255, rgb.g - mathRound( 255 * - (amount / 100) ) ) );
									rgb.b = mathMax( 0, mathMin( 255, rgb.b - mathRound( 255 * - (amount / 100) ) ) );
									return tinycolor( rgb );
								}

								function darken( color, amount ) {
									amount = (amount === 0) ? 0 : (amount || 10);
									var hsl = tinycolor( color ).toHsl();
									hsl.l -= amount / 100;
									hsl.l = clamp01( hsl.l );
									return tinycolor( hsl );
								}

								// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
								// Values outside of this range will be wrapped into this range.
								function spin( color, amount ) {
									var hsl = tinycolor( color ).toHsl();
									var hue = (mathRound( hsl.h ) + amount) % 360;
									hsl.h = hue < 0 ? 360 + hue : hue;
									return tinycolor( hsl );
								}

								// Combination Functions
								// ---------------------
								// Thanks to jQuery xColor for some of the ideas behind these
								// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

								function complement( color ) {
									var hsl = tinycolor( color ).toHsl();
									hsl.h = (hsl.h + 180) % 360;
									return tinycolor( hsl );
								}

								function triad( color ) {
									var hsl = tinycolor( color ).toHsl();
									var h = hsl.h;
									return [
										tinycolor( color ),
										tinycolor( {h: (h + 120) % 360, s: hsl.s, l: hsl.l} ),
										tinycolor( {h: (h + 240) % 360, s: hsl.s, l: hsl.l} )
									];
								}

								function tetrad( color ) {
									var hsl = tinycolor( color ).toHsl();
									var h = hsl.h;
									return [
										tinycolor( color ),
										tinycolor( {h: (h + 90) % 360, s: hsl.s, l: hsl.l} ),
										tinycolor( {h: (h + 180) % 360, s: hsl.s, l: hsl.l} ),
										tinycolor( {h: (h + 270) % 360, s: hsl.s, l: hsl.l} )
									];
								}

								function splitcomplement( color ) {
									var hsl = tinycolor( color ).toHsl();
									var h = hsl.h;
									return [
										tinycolor( color ),
										tinycolor( {h: (h + 72) % 360, s: hsl.s, l: hsl.l} ),
										tinycolor( {h: (h + 216) % 360, s: hsl.s, l: hsl.l} )
									];
								}

								function analogous( color, results, slices ) {
									results = results || 6;
									slices = slices || 30;

									var hsl = tinycolor( color ).toHsl();
									var part = 360 / slices;
									var ret = [tinycolor( color )];

									for ( hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; -- results; ) {
										hsl.h = (hsl.h + part) % 360;
										ret.push( tinycolor( hsl ) );
									}
									return ret;
								}

								function monochromatic( color, results ) {
									results = results || 6;
									var hsv = tinycolor( color ).toHsv();
									var h = hsv.h, s = hsv.s, v = hsv.v;
									var ret = [];
									var modification = 1 / results;

									while ( results -- ) {
										ret.push( tinycolor( {h: h, s: s, v: v} ) );
										v = (v + modification) % 1;
									}

									return ret;
								}

								// Utility Functions
								// ---------------------

								tinycolor.mix = function ( color1, color2, amount ) {
									amount = (amount === 0) ? 0 : (amount || 50);

									var rgb1 = tinycolor( color1 ).toRgb();
									var rgb2 = tinycolor( color2 ).toRgb();

									var p = amount / 100;
									var w = p * 2 - 1;
									var a = rgb2.a - rgb1.a;

									var w1;

									if ( w * a == - 1 ) {
										w1 = w;
									} else {
										w1 = (w + a) / (1 + w * a);
									}

									w1 = (w1 + 1) / 2;

									var w2 = 1 - w1;

									var rgba = {
										r: rgb2.r * w1 + rgb1.r * w2,
										g: rgb2.g * w1 + rgb1.g * w2,
										b: rgb2.b * w1 + rgb1.b * w2,
										a: rgb2.a * p + rgb1.a * (1 - p)
									};

									return tinycolor( rgba );
								};


								// Readability Functions
								// ---------------------
								// <http://www.w3.org/TR/AERT#color-contrast>

								// `readability`
								// Analyze the 2 colors and returns an object with the following properties:
								//    `brightness`: difference in brightness between the two colors
								//    `color`: difference in color/hue between the two colors
								tinycolor.readability = function ( color1, color2 ) {
									var c1 = tinycolor( color1 );
									var c2 = tinycolor( color2 );
									var rgb1 = c1.toRgb();
									var rgb2 = c2.toRgb();
									var brightnessA = c1.getBrightness();
									var brightnessB = c2.getBrightness();
									var colorDiff = (
										Math.max( rgb1.r, rgb2.r ) - Math.min( rgb1.r, rgb2.r ) +
										Math.max( rgb1.g, rgb2.g ) - Math.min( rgb1.g, rgb2.g ) +
										Math.max( rgb1.b, rgb2.b ) - Math.min( rgb1.b, rgb2.b )
									);

									return {
										brightness: Math.abs( brightnessA - brightnessB ),
										color: colorDiff
									};
								};

								// `readable`
								// http://www.w3.org/TR/AERT#color-contrast
								// Ensure that foreground and background color combinations provide sufficient contrast.
								// *Example*
								//    tinycolor.isReadable("#000", "#111") => false
								tinycolor.isReadable = function ( color1, color2 ) {
									var readability = tinycolor.readability( color1, color2 );
									return readability.brightness > 125 && readability.color > 500;
								};

								// `mostReadable`
								// Given a base color and a list of possible foreground or background
								// colors for that base, returns the most readable color.
								// *Example*
								//    tinycolor.mostReadable("#123", ["#fff", "#000"]) => "#000"
								tinycolor.mostReadable = function ( baseColor, colorList ) {
									var bestColor = null;
									var bestScore = 0;
									var bestIsReadable = false;
									for ( var i = 0; i < colorList.length; i ++ ) {

										// We normalize both around the "acceptable" breaking point,
										// but rank brightness constrast higher than hue.

										var readability = tinycolor.readability( baseColor, colorList[i] );
										var readable = readability.brightness > 125 && readability.color > 500;
										var score = 3 * (readability.brightness / 125) + (readability.color / 500);

										if ( (readable && ! bestIsReadable) ||
										     (readable && bestIsReadable && score > bestScore) ||
										     ((! readable) && (! bestIsReadable) && score > bestScore) ) {
											bestIsReadable = readable;
											bestScore = score;
											bestColor = tinycolor( colorList[i] );
										}
									}
									return bestColor;
								};


								// Big List of Colors
								// ------------------
								// <http://www.w3.org/TR/css3-color/#svg-color>
								var names = tinycolor.names = {
									aliceblue: "f0f8ff",
									antiquewhite: "faebd7",
									aqua: "0ff",
									aquamarine: "7fffd4",
									azure: "f0ffff",
									beige: "f5f5dc",
									bisque: "ffe4c4",
									black: "000",
									blanchedalmond: "ffebcd",
									blue: "00f",
									blueviolet: "8a2be2",
									brown: "a52a2a",
									burlywood: "deb887",
									burntsienna: "ea7e5d",
									cadetblue: "5f9ea0",
									chartreuse: "7fff00",
									chocolate: "d2691e",
									coral: "ff7f50",
									cornflowerblue: "6495ed",
									cornsilk: "fff8dc",
									crimson: "dc143c",
									cyan: "0ff",
									darkblue: "00008b",
									darkcyan: "008b8b",
									darkgoldenrod: "b8860b",
									darkgray: "a9a9a9",
									darkgreen: "006400",
									darkgrey: "a9a9a9",
									darkkhaki: "bdb76b",
									darkmagenta: "8b008b",
									darkolivegreen: "556b2f",
									darkorange: "ff8c00",
									darkorchid: "9932cc",
									darkred: "8b0000",
									darksalmon: "e9967a",
									darkseagreen: "8fbc8f",
									darkslateblue: "483d8b",
									darkslategray: "2f4f4f",
									darkslategrey: "2f4f4f",
									darkturquoise: "00ced1",
									darkviolet: "9400d3",
									deeppink: "ff1493",
									deepskyblue: "00bfff",
									dimgray: "696969",
									dimgrey: "696969",
									dodgerblue: "1e90ff",
									firebrick: "b22222",
									floralwhite: "fffaf0",
									forestgreen: "228b22",
									fuchsia: "f0f",
									gainsboro: "dcdcdc",
									ghostwhite: "f8f8ff",
									gold: "ffd700",
									goldenrod: "daa520",
									gray: "808080",
									green: "008000",
									greenyellow: "adff2f",
									grey: "808080",
									honeydew: "f0fff0",
									hotpink: "ff69b4",
									indianred: "cd5c5c",
									indigo: "4b0082",
									ivory: "fffff0",
									khaki: "f0e68c",
									lavender: "e6e6fa",
									lavenderblush: "fff0f5",
									lawngreen: "7cfc00",
									lemonchiffon: "fffacd",
									lightblue: "add8e6",
									lightcoral: "f08080",
									lightcyan: "e0ffff",
									lightgoldenrodyellow: "fafad2",
									lightgray: "d3d3d3",
									lightgreen: "90ee90",
									lightgrey: "d3d3d3",
									lightpink: "ffb6c1",
									lightsalmon: "ffa07a",
									lightseagreen: "20b2aa",
									lightskyblue: "87cefa",
									lightslategray: "789",
									lightslategrey: "789",
									lightsteelblue: "b0c4de",
									lightyellow: "ffffe0",
									lime: "0f0",
									limegreen: "32cd32",
									linen: "faf0e6",
									magenta: "f0f",
									maroon: "800000",
									mediumaquamarine: "66cdaa",
									mediumblue: "0000cd",
									mediumorchid: "ba55d3",
									mediumpurple: "9370db",
									mediumseagreen: "3cb371",
									mediumslateblue: "7b68ee",
									mediumspringgreen: "00fa9a",
									mediumturquoise: "48d1cc",
									mediumvioletred: "c71585",
									midnightblue: "191970",
									mintcream: "f5fffa",
									mistyrose: "ffe4e1",
									moccasin: "ffe4b5",
									navajowhite: "ffdead",
									navy: "000080",
									oldlace: "fdf5e6",
									olive: "808000",
									olivedrab: "6b8e23",
									orange: "ffa500",
									orangered: "ff4500",
									orchid: "da70d6",
									palegoldenrod: "eee8aa",
									palegreen: "98fb98",
									paleturquoise: "afeeee",
									palevioletred: "db7093",
									papayawhip: "ffefd5",
									peachpuff: "ffdab9",
									peru: "cd853f",
									pink: "ffc0cb",
									plum: "dda0dd",
									powderblue: "b0e0e6",
									purple: "800080",
									rebeccapurple: "663399",
									red: "f00",
									rosybrown: "bc8f8f",
									royalblue: "4169e1",
									saddlebrown: "8b4513",
									salmon: "fa8072",
									sandybrown: "f4a460",
									seagreen: "2e8b57",
									seashell: "fff5ee",
									sienna: "a0522d",
									silver: "c0c0c0",
									skyblue: "87ceeb",
									slateblue: "6a5acd",
									slategray: "708090",
									slategrey: "708090",
									snow: "fffafa",
									springgreen: "00ff7f",
									steelblue: "4682b4",
									tan: "d2b48c",
									teal: "008080",
									thistle: "d8bfd8",
									tomato: "ff6347",
									turquoise: "40e0d0",
									violet: "ee82ee",
									wheat: "f5deb3",
									white: "fff",
									whitesmoke: "f5f5f5",
									yellow: "ff0",
									yellowgreen: "9acd32"
								};

								// Make it easy to access colors via `hexNames[hex]`
								var hexNames = tinycolor.hexNames = flip( names );


								// Utilities
								// ---------

								// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
								function flip( o ) {
									var flipped = {};
									for ( var i in o ) {
										if ( o.hasOwnProperty( i ) ) {
											flipped[o[i]] = i;
										}
									}
									return flipped;
								}

								// Return a valid alpha value [0,1] with all invalid values being set to 1
								function boundAlpha( a ) {
									a = parseFloat( a );

									if ( isNaN( a ) || a < 0 || a > 1 ) {
										a = 1;
									}

									return a;
								}

								// Take input from [0, n] and return it as [0, 1]
								function bound01( n, max ) {
									if ( isOnePointZero( n ) ) {
										n = "100%";
									}

									var processPercent = isPercentage( n );
									n = mathMin( max, mathMax( 0, parseFloat( n ) ) );

									// Automatically convert percentage into number
									if ( processPercent ) {
										n = parseInt( n * max, 10 ) / 100;
									}

									// Handle floating point rounding errors
									if ( (math.abs( n - max ) < 0.000001) ) {
										return 1;
									}

									// Convert into [0, 1] range if it isn't already
									return (n % max) / parseFloat( max );
								}

								// Force a number between 0 and 1
								function clamp01( val ) {
									return mathMin( 1, mathMax( 0, val ) );
								}

								// Parse a base-16 hex value into a base-10 integer
								function parseIntFromHex( val ) {
									return parseInt( val, 16 );
								}

								// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
								// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
								function isOnePointZero( n ) {
									return typeof n == "string" && n.indexOf( '.' ) != - 1 && parseFloat( n ) === 1;
								}

								// Check to see if string passed in is a percentage
								function isPercentage( n ) {
									return typeof n === "string" && n.indexOf( '%' ) != - 1;
								}

								// Force a hex value to have 2 characters
								function pad2( c ) {
									return c.length == 1 ? '0' + c : '' + c;
								}

								// Replace a decimal with it's percentage value
								function convertToPercentage( n ) {
									if ( n <= 1 ) {
										n = (n * 100) + "%";
									}

									return n;
								}

								// Converts a decimal to a hex value
								function convertDecimalToHex( d ) {
									return Math.round( parseFloat( d ) * 255 ).toString( 16 );
								}

								// Converts a hex value to a decimal
								function convertHexToDecimal( h ) {
									return (parseIntFromHex( h ) / 255);
								}

								var matchers = (function () {

									// <http://www.w3.org/TR/css3-values/#integers>
									var CSS_INTEGER = "[-\\+]?\\d+%?";

									// <http://www.w3.org/TR/css3-values/#number-value>
									var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

									// Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
									var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

									// Actual matching.
									// Parentheses and commas are optional, but not required.
									// Whitespace can take the place of commas or opening paren
									var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
									var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

									return {
										rgb: new RegExp( "rgb" + PERMISSIVE_MATCH3 ),
										rgba: new RegExp( "rgba" + PERMISSIVE_MATCH4 ),
										hsl: new RegExp( "hsl" + PERMISSIVE_MATCH3 ),
										hsla: new RegExp( "hsla" + PERMISSIVE_MATCH4 ),
										hsv: new RegExp( "hsv" + PERMISSIVE_MATCH3 ),
										hsva: new RegExp( "hsva" + PERMISSIVE_MATCH4 ),
										hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
										hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
										hex8: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
									};
								})();

								// `stringInputToObject`
								// Permissive string parsing.  Take in a number of formats, and output an object
								// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
								function stringInputToObject( color ) {

									color = color.replace( trimLeft, '' ).replace( trimRight, '' ).toLowerCase();
									var named = false;
									if ( names[color] ) {
										color = names[color];
										named = true;
									}
									else if ( color == 'transparent' ) {
										return {r: 0, g: 0, b: 0, a: 0, format: "name"};
									}

									// Try to match string input using regular expressions.
									// Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
									// Just return an object and let the conversion functions handle that.
									// This way the result will be the same whether the tinycolor is initialized with string or object.
									var match;
									if ( (match = matchers.rgb.exec( color )) ) {
										return {r: match[1], g: match[2], b: match[3]};
									}
									if ( (match = matchers.rgba.exec( color )) ) {
										return {r: match[1], g: match[2], b: match[3], a: match[4]};
									}
									if ( (match = matchers.hsl.exec( color )) ) {
										return {h: match[1], s: match[2], l: match[3]};
									}
									if ( (match = matchers.hsla.exec( color )) ) {
										return {h: match[1], s: match[2], l: match[3], a: match[4]};
									}
									if ( (match = matchers.hsv.exec( color )) ) {
										return {h: match[1], s: match[2], v: match[3]};
									}
									if ( (match = matchers.hsva.exec( color )) ) {
										return {h: match[1], s: match[2], v: match[3], a: match[4]};
									}
									if ( (match = matchers.hex8.exec( color )) ) {
										return {
											a: convertHexToDecimal( match[1] ),
											r: parseIntFromHex( match[2] ),
											g: parseIntFromHex( match[3] ),
											b: parseIntFromHex( match[4] ),
											format: named ? "name" : "hex8"
										};
									}
									if ( (match = matchers.hex6.exec( color )) ) {
										return {
											r: parseIntFromHex( match[1] ),
											g: parseIntFromHex( match[2] ),
											b: parseIntFromHex( match[3] ),
											format: named ? "name" : "hex"
										};
									}
									if ( (match = matchers.hex3.exec( color )) ) {
										return {
											r: parseIntFromHex( match[1] + '' + match[1] ),
											g: parseIntFromHex( match[2] + '' + match[2] ),
											b: parseIntFromHex( match[3] + '' + match[3] ),
											format: named ? "name" : "hex"
										};
									}

									return false;
								}

								module.exports = tinycolor;
							})();
						},
						"undo-manager.js": function (exports, module, require) {
							/*
							 LICENSE

							 The MIT License

							 Copyright (c) 2010-2013 Arthur Clemens, arthur@visiblearea.com

							 Permission is hereby granted, free of charge, to any person obtaining a copy
							 of this software and associated documentation files (the "Software"), to deal
							 in the Software without restriction, including without limitation the rights
							 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
							 copies of the Software, and to permit persons to whom the Software is
							 furnished to do so, subject to the following conditions:

							 The above copyright notice and this permission notice shall be included in
							 all copies or substantial portions of the Software.

							 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
							 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
							 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
							 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
							 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
							 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
							 THE SOFTWARE.

							 MODIFICATIONS TO THE SCRIPT:
							 (Radu) : 2014-04-29: Added max_queue_length as argument to the constructor
							 (Radu) : 2015-4-20: Added undo and redo buttons to this code
							 */

							module.exports = function ( max_queue_size, $undo, $redo ) {
								"use strict";
								var undoCommands = [],
									index = - 1,
									isExecuting = false,
									callback,
									_maxLength = typeof max_queue_size !== 'undefined' ? parseInt( max_queue_size ) : 10;

								function execute( command, action ) {
									if ( ! command ) {
										return this;
									}
									isExecuting = true;

									TVE.main.trigger( 'before_undo_redo', {action: action} );
									command[action]();

									TVE.main.trigger( 'after_undo_redo', {action: action} );

									isExecuting = false;
									return this;
								}

								return {

									// legacy support

									register: function ( undoObj, undoFunc, undoParamsList, undoMsg, redoObj, redoFunc, redoParamsList, redoMsg ) {
										this.add( {
											undo: function () {
												undoFunc.apply( undoObj, undoParamsList );
											},
											redo: function () {
												redoFunc.apply( redoObj, redoParamsList );
											}
										} );
									},

									add: function ( command ) {
										if ( isExecuting ) {
											return this;
										}
										// if we are here after having called undo,
										// invalidate items higher on the stack
										undoCommands.splice( index + 1, undoCommands.length - index );

										if ( undoCommands.length > _maxLength - 1 ) { //make sure we do not exceed the maximum undo steps
											undoCommands.splice( 0, 1 );
										}

										undoCommands.push( command );

										// set the current index to the end
										index = undoCommands.length - 1;
										if ( callback ) {
											callback( undoCommands );
										}
										$undo.removeClass( 'tve-disabled' );
										$redo.addClass( 'tve-disabled' );

										return this;
									},

									/*
									 Pass a function to be called on undo and redo actions.
									 */
									setCallback: function ( callbackFunc ) {
										callback = callbackFunc;
									},

									undo: function () {
										var command = undoCommands[index],
											evt = {
												redo: 'removeClass'
											};
										if ( ! command ) {
											return this;
										}
										index -= 1;
										$redo.removeClass( 'tve-disabled' );
										if ( index === - 1 ) {
											$undo.addClass( 'tve-disabled' );
											evt.undo = 'addClass';
										}
										execute( command, "undo" );

										if ( callback ) {
											callback( undoCommands );
										}
										return this;
									},

									redo: function () {
										var command = undoCommands[index + 1],
											evt = {
												undo: 'removeClass'
											};
										if ( ! command ) {
											return this;
										}
										index += 1;

										$undo.removeClass( 'tve-disabled' );
										if ( index >= undoCommands.length - 1 ) {
											$redo.addClass( 'tve-disabled' );
											evt.redo = 'addClass';
										}

										execute( command, "redo" );

										if ( callback ) {
											callback( undoCommands );
										}
										return this;
									},

									/*
									 Clears the memory, losing all stored states.
									 */
									clear: function () {
										var prev_size = undoCommands.length;

										undoCommands = [];
										index = - 1;
										$undo.addClass( 'tve-disabled' );
										$redo.addClass( 'tve-disabled' );
										TCB_Main.trigger( 'undoredochange', {
											undo: 'addClass',
											redo: 'addClass'
										} );

										if ( callback && ( prev_size > 0 ) ) {
											callback( undoCommands );
										}
									},

									hasUndo: function () {
										return index !== - 1;
									},

									hasRedo: function () {
										return index < (undoCommands.length - 1);
									},

									getCommands: function () {
										return undoCommands;
									},

									temp: {
										/**
										 * Save css styles for a specific element so it can be used later.
										 * @param $element element to read from
										 * @param {Object|Array} styles style to be read
										 */
										set: function ( $element, styles ) {

											if ( ! $element || ! styles ) {
												return;
											}

											this._temp_state = styles;
										},
										get: function () {
											return this._temp_state ? this._temp_state : false;
										},
										delete: function () {
											this._temp_state && delete this._temp_state;
										}
									}
								};
							};
						},
						"watcher.js": function (exports, module, require) {
							/**
							 * Watch object properties and apply callbacks on change
							 */
							/**
							 *
							 * @param {Object} object object being watched
							 * @param {String|Array} prop property
							 * @param {Function} callback applied on change
							 * @param {Object} scope scope in which to apply the callback
							 */
							var watch = function ( object, prop, callback, scope ) {
								if ( ! Object.defineProperty ) {
									return object;
								}
								if ( ! ( prop instanceof Array ) ) {
									prop = [prop];
								}

								var self = this;

								_.each( prop, function ( property ) {
									var __v;
									if ( object.hasOwnProperty( property ) ) {
										return;
									}

									Object.defineProperty( object, property, {
										enumerable: true,
										get: function () {
											return __v;
										},
										set: function ( value ) {
											if ( ! self.skip_once && value !== __v ) {
												var prev = __v;
												__v = value;
												callback.apply( scope || null, [property, value, prev] )
											}
											delete self.skip_once;
										}
									} );
								} );
							};

							watch.skip_one = function () {
								this.skip_once = true;
								return this;
							};

							module.exports = watch;
						}
					},
					"models": {
						"api.js": function (exports, module, require) {
							(function ( $ ) {

								module.exports = function ( params ) {

									var self = {
										key: '',
										name: '',
										config: {},
										lists: {},
										custom_fields: [],
										state: 0
									};

									self.get = function ( field ) {
										return self[field];
									};

									self.set = function ( key, value ) {
										self[key] = value;
									};

									self.getConfig = function ( field ) {
										return self.config[field];
									};

									self.setConfig = function ( config ) {
										$.extend( true, self.config, config );
									};

									self.ready = function () {
										return self.state !== 'undefined' && parseInt( self.state ) === 1;
									};

									self.logo = function () {
										return TVE.CONST.dash_url + '/inc/auto-responder/views/images/' + self.key + '.png';
									};

									self.getApi = function ( force, callback ) {

										/* trigger so other can hook in and add extra ajax parameters */
										$( TVE.main ).trigger( 'tve-api-before-ajax-' + self.key, {api: self} );

										TVE.ajax( 'get_api', 'GET', {
											extra: self.ajax_extra || {},
											api: self.key,
											force: force ? 1 : 0
										} ).done( function ( response ) {

											self.lists = self._normalize( response.lists, ['id', 'name'] );

											self.custom_fields = self._normalize( response.custom_fields, ['id', 'placeholder'] );

											self.extra_settings = typeof response.extra_settings === 'undefined' ? [] : response.extra_settings;

											/* initialize the api before rendering the edit card. do whatever you want, but do it responsibly */
											$( TVE.main ).trigger( 'tve-api-after-get-' + self.key, {api: self, response: response} );

											if ( typeof callback === 'function' ) {
												callback.call( self );
											}
										} )
									};

									self.setFieldProp = function ( field, prop, value ) {
										if ( typeof self.form_fields[field] === 'undefined' ) {
											return self;
										}

										self.form_fields[field][prop] = value;
									};

									/**
									 * Return a new object containing only the specified keys from the object
									 * @param obj
									 * @param keys
									 * @returns {Array}
									 * @private
									 */
									self._normalize = function ( obj, keys ) {
										var _new = [];

										if ( typeof obj !== 'undefined' ) {
											_.each( obj, function ( v ) {
												var _props = {};

												_.each( keys, function ( key ) {
													if ( typeof v[key] !== 'undefined' ) {
														_props[key] = v[key];
													}
												} );

												_new.push( _props );
											} );
										}

										return _new;
									};

									/**
									 * Validate if api is ready to be connected.
									 * @returns void
									 */
									self.validate = function () {
										var message = '', valid = 1;

										if ( ! this.getConfig( 'list' ) ) {
											message = 'No list selected';
											valid = 0;
										}

										this.set( 'state', valid );
										this.set( 'error', message );

										/* trigger validation event for the current api. this way apis can hook and check if all settings are right */
										$( TVE.main ).trigger( 'tve-api-validate-' + this.get( 'key' ), {api: this} );
									};

									_.each( params, function ( v, k ) {
										self[k] = v;
									} );

									return self;
								}

							})( jQuery );
						},
						"base.js": function (exports, module, require) {
							(function ( $ ) {
								module.exports = Backbone.Model.extend( {
									/**
									 * Saves the current state (attributes) of this model in an internal field
									 * Useful for restoring the attributes to their original values after some modifications
									 *
									 * @return {Backbone.Model}
									 */
									saveState: function () {
										this.__saved_state = {};
										$.extend( true, this.__saved_state, this.attributes );

										return this;
									},
									/**
									 * Restores a previously saved state
									 *
									 * @param {Boolean} [silent] whether or not to trigger the 'change' event. Defaults to false
									 */
									restoreState: function ( silent ) {
										if ( ! this.__saved_state ) {
											return this;
										}
										this.set( this.__saved_state, {silent: typeof silent === 'undefined' ? false : silent} );
									}
								} );
							})( jQuery );
						},
						"extended_apis.js": function (exports, module, require) {
							(function ( $ ) {

								module.exports = {
									drip: function ( $container ) {
										if ( typeof $container === 'undefined' ) {
											$container = $( '.connection-setup:last' );
										}

										/* save drip options/config */
										$( TVE.main ).on( 'tve-api-options-drip.tcb', function ( event, params ) {
											var config = TVE.get_inputs_value( params.$container, '.tve-api-extra', ':not(.tve_disabled, .drip-custom-field)' );

											params.api.set( 'config', {} );

											params.api.setConfig( config );
										} );

										/* parse drip fields before render */
										$( TVE.main ).on( 'tve-api-after-get-drip.tcb', function ( event, params ) {
											var custom_properties = {};

											/**/
											_.each( params.api.get( 'config' ), function ( value, key ) {
												var match = /field\[(\w*)\]/.exec( key );

												if ( match && match.length > 1 ) {
													custom_properties[match[1]] = value;
												}
											} );

											params.api.set( 'custom_properties', custom_properties );

										} );

										/* validate drip fields and make sure the fields are correct */
										$( TVE.main ).on( 'tve-api-validate-drip.tcb', function ( event, params ) {

											var valid = 1, message = '';

											if ( params.api.getConfig( 'type' ) === 'automation' ) {
												var config = params.api.get( 'config' );

												_.each( config, function ( value, key ) {
													if ( key.indexOf( 'field' ) === 0 ) {
														if ( value.trim().length === 0 ) {
															valid = 0;
															message = 'Please fill all custom fields values!';
														}
													} else if ( value === 'field[thrive_custom_field]' ) {
														valid = 0;
														message = 'Empty custom field name!';
													}
												} )
											}

											params.api.set( 'state', valid );
											params.api.set( 'error', message );
										} );

										/* drip-connection-type */
										$( document ).on( 'change', '.drip-connection-type', function () {
											$container.find( '.tve-api-option-group' ).hide().find( '.tve-api-extra' ).removeClass( 'tve-api-extra' );
											$container.find( '.tve-api-option-group-' + this.value ).show().find( 'input, select' ).addClass( 'tve-api-extra' );
										} );

										$( document ).on( 'change', '.index-custom-field', function ( event ) {
											var patt = /^[A-Za-z0-9-_]+$/,
												$input = $( event.currentTarget ),
												val = event.currentTarget.value,
												$container = $input.closest( '.tve-field-pair' );

											if ( ! patt.test( val ) ) {
												$input.val( $container.find( '.drip-custom-field-value' ).attr( 'name' ).replace( 'field[', '' ).replace( ']', '' ) );
												alert( 'No spaces, commas, dots, or special characters are allowed' );
												return;
											}
											// change the name of the field to fit the parent field value
											$container.find( '.drip-custom-field-value' ).attr( 'name', 'field[' + val + ']' );
										} );

										/* Adds a new field or set of fields for custom inputs */
										$( document ).on( 'click', '.tve-add-new-field', function () {
											var $elem = $container.find( '.tve-field-pair' ).last(),
												$clone = $elem.clone();

											$clone.find( 'input' ).val( '' );

											$clone.find( '.tve-remove-action' ).show();
											$clone.appendTo( $container.find( '.tve-custom-fields-container' ) );
										} );

										/* Removes a field or a set of fields for custom inputs */
										$( document ).on( 'click', '.tve-remove-added-field', function ( event ) {
											$( event.currentTarget ).closest( '.tve-field-pair' ).remove();
										} );
									},
									activecampaign: function ( $container, api ) {

										/* active campaign save extra fields */
										$( TVE.main ).on( 'tve-api-options-activecampaign.tcb', function ( event, params ) {
											params.api.setConfig( TVE.get_inputs_value( params.$container, '.tve-api-extra' ) );
										} );

										/* trigger change of the list select so we can init the api */
										$( TVE.main ).on( 'tve-api-after-render-activecampaign.tcb', function ( event, params ) {
											params.$container.find( '.tve-active-campaign-list' ).trigger( 'change' );
										} );

										$( document ).on( 'change', '.tve-active-campaign-list', function () {
											var $select = $container.find( '.activecampaign-list-form' ).empty(),
												list = this.value,
												forms = api.get( 'extra_settings' ).forms,
												$error = $container.find( '.ac-error' ),
												selected = api.getConfig( 'form' ) || '';

											if ( forms && forms[list] ) {
												_.each( forms[list], function ( form ) {
													$select.append( $( '<option>', {
														value: form.id,
														text: form.name
													} ) )
												} );

												$select.val( selected );
												$error.hide();
											} else {
												$select.hide();
												$error.show();
											}
										} );

									},
									aweber: function () {
										$( TVE.main ).on( 'tve-api-options-aweber.tcb', function ( event, params ) {
											params.api.setConfig( TVE.get_inputs_value( params.$container, '.tve-api-extra' ) );
										} );
									},
									'get-response': function () {
										$( TVE.main ).on( 'tve-api-options-get-response.tcb', function ( event, params ) {
											params.api.setConfig( TVE.get_inputs_value( params.$container, '.tve-api-extra' ) );
										} );

										$( document ).on( 'change', '#get-response-cycleday', function ( event ) {
											var input = event.currentTarget,
												max = parseInt( input.getAttribute( 'max' ) );

											if ( isNaN( input.value ) || input.value < 0 || input.value > max ) {
												alert( 'Invalid cycle day' );
												input.value = 0;
											}
										} );

									},
									klicktipp: function () {
										$( TVE.main ).on( 'tve-api-options-klicktipp.tcb', function ( event, params ) {
											params.api.setConfig( TVE.get_inputs_value( params.$container, '.tve-api-extra' ) );
										} );
									},
									mailchimp: function ( $container, api ) {
										/* save mailchimp extra fields  */
										$( TVE.main ).on( 'tve-api-options-mailchimp.tcb', function ( event, params ) {
											params.api.setConfig( TVE.get_inputs_value( params.$container, '.tve-api-extra' ) );
										} );

										/* add list id as a parameter when getting the groupin */
										$( TVE.main ).on( 'tve-api-before-ajax-mailchimp.tcb', function ( event, params ) {
											params.api.set( 'ajax_extra', {'list_id': (params.api.getConfig( 'list' ) || 0)} )
										} );

										/* after the lists are rendered add the groupin and the groups. If we have selected groups we mark the accordingly */
										$( TVE.main ).on( 'tve-api-after-render-mailchimp.tcb', function ( event, params ) {
											var $groupin = params.$container.find( '#thrive-api-groupin-select' ).empty(),
												$groups = params.$container.find( '.tve-groups-wrapper' ).empty(),
												groupin = api.get( 'groupin' );

											/* apply previous settings from config */
											$groupin.append( TVE.tpl( 'util/option', {value: 0, selected: (groupin === '0'), text: 'No Group'} ) );

											_.each( api.get( 'groups' ), function ( item ) {
												$groupin.append( TVE.tpl( 'util/option', {value: item.id, selected: groupin === item.id, text: item.title} ) );

												if ( item.id === groupin ) {
													$groups.html( TVE.tpl( 'lead-generation/apis/extra/mailchimp-group', {item: item, selected_groups: api.get( 'selected_groups' )} ) )
												}
											} );
										} );

										/* initialize the api and parse the fields so we can render the html much easier */
										$( TVE.main ).on( 'tve-api-after-get-mailchimp.tcb', function ( event, params ) {
											var groupin = params.api.getConfig( 'groupin' ),
												selected_groups = params.api.getConfig( 'group' ),
												groups = params.api.get( 'extra_settings' ).groups;

											groups = (typeof groups === 'undefined' ? [] : groups);
											groupin = (typeof groupin === 'undefined' ? 0 : groupin);

											selected_groups = (typeof selected_groups === 'undefined' ? [] : selected_groups.split( ',' ));

											params.api.set( 'selected_groups', selected_groups );
											params.api.set( 'groupin', groupin );
											params.api.set( 'groups', groups );

										} );

										$( document ).on( 'change', '#thrive-api-groupin-select', function () {
											var $container = $( '.tve-groups-wrapper' ).empty(),
												groupin = this.value;

											_.each( api.get( 'groups' ), function ( item ) {
												if ( item.id === groupin ) {
													$container.html( TVE.tpl( 'lead-generation/apis/extra/mailchimp-group', {item: item, selected_groups: []} ) )
												}
											} );
										} );

										$( document ).on( 'change', '.mailchimp-api-list', function () {
											var list = this.value,
												$container = $( '#thrive-api-groups' );

											$( '.tve-groups-wrapper' ).empty();
											$container.addClass( 'loading' );

											TVE.ajax( 'get_api_extra', 'GET', {
												api: api.get( 'key' ),
												extra: '_getGroups',
												params: {
													list_id: list
												}
											} ).done( function ( response ) {

												var $groupin = $container.find( '#thrive-api-groupin-select' ).empty();

												response.extra = response.extra || [];
												api.set( 'groups', response.extra );

												if ( response.extra && response.extra.length ) {
													$groupin.append( TVE.tpl( 'util/option', {value: 0, selected: true, text: 'No Group'} ) );
													_.each( response.extra, function ( item ) {
														$groupin.append( TVE.tpl( 'util/option', {value: item.id, selected: false, text: item.title} ) );
													} );
												}

												$container.removeClass( 'loading' );
											} )
										} );

									},
									custom_html: function ( inputs ) {

										/* in case we have a mailchimp connection */
										if ( inputs.code.indexOf( 'mailchimp' ) !== - 1 ||
										     inputs.code.indexOf( 'mc_embed_signup' ) !== - 1 ||
										     inputs.code.indexOf( 'mc-embedded-subscribe' ) !== - 1 ) {

											_.each( inputs.text, function ( input, index ) {
												if ( input.name.length > 30 ) {
													/* this is a normal text input but is a spam protection that is placed absolute outside of the screen */
													input.type = 'hidden';
													inputs.hidden.push( input );
													/* we change it to type hidden and remove it from the text inputs */
													inputs.text.splice( index, 1 );
												}
											} )
										}

										return inputs;
									}

								}
							})( jQuery );
						},
						"html-parser.js": function (exports, module, require) {
							(function ( $ ) {

								function HTMLParser( code ) {

									this.setCode( code );
									/* save two copies of the code so we can work on one of them and still have the original */
									this._orignial_code = code;

									this._inputs = {};

									this.valid = true;
								}

								/**
								 * Validate if the code parsing has went well and we are ok to move on
								 */
								HTMLParser.prototype.validate = function () {

									/* we should have at least one input to be displayed */
									this.valid = (this._inputs.text && this._inputs.text.length) ||
									             (this._inputs.select && this._inputs.select.length) ||
									             (this._inputs.textarea && this._inputs.textarea.length) ||
									             (this._inputs.radio_checkbox && Object.keys( this._inputs.radio_checkbox ).length);
								};

								HTMLParser.prototype.isValid = function () {
									return this.valid;
								};

								HTMLParser.prototype.setCode = function ( code ) {
									if ( ! (code instanceof $) ) {
										code = $( code );
									}

									this.$code = code;
								};

								/**
								 * Parse the current code and in the process remove each field that we retrieve so we won't handle it again.
								 * @param $code
								 * @returns {{hidden, radio_checkbox, text, select, textarea, submit, form}|*|{}}
								 */
								HTMLParser.prototype.parse = function ( $code ) {

									if ( typeof $code === 'undefined' ) {
										$code = this._orignial_code;
									}

									this.setCode( $code );

									this.removeExtra();

									this._inputs = {
										'hidden': this.getInputs( 'hidden' ),
										'radio_checkbox': this.getCheckboxRadio(),
										'text': this.getInputs(),
										'select': this.getSelect(),
										'textarea': this.getTextarea(),
										'submit': this.getSubmit(),
										'form': this.getForm()
									};

									this.validate();

									return this._inputs;
								};

								/**
								 * Remoce extra code that we don't need to parse, like style, scripts, links or inputs of type image.
								 * @param tags
								 * @returns {*}
								 */
								HTMLParser.prototype.removeExtra = function ( tags ) {

									if ( typeof tags === 'undefined' || ! tags instanceof Array ) {
										tags = ['style', 'script', 'link'];
									}

									/* we can't do anything with those ones :( */
									tags.push( 'input:image' );

									/* remove extra tags that we don't need */
									this.$code.find( tags.join( ',' ) ).remove();

									return this.$code;
								};

								/**
								 * Get the text from the submit button
								 * @returns {*}
								 */
								HTMLParser.prototype.getSubmit = function () {
									var text = TVE.t.SignUp,
										$submit = this.$code.find( 'input:submit' ),
										$button = this.$code.find( 'button' );

									if ( $submit.length ) {
										text = $submit.val();
										$submit.remove();
									} else if ( $button.length ) {
										text = $button.text();
										$button.remove();
									}

									return text;
								};

								/**
								 * Read inputs passed as types or all if it's empty. If inputs have a label, save this also.
								 * @param types
								 * @returns {Array}
								 */
								HTMLParser.prototype.getInputs = function ( types ) {

									if ( typeof types === 'undefined' ) {
										types = [];
									}

									if ( typeof types === 'string' ) {
										types = [types];
									}

									var inputs = [];

									_.each( this.$code.find( 'input:not(:submit)' ), function ( input ) {

										if ( types.length > 0 && types.indexOf( input.type ) === - 1 ) {
											return;
										}

										var item = {
											name: input.name,
											id: input.id,
											type: input.type,
											placeholder: input.placeholder,
											value: input.value
										}, $label = this.$code.find( 'label[for="' + input.id + '"]' );

										if ( $label.length ) {
											item.label = $label.text();
										}

										inputs.push( item );

										input.parentNode.removeChild( input );
									}, this );

									return inputs;
								};

								/**
								 * Radio and checkbox inputs are read differently because we have to group them by name
								 * @returns {{}}
								 */
								HTMLParser.prototype.getCheckboxRadio = function () {

									var inputs = {};

									_.each( this.$code.find( 'input:checkbox, input:radio' ), function ( input ) {
										var item = {
											name: input.name,
											id: input.id,
											type: input.type,
											placeholder: input.placeholder,
											value: input.value
										}, $label = this.$code.find( 'label[for="' + input.id + '"]' );

										if ( $label.length ) {
											item.label = $label.text();
										}

										if ( typeof inputs[input.name] === 'undefined' ) {
											inputs[input.name] = [];
										}

										inputs[input.name].push( item );

										input.parentNode.removeChild( input );
									}, this );

									return inputs;
								};

								/**
								 * Read the selects and all the options
								 * @returns {Array}
								 */
								HTMLParser.prototype.getSelect = function () {
									var select = [];

									_.each( this.$code.find( 'select' ), function ( sel ) {
										var item = {
											name: sel.name,
											id: sel.id,
											options: []
										}, $label = this.$code.find( 'label[for="' + sel.id + '"]' );

										if ( $label.length ) {
											item.label = $label.text();
										}

										$( sel ).find( 'option' ).each( function () {
											item.options.push( {
												value: this.value,
												text: this.text
											} )
										} );

										select.push( item );

										sel.parentNode.removeChild( sel );
									}, this );

									return select;
								};

								/**
								 * Read textareas
								 * @returns {Array}
								 */
								HTMLParser.prototype.getTextarea = function () {
									var textareas = [];

									_.each( this.$code.find( 'textarea' ), function ( text ) {
										var item = {
											name: text.name,
											id: text.id,
											placeholder: text.placeholder,
											value: text.value
										};

										textareas.push( item );

										text.parentNode.removeChild( text );
									}, this );

									return textareas;
								};

								/**
								 * Get form info. this can be inside the code or as a first level element
								 * @returns {{}}
								 */
								HTMLParser.prototype.getForm = function () {
									var form = {},
										$form = this.$code.find( 'form' );

									if ( $form.length ) {
										/* get all attributes we need for the form */
										form.action = $form.attr( 'action' );
										form.method = $form.attr( 'method' );
									} else {
										this.$code.each( function ( k, element ) {
											if ( element.tagName === 'FORM' ) {
												form.action = element.action;
												form.method = element.method;
											}
										} )
									}

									return form;
								};

								module.exports = HTMLParser;

							})( jQuery );
						},
						"lead-generation.js": function (exports, module, require) {
							(function ( $ ) {
								var lgModel, lgView;

								lgModel = require( '../models/base' ).extend( {
									initialize: function ( options ) {
										$.extend( true, this, options || {} );

										this._callbacks = {
											read: {},
											write: {}
										};
									},
									/**
									 * Call model callback from outside
									 * @param type the type of callback we want to call - write/read
									 * @param name name of the callback
									 */
									doCallbacks: function ( type, name ) {
										if ( typeof this._callbacks[type][name] === 'undefined' ) {
											return;
										}

										_.each( this._callbacks[type][name], function ( callback ) {
											typeof callback.f === 'function' && callback.f.call( callback.c, this );
										}, this );
									},
									/**
									 * Register model callback
									 * @param type
									 * @param name
									 * @param callback
									 * @param context
									 */
									registerCallback: function ( type, name, callback, context ) {
										if ( typeof this._callbacks[type][name] === 'undefined' ) {
											this._callbacks[type][name] = [];
										}

										this._callbacks[type][name].push( {f: callback, c: context || this} );
									},
									/**
									 * Remove callback from model
									 * @param type
									 * @param name
									 * @param callback
									 */
									removeCallbacks: function ( type, name, callback ) {
										if ( typeof this._callbacks[type][name] === 'undefined' ) {
											return;
										}

										if ( typeof callback === 'undefined' ) {
											delete typeof this._callbacks[type][name];
										}

										_.each( this._callbacks[type][name], function ( call, index ) {
											this._callbacks[type][name][index].f === callback && delete this._callbacks[type][name][index];
										}, this );
									}
								} );

								lgView = Backbone.View.extend( {

									code_separator: '__CONFIG_lead_generation_code__',

									cache_wrappers: {},

									initialize: function ( options ) {

										$.extend( true, this, options || {} );

										this.undelegateEvents();

										this.read();

										this.listenTo( this.model, 'change', this.change );

										this.$( 'form' ).attr( 'novalidate', 'novalidate' );
									},

									_is_placeholder: function () {

										return this.$el.is( '.tcb-elem-placeholder' );
									},

									change: function ( model ) {

										if ( typeof model.changed.write !== 'undefined' ) {
											this.model.doCallbacks( 'write', model.changed.write );

											this.write( model.changed.write );

											this.model.unset( 'write', {silent: true} );
										}
										/* if a write/read attribute has changed, we check to see if we have any callbacks for this kind of method */
										if ( typeof model.changed.read !== 'undefined' ) {
											this.model.doCallbacks( 'read', model.changed.read );

											this.read( model.changed.read );

											this.model.unset( 'read' );
										}
									},

									read: function ( what ) {
										/* in case you want to read only one specific field */
										if ( typeof what !== 'undefined' && typeof this._read[what] !== 'undefined' ) {
											return this._read[what].call( this );
										}

										_.each( this._read, function ( func ) {
											func.call( this );
										}, this );
									},

									_read: {

										form_type: function () {

											this.model.set( 'form_type', this.$( 'input[name="_form_type"]' ).val() );
										},

										/**
										 * Read options set for after sign up(opt-in) action
										 */
										submit_option: function () {

											this.model.set( 'submit_option', this.$( '#_submit_option' ).val() || 'reload', {silent: true} );
											this.model.set( 'back_url', this.$( '#_back_url' ).val() || '' );
										},

										display_custom_error_message: function () {

											this.model.set( 'display_custom_error_message', this.$( '#_error_message_option' ).val() === '1' );
										},

										custom_messages: function () {

											var _value = this.$el.find( '#__tcb_lg_msg' ).val();

											if ( typeof _value === 'undefined' || _value === 'undefined' ) {
												_value = {
													error: TVE.t.error + '!',
													success: TVE.t.success + '!'
												};
											} else {
												try {
													_value = TVE.Base64.decode( _value );
													_value = TVE.unserialize( _value );
												} catch ( error ) {
													_value = '';
													console.info( error );
												}
											}

											this.model.set( 'custom_messages', _value );

											return this;
										},

										type: function () {

											this.model.set( 'type', this.$el.attr( 'data-connection' ) );

											return this;
										},

										error_messages: function () {

											var $errors_input = this.$el.find( '.tve-lg-err-msg' );
											if ( $errors_input.length ) {
												try {
													this.model.set( 'error_messages', JSON.parse( $errors_input.val() ) );
												} catch ( Error ) {
													console.log( Error );
													this.model.set( 'error_messages', {} )
												}
											}

											return this;
										},

										captcha: function () {
											var config = {};

											this.$el.find( "input[name*='captcha']" ).each( function () {
												config[this.getAttribute( 'name' )] = this.value;
											} );

											this.model.set( 'captcha', $.extend( {
												_use_captcha: '0',
												_captcha_theme: 'light',
												_captcha_type: 'image',
												_captcha_size: 'normal'
											}, config ) );

											return config;
										},

										/**
										 * Read api connections and extra fields for
										 */
										apis: function () {

											var $conn = this.$( '#__tcb_lg_fc' ),
												apis = {};

											if ( $conn.length ) {
												try {
													var c = TVE.unserialize( TVE.Base64.decode( $conn.val() ) );

													_.each( c, function ( list, api ) {
														apis[api] = {
															list: list
														}
													} )
												} catch ( e ) {
													console.log( e );
												}
											}

											/* read extra fields and save them for each api */
											this.$( '.tve-api-extra' ).filter( ':not(.tve_disabled)' ).each( function () {
												var $this = jQuery( this ),
													_parts = $this.attr( 'name' ).split( '_' ),
													key = _parts.shift(),
													_field = _parts.join( '_' );

												if ( typeof apis[key] === 'undefined' ) {
													return;
												}

												if ( $this.is( 'input:radio, input:checkbox' ) ) {
													if ( $this.is( ':radio' ) && $this.is( ':checked' ) ) {
														apis[key][_field] = this.value;
													} else if ( $this.is( ':checkbox' ) && $this.is( ':checked' ) ) {
														apis[key][_field] = (apis[key][_field] ? apis[key][_field] + ',' + this.value : this.value);
													}
												} else {
													apis[key][_field] = this.value;
												}
											} );

											this.model.set( 'apis', apis );

											return apis;
										},
										/**
										 * Read what fields where added for the lead generation form: email, name, phone ..
										 * @returns {{}}
										 */
										form_fields: function () {
											var form_fields = {};

											if ( this.model.get( 'type' ) === 'api' ) {
												/* only read fields if we have an api connection, for custom html we don't care */
												this.$( '.tve_lg_input_container>input' ).each( function () {
													form_fields[this.name] = {
														id: this.name,
														placeholder: this.getAttribute( 'placeholder' ),
														required: (parseInt( this.dataset.required ) === 1)
													}
												} );
											}

											this.model.set( 'form_fields', form_fields );

											return form_fields;
										},
										/**
										 * Read custom html code that is saved insde the hidden div
										 * @returns {string}
										 */
										custom_html_code: function () {
											var $lg_code = this.$( '.thrv_lead_generation_code' ),
												code = '';

											if ( $lg_code.length ) {
												code = $lg_code.text().replace( new RegExp( this.code_separator, 'g' ), '' );
											}

											this.model.set( 'custom_html_code', code );

											return code;
										}
									},

									write: function ( what, params ) {

										if ( typeof what !== 'undefined' && typeof this._write[what] !== 'undefined' ) {
											return this._write[what].call( this, params );
										}

										/**
										 * In case you want to write all the fields
										 */
										_.each( this._write, function ( func ) {
											func.call( this, params );
										}, this );
									},

									get_wrapper: function ( selector, $parent ) {

										if ( this._is_placeholder() ) {
											var tpl = TVE.tpl( 'lead-generation/wrappers' );
											this.$el.html( tpl() ).removeClass( 'tcb-elem-placeholder' );
										}

										var $wrapper = this.$( selector ).first();

										/* if the element does not exist, but we provide a parent, we just create a div with the same div/class and return it. */
										if ( $wrapper.length === 0 && typeof $parent !== 'undefined' && $parent instanceof $ ) {
											$wrapper = $( '<div>' ).attr( (selector[0] === '#' ? 'id' : 'class'), selector.substring( 1 ) ).appendTo( $parent );
										}

										return $wrapper;
									},

									renderCaptcha: function ( key ) {

										var rand = Math.floor( (Math.random() * 1000) + 1 ),
											captcha_settings = this.model.get( 'captcha' );

										captcha_settings = $.extend( {
											_captcha_theme: 'light',
											_captcha_type: 'image',
											_captcha_size: 'normal'
										}, captcha_settings );

										return '<div class="tve-captcha-container ' +
										       'tve-captcha-' + captcha_settings._captcha_theme + ' tve-captcha-' + captcha_settings._captcha_size + '" ' +
										       'id="tve_captcha-' + rand + '" ' +
										       'data-site-key="' + key + '" ' +
										       'data-theme="' + captcha_settings._captcha_theme + '" ' +
										       'data-type="' + captcha_settings._captcha_type + '" ' +
										       'data-size="' + captcha_settings._captcha_size + '">' +
										       '</div>';
									},

									_write: {

										reset: function () {
											var tpl = TVE.tpl( 'lead-generation/wrappers' );
											this.$el.html( tpl() );
										},

										form_type: function () {

										},

										/**
										 * Write two hidden inputs into form:
										 * #_submit_option
										 * #_back_url
										 *
										 * If the submit_option is 'message'
										 * then the #_back_url is removed and the message set into custom_messages
										 *
										 * @returns {lgView}
										 */
										submit_option: function () {

											/**
											 * write #_submit_option input
											 */
											var $submit = this.$( '#_submit_option' );
											if ( $submit.length > 0 ) {
												$submit.val( this.model.get( 'submit_option' ) );
											} else {
												this.get_wrapper( 'form' ).append( this._write.renderHiddenInput( {
													name: '_submit_option',
													value: this.model.get( 'submit_option' )
												} ) );
											}

											/**
											 * if the option is message
											 * also write the custom_messages
											 */
											if ( this.model.get( 'submit_option' ) === 'message' ) {

												this.write( 'custom_messages' );

												this.$( '#_back_url' ).remove();

												return this;
											}

											/**
											 * write #_back_url input
											 */
											var $back = this.$( '#_back_url' );
											if ( $back.length > 0 ) {
												$back.val( this.model.get( 'back_url' ) );
											} else {
												this.get_wrapper( 'form' ).append( this._write.renderHiddenInput( {
													name: '_back_url',
													value: this.model.get( 'back_url' )
												} ) );
											}

											return this;
										},

										/**
										 * Sets the data-connection on active element
										 */
										type: function () {

											this.$el.attr( 'data-connection', this.model.get( 'type' ) );
										},

										/**
										 * Renders an hidden input to be used inside the form
										 *
										 * @param element
										 * @returns {string}
										 */
										renderHiddenInput: function ( element ) {

											element = _.extend( {
												name: '',
												value: '',
												className: ''
											}, element );

											return '<input id="' + element.name + '" type="hidden" name="' + element.name + '"' + (element.className ? ' class="' + element.className + '"' : '') + ' value="' + element.value + '">';
										},

										/**
										 * sets a hidden input with bool value (1|0)
										 * for toggling custom error|success message on form submit on front end
										 */
										display_custom_error_message: function () {

											var _value = this.model.get( 'display_custom_error_message' ) ? 1 : 0;

											if ( this.$( '#_error_message_option' ).length > 0 ) {
												this.$( '#_error_message_option' ).val( _value );

												return this;
											}

											var _input = this._write.renderHiddenInput( {
												name: '_error_message_option',
												value: _value
											} );

											this.get_wrapper( 'form' ).append( _input );

											return this;
										},

										/**
										 * Sets a hidden input with error and success messages serialized and base64 encoded
										 */
										custom_messages: function () {

											try {
												var _value = this.model.get( 'custom_messages' );

												_value = TVE.serialize( _value );
												_value = TVE.Base64.encode( _value );

												if ( this.$( '#__tcb_lg_msg' ).length > 0 ) {
													this.$( '#__tcb_lg_msg' ).val( _value );

													return this;
												}

												var _input = this._write.renderHiddenInput( {
													name: '__tcb_lg_msg',
													value: _value
												} );

												this.get_wrapper( 'form' ).append( _input );

												return this;

											} catch ( error ) {
												console.log( error );
											}
										},

										/**
										 * stringify the error_messages from model and set them
										 * as value on its input
										 *
										 * @returns {lgView}
										 */
										error_messages: function () {

											var _errors = JSON.stringify( this.model.get( 'error_messages' ) );

											if ( _errors ) {
												this.$el.find( '.tve-lg-err-msg' ).val( _errors );
											}

											return this;
										},

										captcha: function () {

											var self = this,
												captcha_settings = this.model.get( 'captcha' );

											this.$( '.tve-captcha-container' ).remove();

											if ( parseInt( captcha_settings._use_captcha ) === 1 ) {
												this.get_wrapper( '.tve_lead_generated_inputs_container' ).append(
													this.renderCaptcha( this.model.get( 'captcha' ).site_key )
												);

												$.each( captcha_settings, function ( prop, value ) {
													if ( prop === 'site_key' ) {
														return;
													}
													var $input = self.$( '#' + prop );
													if ( $input.length > 0 ) {
														$input.val( value );
													} else {
														var input = self._write.renderHiddenInput( {
															name: prop,
															value: value
														} );
														self.get_wrapper( 'form' ).append( input );
													}
												} );

												return this;
											}

											this.$( "input[name*='captcha']" ).remove();

											return this;
										},

										apis: function () {
											/* base 64 encoded and serialized object of the connections and their list */
											var $conn = this.$( '#__tcb_lg_fc' ),
												/* container of all the inputs */
												$inputs = this.get_wrapper( '.tve_lead_generated_inputs_container' ),
												$form = this.get_wrapper( 'form' ),
												apis = this.model.get( 'apis' ),
												config = {};

											/* prepare config to be saved */
											_.each( apis, function ( api, key ) {
												config[key] = api.list;
												/* we don't need this anymore */
												delete apis[key].list;
											} );

											/* if there is no connection container input, we add it */
											if ( $conn.length === 0 ) {
												$conn = $( '<input>', {
													type: 'hidden',
													name: '__tcb_lg_fc',
													id: '__tcb_lg_fc'
												} );

												$form.append( $conn );
											}

											/* we try and encode this config and save it afterwards  */
											try {
												var c = TVE.Base64.encode( TVE.serialize( config ) );

												$conn.val( c );
											} catch ( e ) {
												console.log( e );
											}

											/* remove all extra fields so we can recreate them again */
											this.$( '.tve-api-extra' ).remove();

											_.each( apis, function ( api, key ) {
												_.each( api, function ( v, k ) {
													/* append all fields except the list because that was added before */
													$form.append( $( '<input>', {
														type: 'hidden',
														id: key + '_' + k,
														class: 'tve-api-extra',
														name: key + '_' + k,
														value: v
													} ) )
												} )
											} );
										},

										custom_fields: function () {
											/* remove old inputs */
											this.$( '.tve_lg_input' ).remove();

											var input_class = 'tve_lg_input_container tve_lg_input',
												$container = this.get_wrapper( '.tve_lead_generated_inputs_container' );

											/* for horizontal forms, we search the submit class and add it to all the inputs that we create */
											if ( this.$el.hasClass( 'thrv_lead_generation_horizontal' ) ) {
												var submit_class = this.$( '.tve_submit_container' ).attr( 'class' ).match( /tve_lg_\d/gi );
												input_class += (submit_class && submit_class.length) ? ' ' + submit_class[0] : '';
											}

											/* generate all the inputs inside the container */
											_.each( this.model.get( 'custom_fields' ), function ( field ) {

												field.placeholder = (field.placeholder.trim().length === 0 ? field.id : field.placeholder);

												var type = (field.id === 'email') ? 'email' : 'text',
													$div = $( '<div>', {class: input_class} );

												if ( field.id.indexOf( 'password' ) !== - 1 ) {
													type = 'password';
													$div.append( TVE.tpl( 'lead-generation/apis/extra/password-strength' )() );
												}

												$div.append( $( '<input>', {
													type: type,
													'data-field': field.id,
													'data-required': field.required ? 1 : 0,
													'data-validation': field.id === 'email' ? 'email' : '',
													name: field.id,
													placeholder: field.placeholder,
													'data-placeholder': field.placeholder
												} ) );

												$container.append( $div );
											} );

											/* we regenerate the submit button */
											$container.append( this._write.formInputs.submit( TVE.t.SignUp ) );
										},

										customHtml: function () {
											var inputs = this.model.get( 'customHtml' ),
												$container = this.get_wrapper( '.thrv_lead_generation_container', this.$el ),
												$form = $( '<form>', {
													method: inputs.form.method,
													action: '#'
												} ),
												$inputs_container = $( '<div>', {class: 'tve_lead_generated_inputs_container'} ).appendTo( $form );

											/* save the html code that was used to generate the form */
											this._write._custom_html_code.call( this );

											/* add the form action into a hidden input so we can prevent bots from automatic submit */
											$form.append( $( '<input>', {
												type: 'hidden',
												class: 'tve-f-a-hidden',
												value: inputs.form.action
											} ) );

											/* render all hidden inputs */
											_.each( inputs.hidden, function ( input ) {
												$form.append( this._write.renderHiddenInput( input ) );
											}, this );

											/* render the rest of the inputs */
											_.each( inputs, function ( input, func ) {
												/* if there is a function for that type of input, we render it */
												if ( typeof this._write.formInputs[func] === 'function' ) {
													/* if we have an array or an object, we render each one individually */
													if ( typeof input === 'object' ) {
														_.each( input, function ( item ) {
															$inputs_container.append( this._write.formInputs[func]( item ) );
														}, this )
													} else {
														$inputs_container.append( this._write.formInputs[func]( input ) );
													}
												}
											}, this );

											/* append all inputs to the form */
											$inputs_container.appendTo( $form );
											/* put just the form inside the container */
											$container.html( $form );
										},
										/**
										 * render certain types of inputs and return the jQuery object
										 */
										formInputs: {
											text: function ( input ) {
												var $container = $( '<div>', {
													class: 'tve_lg_input_container tve_lg_input'
												} );

												/* we don't add label to text inputs :( */
												if ( 0 && typeof input.label === 'string' ) {
													$( '<label>', {
														for: input.id,
														text: input.label
													} ).appendTo( $container );
												}

												$( '<input>', input ).appendTo( $container );

												return $container;
											},
											radio_checkbox: function ( inputs ) {
												var $container = $( '<div>', {
													class: 'tve_lg_input_container tve_clearfix tve_lg_' + inputs[0].type //radio or checkbox
												} );

												_.each( inputs, function ( input ) {
													var $wrapper = $( '<div>', {class: 'tve_lg_' + inputs[0].type + '_wrapper'} );

													$( '<input>', input ).appendTo( $wrapper );

													/* we don't use the label, we just add the value :( */
													input.label = input.value;

													if ( typeof input.label === 'string' ) {
														$( '<label>', {
															for: input.id,
															text: input.label,
															class: 'thrv-inline-text'
														} ).appendTo( $wrapper );
													}

													$container.append( $wrapper );
												} );

												return $container;
											},
											select: function ( select ) {
												var $container = $( '<div>', {
														class: 'tve_lg_input_container tve_lg_dropdown tve_lg_select_container'
													} ),
													$select = $( '<select>', {name: select.name, id: select.id} );

												/* we don't display label to select :( */
												if ( 0 && typeof select.label === 'string' ) {
													$( '<label>', {
														for: select.id,
														text: select.label
													} ).appendTo( $container );
												}

												_.each( select.options, function ( option ) {
													$select.append( $( '<option>', option ) )
												} );

												$container.append( $select );

												return $container;
											},
											textarea: function ( textarea ) {
												var $container = $( '<div>', {
													class: 'tve_lg_input_container tve_lg_textarea'
												} );

												$( '<textarea>', textarea ).appendTo( $container );

												return $container;
											},
											submit: function ( text ) {
												return $( '<div>', {class: 'tve_lg_input_container tve_submit_container tve_lg_submit'} ).append( $( '<button>', {type: 'submit', text: text} ) );
											}
										},

										_custom_html_code: function () {
											var $lg_code = this.get_wrapper( '.thrv_lead_generation_code', this.$el );

											$lg_code.hide();

											$lg_code.text( this.code_separator + this.model.get( 'customHtml' ).code + this.code_separator );
										}
									}
								} );

								module.exports = {
									model: lgModel,
									view: lgView
								}

							})( jQuery );
						},
						"typefocus.js": function (exports, module, require) {
							module.exports = require( './base' ).extend( {
								defaults: function () {
									return {
										text: '',
										variations: [],
										speed: 1000,
										blink: false,
										highlight: 1,
										colors: ''
									};
								},
								validate: function () {
									var v = this.get( 'variations' );

									if ( ! v.length || ! v[0].length ) {
										this.error = TVE.t.variation_required;
										return false;
									}

									if ( ! this.get( 'text' ) ) {
										this.error = TVE.t.default_text_required;
										return false;
									}

									return true;
								},
								get_dom_attr: function () {
									return {
										'class': 'tve_typefocus' + (this.get( 'blink' ) ? ' ' + 'tve_typefocus_cursor' : ''),
										'data-typist': this.get( 'variations' ).join( '|' ),
										'data-speed': this.get( 'speed' ),
										'data-highlight': this.get( 'highlight' ) ? 1 : 0,
										'data-colors': this.get( 'colors' ) || ''
									};
								},
								read: function ( element ) {
									this.set( {
										text: element.innerText || element.textContent,
										blink: element.className && element.className.indexOf( 'tve_typefocus_cursor' ) !== - 1,
										variations: ( element.getAttribute( 'data-typist' ) || '' ).split( '|' ),
										speed: parseInt( element.getAttribute( 'data-speed' ) || 1000 ),
										highlight: parseInt( element.getAttribute( 'data-highlight' ) || 1 ),
										colors: element.getAttribute( 'data-colors' ) || ''
									} );
									this.__dom = element;// store the reference here
									this.set( 'label', this.get_preview_text() );
								},
								get_preview_text: function () {
									var text = this.get( 'text' );
									if ( this.get( 'variations' ).length ) {
										text += ' | ' + this.get( 'variations' ).join( ' | ' );
									}

									return text;
								},
								/**
								 *
								 * @param {Boolean} silent if defined, it will not trigger a change event
								 */
								reset: function ( silent ) {
									silent = typeof silent !== 'undefined';
									delete this.__dom;
									this.set( this.defaults(), {silent: silent} );
								}
							} );
						}
					},
					"views": {
						"_includes.js": function (exports, module, require) {
							var AnimationComponent = require( './components/animation' );

							(function ( $ ) {
								module.exports = {
									Views: {
										Components: {
											ct: require( './components/content-templates' ),
											Button: require( './components/button' ),
											Columns: require( './components/columns' ),
											Image: require( './components/image' ),
											Tweet: require( './components/click-tweet' ),
											Rating: require( './components/rating' ),
											Wordpress: require( './components/wordpress' ),
											Testimonial: require( './components/testimonial' ),
											CommentsDisqus: require( './components/comments-disqus' ),
											CommentsFacebook: require( './components/comments-facebook' ),
											Countdown: require( './components/countdown' ),
											CountdownEvergreen: require( './components/countdown-evergreen' ),
											StyledList: require( './components/styled-list' ),
											ResponsiveVideo: require( './components/responsive-video' ),
											Html: require( './components/html' ),
											Icon: require( './components/icon' ),
											ImageEffects: require( './components/image-effects' ),
											Layout: require( './components/layout' ),
											Typography: require( './components/typography' ),
											Text: require( './components/text' ),
											Borders: require( './components/borders-corners' ),
											TableBorders: require( './components/table-borders' ),
											Shadow: require( './components/shadow' ),
											Responsive: require( './components/responsive' ),
											StylesTemplates: require( './components/styles-templates' ),
											Animation: AnimationComponent.component,
											Background: require( './components/background' ),
											Social: require( './components/social' ),
											Credit: require( './components/credit' ),
											Reveal: require( './components/reveal' ),
											Section: require( './components/section' ),
											Decoration: require( './components/decoration' ),
											Divider: require( './components/divider' ),
											Gmap: require( './components/gmap' ),
											PostGrid: require( './components/post-grid' ),
											PostGridLayout: require( './components/post-grid-layout' ),
											PostGridQuery: require( './components/post-grid-query' ),
											PostGridFilter: require( './components/post-grid-filter' ),
											AnimationViews: AnimationComponent.views,
											LpAdvanced: require( './components/landing-page/lp-advanced' ),
											LpScripts: require( './components/landing-page/lp-scripts' ),
											LpFonts: require( './components/landing-page/lp-fonts' ),
											ContentBox: require( './components/contentbox' ),
											TOC: require( './components/toc' ),
											ProgressBar: require( './components/progress-bar' ),
											Table: require( './components/table' ),
											Cell: require( './components/cell' ),
											LeadGeneration: require( './components/lead-generation' ),
											LeadGenerationInput: require( './components/lead-generation/input' ),
											LeadGenerationSubmit: require( './components/lead-generation/submit' ),
											LeadGenerationSelect: require( './components/lead-generation/select' ),
											LeadGenerationRadio: require( './components/lead-generation/radio' ),
											LeadGenerationCheckbox: require( './components/lead-generation/checkbox' ),
											LeadGenerationTextarea: require( './components/lead-generation/textarea' ),
											FillCounter: require( './components/fillcounter' ),
											CustomMenu: require( './components/menu' ),
											TabContent: require( './components/tabs' ),
											ContentToggle: require( './components/toggle' ),
											Lightbox: require( './components/lightbox' )
										},
										Controls: {
											ApiConnections: require( './controls/api-connections' ),
											ButtonGroup: require( './controls/button-group' ),
											Checkbox: require( './controls/checkbox' ),
											Headings: require( './controls/toc/headings' ),
											Switch: require( './controls/switch' ),
											ColorPicker: require( './controls/color-picker' ),
											DatePicker: require( './controls/date-picker' ),
											ModalPicker: require( './controls/modal-picker' ),
											ImagePicker: require( './controls/image-picker' ),
											ImageSize: require( './controls/image-size' ),
											Input: require( './controls/input' ),
											LabelInput: require( './controls/label-input' ),
											InputMultiple: require( './controls/input-multiple' ),
											TextInput: require( './controls/text-input' ),
											Borders: require( './controls/borders' ),
											Corners: require( './controls/corners' ),
											InputSearch: require( './controls/input-search' ),
											Select: require( './controls/select' ),
											SelectMultiple: require( './controls/select-multiple' ),
											MarginAndPadding: require( './controls/margin-padding' ),
											MaxWidth: require( './controls/max-width' ),
											PositionFrom: require( './controls/position-from' ),
											Slider: require( './controls/slider' ),
											TimeSlider: require( './controls/time-slider' ),
											StylePicker: require( './controls/style-picker' ),
											List: require( './controls/list' ),
											PreviewList: require( './controls/preview-list' ),
											LinkSearch: require( './controls/link' ),
											DropPanel: require( './controls/drop-panel' ),
											FontManager: require( './controls/font-manager' ),
											Shadow: require( './controls/shadow' ),
											Knob: require( './controls/knob' )
										},
										Base: require( './base' ),
										InlinePanel: require( './inline/inline-drop-panel' )
									},
									FontManager: require( './../../editor/src/util/font-manager' ),
									StorageManager: require( './../libs/storage' ),
									renderers: require( '../elements/_renderers.js' ),
									modal: require( './modals/base' ),
									modal_open: require( './modals/_open' ),
									EventManager: require( '../libs/event-manager' ),
									shortcode_manager: require( '../libs/shortcode-manager' )
								};

							})( jQuery );
						},
						"base.js": function (exports, module, require) {
							var baseView, controlBase, componentBase, viewModelBase,
								watcher = require( '../libs/watcher' ),
								storage = require( '../libs/storage' );

							(function ( $ ) {
								baseView = Backbone.View.extend( {
									events: {
										'click .click': '_call',
										'input .input': '_call',
										'change .change': '_call',
										'mousedown .mousedown': '_call',
										'mouseenter .mouseenter': '_call',
										'mouseup .mouseup': '_call',
										'keyup .keyup': '_call',
										'keyup .keyup-enter': '_keyup_enter',
										'click .dropdown-header': 'toggleControls'
									},
									initialize: function ( attr ) {
										if ( typeof this.before_initialize === 'function' ) {
											this.before_initialize( attr );
										}
										this.render();
										if ( typeof this.after_initialize === 'function' ) {
											this.after_initialize( attr );
										}
									},
									/**
									 * Call method for specific events
									 * @param e
									 * @returns {boolean}
									 */
									_call: function ( e ) {
										/**
										 * Do not allow actions on disabled controls
										 */
										if ( e.currentTarget.disabled || e.currentTarget.classList.contains( 'tve-disabled' ) ) {
											return false;
										}
										var m = e.currentTarget.getAttribute( 'data-fn-' + e.type ) || e.currentTarget.getAttribute( 'data-fn' );
										if ( m && m === '__return_false' ) {
											e.stopPropagation();
											e.preventDefault();
											return false;
										}

										if ( typeof this[m] === 'function' ) {
											return this[m].call( this, e, e.currentTarget );
										}

										/**
										 * call external function on the base TVE object
										 */
										if ( m && m.indexOf( 'f:' ) === 0 ) {
											var fn = TVE, parts = m.split( ':' )[1].split( '.' ), context = window;
											while ( fn && parts.length ) {
												context = fn;
												fn = fn[parts.shift()];
											}
											if ( typeof fn === 'function' ) {
												return fn.call( context, e );
											}
										}
									},
									/**
									 * Apply callback on Enter press on an input
									 *
									 * @param e
									 * @returns {*|boolean}
									 * @private
									 */
									_keyup_enter: function ( e ) {
										if ( e.which === 13 ) {
											return this._call( e );
										}
									},
									/**
									 * Show the element
									 *
									 * @param {Boolean} [silent] whether or not to suppress the event triggering
									 *
									 * @returns {TVE.Views.Base}
									 */
									show: function ( silent ) {
										if ( ! this.visible() ) {
											if ( ! silent ) {
												this.trigger( 'show' );
											}

											if ( ! this.$el.data( 'hide' ) ) {
												this.$el.show();
											}
										}

										return this;
									},
									/**
									 * Hide the element
									 *
									 * @param {Boolean} [silent] whether or not to suppress the event triggering
									 *
									 * @returns {TVE.Views.Base}
									 */
									hide: function ( silent ) {
										if ( this.visible() ) {
											if ( ! silent ) {
												this.trigger( 'hide' );
											}
											this.$el.hide();
										}
										return this;
									},
									/**
									 * Checks if the root element is visible
									 *
									 * @returns {Boolean}
									 */
									visible: function () {
										return this.$el.is( ':visible' );
									},
									toggleControls: function () {

									},
									/**
									 * Returns an Array containing the values of all the checked checkboxes
									 *
									 * @param {String} selector
									 *
									 * @returns {Array}
									 */
									checkbox_values: function ( selector ) {
										var _r = [];
										this.$( selector + ':checked' ).each( function () {
											_r.push( this.value );
										} );

										return _r;
									},
									/**
									 * Completely destroy the view
									 */
									destroy: function () {
										this.unbind();
										this.remove();
										if ( this.onDestroy ) {
											this.onDestroy();
										}
									},
									render: function () {
										/**
										 * Also allow defining template as a string
										 */
										if ( this.template && _.isString( this.template ) ) {
											this.template = TVE.tpl( this.template );
										}
										if ( this.template ) {
											this.$el.html( this.template() );
										}

										if ( typeof this['after_render'] === 'function' ) {
											this.after_render();
										}

										return this;
									},
									/**
									 * Creates and displays an inline message in a view
									 *
									 * @param message
									 * @param state
									 * @param $element
									 */
									inline_message: function ( message, state, $element ) {
										if ( typeof $element === 'undefined' ) {
											$element = this.$el.children().last();
										}
										state = state || 'info';
										message = message || {};

										var $message = this.$( '.inline-message' );
										if ( ! $message.length ) {
											$message = jQuery( '<div class="inline-message"></div>' );
										}

										$message.removeClass( 'm-success m-info m-error' ).addClass( 'm-' + state ).empty();
										$element.after( $message );
										$message.text( message );

										return $message;
									}
								} );

								viewModelBase = baseView.extend( {
									events: function () {
										return _.extend( baseView.prototype.events, {
											'change [data-setting]': 'change_value'
										} );
									},
									initialize: function ( attr ) {
										var self = this;

										if ( typeof this.before_initialize === 'function' ) {
											this.before_initialize( arguments );
										}
										this.data = {};

										this.render();

										this.$( '[data-setting]' ).each( function () {
											var k = this.getAttribute( 'data-setting' );
											watcher( self.data, k, self.value_changed, self )
										} );

										if ( typeof this.after_initialize === 'function' ) {
											this.after_initialize( arguments );
										}
									},
									change_value: function ( e, input ) {
										watcher.skip_one();
										this.data[input.getAttribute( 'data-setting' )] = this.$( input ).val();
									},
									value_changed: function ( prop, value ) {
										this.$( '[data-setting="' + prop + '"]' ).val( value );
									}
								} );
								/**
								 * Generic Control that will be extend by the others
								 */
								controlBase = baseView.extend( {
									/**
									 * Return the element where the control will apply his css
									 *
									 * this.config.to special values:
									 *      main::<selector> - do not search inside the TVE.ActiveElement context - search it globally on the page
									 *      closest::<selector> - a parent of the TVE.ActiveElement having the corresponding selector
									 * @returns {*}
									 */
									applyTo: function ( dom ) {
										if ( ! TVE.ActiveElement ) {
											return $();
										}
										var to = this.config ? this.config.to || '' : '',
											$element = TVE.ActiveElement;

										if ( to.indexOf( 'main::' ) === 0 ) {
											$element = TVE.inner_$( to.replace( 'main::', '' ) );
										} else if ( to.indexOf( 'closest::' ) === 0 ) {
											$element = TVE.ActiveElement.closest( to.replace( 'closest::', '' ) );
										} else if ( to ) {
											$element = $element.find( to );
											if ( ! $element.length ) {
												$element = TVE.ActiveElement.closest( '.thrv_wrapper' ).find( to );
											}
										}

										if ( dom ) {
											$element = $element[0];
										}

										return $element
									},
									/**
									 * Check if the config has css_suffix
									 * and returns the element from css_suffix in context of $element
									 *
									 * @returns {*}
									 */
									readFrom: function () {

										var $element = this.applyTo();

										if ( this.config && this.config.css_suffix ) {
											if ( ! $.isArray( this.config.css_suffix ) ) {
												return $element.find( this.config.css_suffix );
											}
											var $o = $element;
											$element = $();
											for ( var i = 0, _selector; _selector = this.config.css_suffix[i ++]; ) {
												$element = $element.add( $o.find( _selector ) );
											}
										}

										return $element;
									},
									/**
									 * Call method for specific events
									 * @param e
									 * @returns {boolean}
									 */
									_call: function ( e ) {
										var m = e.currentTarget.getAttribute( 'data-fn-' + e.type ) || e.currentTarget.getAttribute( 'data-fn' );

										if ( m && m === '__return_false' ) {
											e.stopPropagation();
											e.preventDefault();
											return false;
										}

										switch ( e.type ) {
											case 'input':
												TVE.SKIP_CSS_STATE = true;
												break;
											default:
											case 'change':
												TVE.SKIP_CSS_STATE = false;
												break;
										}

										if ( typeof this[m] === 'function' ) {
											var $element = this.applyTo();

											$element = typeof this.prepare === 'function' ? this.prepare( $element ) : $element;

											return this[m].call( this, $element, e.currentTarget, e );
										}

										return false;
									},
									/**
									 * Apply specific config on the control
									 * @param config
									 * @param to
									 * @param {String} [css_suffix] CSS suffix to apply on head_css operations
									 */
									setConfig: function ( config, to, css_suffix ) {

										this.config = {
											to: to,
											css_suffix: css_suffix || ''
										};

										if ( typeof config !== 'undefined' ) {
											$.extend( true, this.config, config );
										}

										this.afterConfig();
									},
									change: function ( $element, dom ) {
										TVE.SkipUpdate = true;
										this.input( $element, dom );
									},
									input: function () {
										throw new Error( this.key() + ': Input function not implemented!' );
									},
									update: function () {
										throw new Error( this.key() + ': Update function not implemented!' );
									},
									afterConfig: function () {
									},
									/**
									 *  Get default value set in initial config
									 * @returns {*|string}
									 */
									getDefault: function () {
										return this.default || this.model.default || this.model.config.default || '';
									},
									/**
									 * Return control key in case we have it
									 *
									 * @returns {string}
									 */
									key: function () {
										return this.$el.data( 'key' ) || this.$el.data( 'view' ) || '';
									}
								} );

								/**
								 * Generic Component that will be extend
								 */
								componentBase = baseView.extend( {
									/**
									 * Flag marking whether or not this component is visible on other states than the default one
									 */
									extra_states: false,
									initialize: function ( attr ) {
										var self = this;
										this.config = attr.config;
										this.renderer = attr.renderer;

										this.hide();

										this.controls = {};

										/* component key - so we can identify it much easier */
										this.key = '';

										/* Go through all the controls and check to see if they are custom ones or extend existing ones */
										this.$el.find( '.tve-control' ).each( function () {
											var $this = $( this ),
												view = $this.data( 'view' ),
												key = $this.data( 'key' ) || view,
												control = view,
												view_constructor = $this.data( 'initializer' ),
												model = self.config && self.config[key] ? self.config[key] : {config: {}};

											if ( self.config && self.config[key] && typeof self.config[key].extends !== 'undefined' ) {
												control = self.config[key].extends;
											}

											/**
											 * Allows dynamic controls instantiation
											 */
											if ( view_constructor && typeof self[view_constructor] === 'function' ) {
												control = self[view_constructor]();
											} else if ( typeof TVE.Views.Controls[control] === 'undefined' ) {
												/* If for some reason we can't find the control, we just create an instance of a base control */
												control = TVE.Views.Base.control;
											} else {
												control = TVE.Views.Controls[control];
											}

											self.controls[key] = new control( {
												el: $this,
												model: model,
												component: self
											} );

											self.controls[key].component = self;
										} );

										this.options = ( attr.options || {} );

										if ( typeof this.after_init === 'function' ) {
											this.after_init.call( this, attr );
										}

										this.controls_init( this.controls );

									},
									setKey: function ( key ) {
										this.key = key;
									},
									/**
									 * Set flex order for the component
									 * @param order
									 */
									setOrder: function ( order ) {
										if ( typeof order === 'undefined' || isNaN( order ) ) {
											order = 0;
										}

										this.$el.css( 'order', order );
									},
									/**
									 * Should return true if the current element is a placeholder
									 *
									 * @param {jquery} $element
									 *
									 * @returns {boolean}
									 */
									is_placeholder: function ( $element ) {
										return $element.hasClass( 'tcb-elem-placeholder' );
									},
									/**
									 * Update all controls or just a single one
									 *
									 * @param {String} [control] optional. If not passed it will update all controls
									 */
									update: function ( control ) {
										if ( typeof control !== 'undefined' ) {
											if ( this.controls[control] ) {
												this.controls[control].update( this.controls[control].applyTo() );
											}
											return;
										}
										this.before_update();
										$.each( this.controls, function ( key, control ) {
											control.update( control.readFrom() );
										} );
										this.after_update();
									},
									/**
									 * Apply the config to all the controls from this element
									 * @param config
									 * @param {Boolean} [skip_update] Allows skipping the call to update() on the control
									 */
									setConfig: function ( config, skip_update ) {
										if ( ! skip_update ) {
											this.before_update();
										}
										$.each( this.controls, function ( control, view ) {
											view.setConfig( config[control] || {}, config.to, config.css_suffix );
											if ( ! skip_update ) {
												view.update( view.readFrom() );
											}
										} );
										if ( ! skip_update ) {
											this.after_update();
										}
									},
									disable_controls: function ( disabled_controls ) {
										this.$( '.control-hide' ).removeClass( 'control-hide' );
										_.each( disabled_controls, function ( ctrl ) {
											if ( this.controls && this.controls[ctrl] ) {
												this.controls[ctrl].$el.addClass( 'control-hide' );
											} else {
												this.$( ctrl ).addClass( 'control-hide' );
											}
										}, this );
										if ( typeof this.disable_extra_controls === 'function' ) {
											this.disable_extra_controls( disabled_controls );
										}
									},
									controls_init: function ( controls ) {
									},
									toggleControls: function ( e ) {
										var _type = TVE._type( TVE.ActiveElement ),
											prop = e.currentTarget.getAttribute( 'data-prop' );

										tcb_main_const.display[_type][this.key][prop] = ! tcb_main_const.display[_type][this.key][prop];
										storage.setComponentMeta( _type, this.key, prop, tcb_main_const.display[_type][this.key][prop] );

										this.toggleDropdown( prop );
									},
									change_state: function ( state ) {
									},
									reinit: function () {
									},
									reset: function () {
									},
									/**
									 * Toggle show/hide the dropdown content for either docked or advanced area.
									 * @param type {String} docked/advanced
									 * @param [display] {Boolean}  show or hide. if it's undefined we'll just toggle
									 */
									toggleDropdown: function ( type, display ) {
										if ( typeof type === 'undefined' ) {
											return;
										}

										if ( typeof this['docked'] === 'undefined' ) {
											this['docked'] = this.$el.find( '.dropdown-header[data-prop="docked"]' );
										} else if ( typeof this['advanced'] === 'undefined' ) {
											this['advanced'] = this.$el.find( '.dropdown-header[data-prop="advanced"]' );
										} else {
											this[type] = this.$el.find( '.dropdown-header[data-prop="' + type + '"]' );
										}

										if ( typeof display === 'undefined' ) {
											this[type].toggleClass( 'open' );
											var $expanded = this[type].siblings( '.dropdown-content' ),
												is_open = this[type].hasClass( 'open' );

											$expanded.slideToggle( 'fast', function () {
												if ( is_open ) {
													TVE.main.scroll_panel_to( $expanded );
												}
											} );
										} else {
											/* add or remove the open class for the specified dropdown */
											this[type][display ? 'addClass' : 'removeClass']( 'open' );

											/* for the specified dropdown, show or hide the content */
											this[type].siblings( '.dropdown-content' )[display ? 'show' : 'hide']();
										}
									},
									/**
									 * Map a callback function on each of the controls
									 *
									 * @param {*} cb
									 */
									map: function ( cb ) {
										var args = Array.prototype.slice.call( arguments, 1 );
										return _.each( this.controls, function ( ctrl ) {
											if ( typeof cb === 'string' && ctrl[cb] ) {
												ctrl[cb].apply( ctrl, args );
											} else if ( typeof cb === 'function' ) {
												cb( ctrl );
											}
										} );
									},
									/**
									 * Check if the current element needs update (migration to TCB2)
									 * @param $element
									 * @returns {boolean}
									 */
									needs_update: function ( $element ) {
										return false;
									},
									/**
									 * Called before updating the controls
									 */
									before_update: function () {
									},
									/**
									 * Called after all controls have had their update() function called
									 */
									after_update: function () {
									}
								} );

							})( jQuery );

							module.exports = {
								base_view: baseView,
								base_view_model: viewModelBase,
								control: controlBase,
								component: componentBase
							};
						},
						"components": {
							"animation": {
								"css-animation.js": function (exports, module, require) {
									var event_manager = require( '../../../libs/event-manager' );

									module.exports = require( '../../base' ).component.extend( {
										controls_init: function () {
											this.$trigger = this.$( '#anim-trigger' );
											this.$loop = this.$( '.anim-loop' );
											this.$anim = this.$( '#anim-animation' );
										},
										set_model: function ( model ) {
											this.model = typeof model !== 'undefined' ? model : new Backbone.Model( {t: 'tve-viewport', config: {anim: 'slide_top'}} );
											this.event_trigger = this.model.get( 't' );
											this.$loop.prop( 'checked', ! ! this.model.get( 'config' ).loop );
											this.selected = this.model.get( 'config' ).anim;
											this.$anim.val( this.selected );

											this.handle_triggers( this.options.actions[this.key].triggers[this.selected] || ['tve-viewport'] );

											return this;
										},
										reset: function () {
											this.handle_triggers( ['tve-viewport'] );
											this.$anim.val( this.$anim.find( 'option' ).first().val() ).trigger( 'change' );
											this.$loop.prop( 'checked', false );
											return this;
										},
										select: function ( e, select ) {
											this.selected = this.$( select ).val();
											this.handle_triggers( this.options.actions[this.key].triggers[this.selected] || ['tve-viewport'] );
											this._preview( this.selected );

											return false;
										},
										change_trigger: function ( e, select ) {
											this.event_trigger = this.$( select ).val() || 'tve-viewport';
											return false;
										},
										/**
										 * Render the select dropdown with triggers
										 *
										 * @param {Array} triggers
										 */
										handle_triggers: function ( triggers ) {
											var $select = this.$trigger.hide().find( 'select' ).empty();
											_.each( triggers, function ( t ) {
												$select.append( '<option value="' + t + '">' + this.component.options.triggers[t].name + '</option>' );
											}, this );
											if ( triggers.length !== 1 ) {
												this.$trigger.show();
											}
											if ( this.event_trigger ) {
												$select.val( this.event_trigger );
											}
											$select.trigger( 'change' );
										},
										validate: function () {
											if ( this.selected ) {
												return true;
											}
											TVE.page_message( TVE.t.anim.missing, true )

											return false;
										},
										apply_settings: function ( $element ) {
											if ( ! this.validate() ) {
												return false;
											}
											this.model.set( {
												a: this.key,
												t: this.event_trigger,
												config: {
													anim: this.selected,
													loop: this.$loop.prop( 'checked' ) ? 1 : 0
												}
											} );
											return true;
										},
										_preview: function ( anim, $element ) {
											$element = $element || this.component.$element;
											if ( ! $element || ! $element.length ) {
												return;
											}
											var $target = $element.closest( '.thrv_wrapper' ),
												o_class = $target.attr( 'class' );

											$target.removeClass( event_manager.remove_classes );
											$target.addClass( 'tve_ea_thrive_animation tve_anim_' + anim ).addClass( 'anim-preview' ).css( {'visibility': 'hidden'} );
											setTimeout( function () {
												$target.css( 'visibility', '' );
												$target.addClass( 'tve_anim_start' );
												setTimeout( function () {
													$target.attr( 'class', o_class ).removeClass( 'anim-preview' );
												}, 1000 );
											}, 400 );
										},
										preview: function ( model, $element ) {
											this._preview( model.get( 'config' ).anim, $element );
										}
									} );
								},
								"image-zoom.js": function (exports, module, require) {
									var base = require( '../../base' ),
										FilePickerCtrl = require( '../../controls/file' );

									module.exports = require( '../../base' ).component.extend( {
										controls_init: function () {
											this.picker = new FilePickerCtrl( {
												labels: {
													choose: TVE.t.ChooseImage
												}
											} );
											this.$el.append( this.picker.$el );
											this.picker.on( 'select', _.bind( this.on_select, this ) );
											this.picker.on( 'remove', _.bind( this.on_remove, this ) );
										},
										set_model: function ( model ) {
											this.model = typeof model !== 'undefined' ? model : new Backbone.Model( {config: {}} );
											this.config = _.extend( {}, this.model.get( 'config' ) );
											if ( ! this.config || ( ! this.config.title ) ) {
												/* this is an "old-style" image zoom */
												var $img = this.get_image_element();
												if ( $img && $img.attr( 'src' ) ) {
													this.config = {
														title: $img.attr( 'src' ).split( '/' ).pop()
													};
													if ( $img.attr( 'data-id' ) ) {
														this.config.id = $img.attr( 'data-id' );
														this.config.size = 'full';
													}
												}
											}
											this.picker.set( this.config );

											return this;
										},
										on_select: function ( attachment ) {
											this.config = {
												id: attachment.id,
												size: attachment.size || 'full',
												title: attachment.title
											};
										},
										on_remove: function () {
											this.config = {};
										},
										validate: function () {
											if ( this.config && this.config.title ) {
												return true;
											}
											TVE.page_message( TVE.t.anim.img_missing, true );

											return false;
										},
										apply_settings: function () {
											if ( this.validate() !== true ) {
												return false;
											}
											this.model.set( {
												a: this.key,
												t: 'click',
												config: _.extend( {}, this.config )
											} );
											TVE.Components.image.update( 'ImageFullSize' );
											return true;
										},

										/**
										 * Checks if the element being edited is an image and, if true, return it
										 * Used in backwards compatibility checks for Image Zoom action
										 *
										 * @returns {jQuery|boolean} jQuery element if the current element is an image, false otherwise
										 */
										get_image_element: function () {
											if ( this.component.$element.is( 'img' ) ) {
												return this.component.$element;
											}
											var $img = this.component.$element.find( 'img' );
											return $img.length ? $img : false;
										}
									} );
								},
								"link.js": function (exports, module, require) {
									var base = require( '../../base' ),
										modal = require( '../../modals/base' )
									LinkSearch = require( '../../controls/link' );

									module.exports = base.component.extend( {
										controls_init: function () {
											var self = this;
											this.search = new LinkSearch( {
												el: this.$( '#a-link-main' )[0]
											} );
											this.search.on( 'linkchange', function ( val ) {
												self.data.href = val;
											} );
											this.modal = new modal.base( {
												el: modal.get_element( 'options-post-types' )
											} );
											this.modal.save = function () {
												var params = TVE.ajax_data( 'save_link_post_types', 'post', {post_types: this.checkbox_values( '.post-type' )} );
												jQuery.ajax( params ).done( function ( response ) {
													TVE.page_message( response.message );
												} );
												this.close();
											};
											this.data = {};
										},
										read_element: function ( $element ) {
											var $link = $element.closest( 'a[href]' );
											this.$element = null;
											if ( ! $link.length ) {
												return false;
											}

											this.$element = $link;
											var data = this._read( $link );
											if ( ! data.href || data.href === 'javascript:void(0)' ) {
												return false;
											}

											return data;
										},
										_read: function ( $link ) {
											return {
												a: 'link',
												t: 'link',
												href: $link.attr( 'href' ),
												target: $link.attr( 'target' ) || null,
												rel: $link.attr( 'rel' ) || 'noopener noreferrer'
											};
										},
										_apply: function ( data, $link ) {
											$link.attr( 'href', data.href );
											if ( ! data.target ) {
												$link.removeAttr( 'target' );
											} else {
												$link.attr( 'target', data.target );
											}
											var rel = 'noopener noreferrer';

											if ( ! data.rel ) {
												rel += ' ' + data.rel;
											}

											$link.attr( 'rel', rel );
										},
										validate: function () {
											if ( ! this.data || ! this.data.href ) {
												TVE.page_message( TVE.t.anim.url_miss, true );
												return false;
											}

											return true;
										},
										apply_settings: function () {
											if ( ! this.validate() ) {
												return false;
											}

											this.data.settings_applied = true;
											this.model.set( _.extend( {}, this.data ) );

											var self = this,
												$elem = this.component.$element,
												is_add = ! this.$element || ! this.$element.length || ( ! this.$element.attr( 'href' ) || this.$element.attr( 'href' ) === 'javascript:void(0)' ),
												create_node = ! this.$element || ! this.$element.length,
												prev_value = create_node ? null : this._read( this.$element ),
												current_value = _.extend( {}, this.data ),
												$target = create_node ? this.component.$element.wrapAll( '<a href=""></a>' ).parent() : this.$element,
												m = this.model,
												index = self.component.collection.indexOf( m );

											if ( create_node ) {
												$elem.attr( 'data-link-wrap', 1 );
											}

											this._apply( current_value, $target );
											TVE.UndoManager.add( {
												undo: function () {
													if ( create_node ) {
														$target.children().first().unwrap();
													} else {
														self._apply( prev_value, $target );
													}
													var c = $elem.data( 'anim_collection' );
													c.no_preview = c !== self.component.collection;
													if ( is_add ) {
														c.remove( m );
													} else {
														c.at( index ).set( prev_value );
														c.trigger( 'add' );
													}
													delete c.no_preview;
												},
												redo: function () {
													if ( create_node ) {
														$elem.wrapAll( '<a href=""></a>' );
														self.apply( current_value, $elem.parent() );
													} else {
														self._apply( current_value, $target );
													}
													var c = $elem.data( 'anim_collection' );
													c.no_preview = c !== self.component.collection;
													if ( is_add ) {
														c.add( m );
													} else {
														c.at( index ).set( current_value );
														c.trigger( 'add' );
													}
													delete c.no_preview;
												}
											} );

											return true;
										},
										remove: function ( model ) {
											var $elem = this.component.$element,
												remove_node = $elem.data( 'link-wrap' ),
												$target = $elem.closest( 'a[href]' ),
												self = this,
												index = this.component.collection.indexOf( model ),
												prev_values = this._read( $target );

											TVE.UndoManager.add( {
												undo: function () {
													if ( remove_node ) {
														$elem.wrap( '<a href=""></a>' );
														self._apply( prev_values, $elem.parent() );
													} else {
														self._apply( prev_values, $target );
													}
													var c = $elem.data( 'anim_collection' );
													c.no_preview = c !== self.component.collection;
													c.add( model, {at: index} );
													delete c.no_preview;
												},
												redo: function () {
													if ( remove_node ) {
														$elem.unwrap();
													} else {
														$target.attr( 'href', '' ).removeAttr( 'target' ).removeAttr( 'rel' );
													}
													var c = $elem.data( 'anim_collection' );
													c.no_preview = c !== self.component.collection;
													c.remove( c.at( index ) );
													delete c.no_preview;
												}
											} );

											if ( $elem.data( 'link-wrap' ) ) {
												$elem.unwrap();
											} else {
												$target.attr( 'href', '' ).removeAttr( 'target' ).removeAttr( 'rel' );
											}

											model.destroy();
										},
										attr: function ( e, checkbox ) {
											this.data[checkbox.getAttribute( 'data-attr' )] = checkbox.checked ? checkbox.value : null;

											return false;
										},
										set_model: function ( model ) {
											this.model = typeof model !== 'undefined' ? model : new Backbone.Model();
											this.data = {
												a: 'link',
												t: 'link',
												href: this.model.get( 'href' ) || '',
												target: this.model.get( 'target' ) || null,
												rel: this.model.get( 'rel' ) || 'noopener noreferrer'
											};
											this.dom();
											return this;
										},
										dom: function () {
											this.search.set_link( this.data.href );
											this.$( '.target' ).prop( 'checked', this.data.target === '_blank' );
											this.$( '.rel' ).prop( 'checked', this.data.rel && this.data.rel.indexOf( 'nofollow' ) !== -1 );
										},
										open_settings: function () {
											this.modal.open( {
												top: '20%',
												complete: _.bind( function () {
													this.search.focus();
												}, this )
											} );

											return false;
										}
									} );
								},
								"thrive-lightbox.js": function (exports, module, require) {
									var base = require( '../../base' ),
										List = require( '../../controls/list' );

									module.exports = require( '../../base' ).component.extend( {
										controls_init: function () {
											this.list = new List( {
												el: this.$( '#lb-container' )[0],
												items: this.options.actions.thrive_lightbox.data.lightboxes
											} );
											this.event_trigger = 'click';
											this.$animation = this.$( '#lb-animation' );
										},
										set_model: function ( model ) {
											this.model = typeof model !== 'undefined' ? model : new Backbone.Model( {'config': {}} );
											this.list.set_value( parseInt( this.model.get( 'config' ).l_id || 0 ) );
											this.$animation.val( this.model.get( 'config' ).l_anim || this.$animation.find( 'option' ).first().val() );

											return this;
										},
										reset: function () {
											this.list.select( '' );
											return this;
										},
										validate: function () {
											if ( ! this.list.get_value() ) {
												TVE.page_message( TVE.t.anim.lb_missing, true );

												return false;
											}

											return true;
										},
										apply_settings: function ( $element ) {
											if ( ! this.validate() ) {
												return false;
											}
											this.model.set( {
												a: this.key,
												t: this.event_trigger,
												config: {
													l_anim: this.$animation.val(),
													l_id: this.list.get_value()
												}
											} );
											return true;
										}
									} );
								},
								"tooltip.js": function (exports, module, require) {
									var base = require( '../../base' );

									module.exports = base.component.extend( {
										set_model: function ( model ) {
											this.model = typeof model !== 'undefined' ? model : new Backbone.Model( {config: {}} );
											this.config = _.extend( {}, this.model.get( 'config' ) );
											this.config.event_tooltip_position = this.config.event_tooltip_position || this.$( '#e-tooltip-position' ).val();
											this.config.event_tooltip_style = this.config.event_tooltip_style || this.$( '.t-style' ).val();
											this.dom();

											return this;
										},
										dom: function () {
											this.$( '#e-tooltip-text' ).val( this.config.event_tooltip_text || '' );
											this.$( '#e-tooltip-position' ).val( this.config.event_tooltip_position );
											this.$( '.t-style' ).val( this.config.event_tooltip_style );
										},
										text: function ( e, btn ) {
											this.config.event_tooltip_text = btn.value;
										},
										pos: function ( e, btn ) {
											this.config.event_tooltip_position = this.$( btn ).val();
										},
										style: function ( e, ctrl ) {
											this.config.event_tooltip_style = this.$( ctrl ).val();
										},
										validate: function () {
											if ( ! this.config.event_tooltip_text ) {
												TVE.page_message( TVE.t.anim.tooltip_miss, true );
												this.$( '#e-tooltip-text' ).focus();
												return false;
											}

											return true;
										},
										apply_settings: function () {
											if ( ! this.validate() ) {
												return false;
											}
											this.model.set( {
												a: this.key,
												t: 'mouseenter',
												config: _.extend( {}, this.config )
											} );

											return true;
										},
										preview: function ( event_model, $element ) {
											TVE.inner.jQuery( '.tve_ui_tooltip' ).remove();
											var config = event_model.get( 'config' ),
												base = TVE.inner.jQuery( '<div></div>', {
													'class': 'tve_ui_tooltip tve_tooltip_style_' + config.event_tooltip_style + ' tve_tooltip_position_' + config.event_tooltip_position
												} );
											base.text( config.event_tooltip_text )
												.appendTo( 'body' );
											var tooltip_width = base.outerWidth(),
												tooltip_height = base.outerHeight(),
												offset = 10,
												top = 0,
												left = 0;
											var rect = $element[0].getBoundingClientRect();
											switch ( config.event_tooltip_position ) {
												case 'top':
													left = (rect.right - rect.left - tooltip_width ) / 2 + rect.left;
													top = rect.top - tooltip_height - offset;
													break;
												case 'top_right':
													left = rect.right + offset;
													top = rect.top - tooltip_height - offset;
													break;
												case 'right':
													left = rect.right + offset;
													top = ( rect.bottom - rect.top - tooltip_height ) / 2 + rect.top;
													break;
												case 'bottom_right':
													left = rect.right + offset;
													top = rect.bottom + offset;
													break;
												case 'bottom':
													left = ( rect.right - rect.left - tooltip_width ) / 2 + rect.left;
													top = rect.bottom + offset;
													break;
												case 'bottom_left':
													left = rect.left - tooltip_width - offset;
													top = rect.bottom + offset;
													break;
												case 'left':
													left = rect.left - tooltip_width - offset;
													top = (rect.bottom - rect.top - tooltip_height ) / 2 + rect.top;
													break;
												case 'top_left':
													left = rect.left - tooltip_width - offset;
													top = rect.top - tooltip_height - offset;
													break;
												default:
													left = 1;
													top = 1;
													break;
											}
											base.css( {
												top: top + 'px',
												left: left + 'px'
											} );

											setTimeout( function () {
												TVE.inner.jQuery( '.tve_ui_tooltip' ).remove();
											}, 2000 );
										}
									} );
								},
								"video-popup.js": function (exports, module, require) {
									var base = require( '../../base' ),
										ColorPicker = require( '../../controls/color-picker' ),
										FilePickerCtrl = require( '../../controls/file' );

									module.exports = base.component.extend( {
										template: TVE.tpl( 'controls/video-settings' ),
										controls_init: function () {
											this.render();
											this.$source = this.$( '.v-source' );
											this.providers = {};
											this.$( '.v-settings' ).each( _.bind( function ( index, elem ) {
												var v = elem.getAttribute( 'data-view' );
												this.providers[v.toLowerCase()] = new TVE.VideoProviders[v]( {
													el: elem,
													key: v.toLowerCase(),
													control: this
												} );
											}, this ) );
										},
										/**
										 * Remove a provider
										 *
										 * @param provider
										 */
										remove_provider: function ( provider ) {
											delete this.providers[provider];
											this.$source.find( 'option[value="' + provider + '"]' ).remove();

											return this;
										},
										show_section: function () {
											_.each( this.providers, function ( p ) {
												p.$el.hide();
											} );
											if ( this.$source.val() ) {
												this.active_view = this.providers[this.$source.val()].show();
											}
										},
										set_model: function ( model ) {
											this.active_view = null;
											this.model = typeof model !== 'undefined' ? model : new Backbone.Model( {config: {}} );
											var config = _.extend( {}, this.model.get( 'config' ) );

											/* config.s = source */
											if ( config.s ) {
												this.$source.val( config.s );
												this.show_section();
												/* config.p = params */
												this.active_view.set_config( config.p );
											} else {
												this.reset();
											}

											return this;
										},
										reset: function () {
											this.active_view = null;
											this.$source.val( '' );
											this.show_section();
											_.each( this.providers, function ( view ) {
												view.reset && view.reset();
											} );
										},
										validate: function () {
											if ( ! this.active_view ) {
												TVE.page_message( TVE.t.anim.vs_missing, true );
												return false;
											}

											return this.active_view.validate();
										},
										apply_settings: function () {
											if ( ! this.validate() ) {
												return false;
											}
											this.model.set( this.get_data() );

											return true;
										},
										get_data: function () {
											return {
												a: this.key,
												t: 'click',
												config: {
													s: this.$source.val(),
													p: _.extend( {}, this.active_view.config )
												}
											};
										},
										get_provider: function ( provider ) {
											if ( this.providers[provider] ) {
												return this.providers[provider];
											}

											return null;
										},
										/**
										 *
										 * @param {String} destination the destination of this video. (e.g. background video)
										 *
										 * @returns {*}
										 */
										get_embed_code: function ( destination, queryString ) {
											if ( ! this.active_view ) {
												return '';
											}

											switch ( destination ) {
												case 'background':
													return this.active_view.get_background_embed();
												case 'responsive':
													return this.active_view.get_responsive_video( queryString );
											}

											return '';
										}
									} );
									TVE.VideoProviders = {};
									TVE.VideoProviders.Base = base.component.extend( {
										initialize: function ( attr ) {
											var self = this;
											this.config = {};
											/**
											 * bind listeners on [data-setting] elements
											 */
											this.$( 'input[data-setting],select[data-setting],textarea[data-setting]' ).on( 'change', function () {
												var setting = this.getAttribute( 'data-setting' ),
													$input = self.$( this ),
													value = $input.attr( 'type' ) == 'checkbox' ? $input.prop( 'checked' ) : $input.val();

												if ( typeof self['validate_' + setting] === 'function' && ! self['validate_' + setting]( value ) ) {
													return;
												}
												if ( value != self.config[setting] ) {
													self.config[setting] = value;
												}
											} );
											if ( typeof this.after_init === 'function' ) {
												this.after_init();
											}
											this.colorpicker();

											this.control = attr.control;
											this.key = attr.key;
										},
										colorpicker: function () {
											var $color = this.$( '.v-setting-color' );
											if ( ! $color.length ) {
												return this;
											}
											this.picker = new ColorPicker( {
												el: $color[0],
												model: {
													config: {
														options: {
															output: 'object',
															preferredFormat: 'hex',
															showInput: false,
															showGradient: false,
															showAlpha: false,
															allowEmpty: true
														}
													}
												},
												change: _.bind( this.color_change, this )
											} );

											return this;
										},
										color_change: function ( color ) {
											this.config.c = color ? color.toHexString().replace( '#', '' ) : '';
											// Trigger color change event on control
											this.control.trigger( 'color-change', color );
										},
										after_init: function () {
											this.$m = this.$( '.inline-message' );
										},
										message: function ( message, state ) {
											state = state || 'info';
											this.$m.removeClass( 'm-success m-info m-error' ).addClass( 'm-' + state ).empty();
											if ( state === 'success' || state === 'error' ) {
												message = TVE.icon( state === 'success' ? 'check' : 'close2' ) + '&nbsp;' + message;
											}
											this.$m.html( message );

											return this;
										},
										reset: function () {
											this.$( 'input[data-setting],select[data-setting]' ).not( 'input:checkbox' ).val( '' );
											/* Autoplay enabled by default */
											this.$( 'input:checkbox' ).prop( 'checked', false ).filter( '[data-setting="a"]' ).prop( 'checked', true ).trigger( 'change' );
											if ( this.$m ) {
												this.$m.empty();
											}
											if ( this.picker ) {
												this.picker.setValue( '' );
											}
										},
										set_config: function ( config ) {
											this.config = _.extend( {}, config || {} );
											if ( this.picker ) {
												this.picker.setValue( '#' + ( this.config.c || 'ffffff' ) );
											}
											this.dom();

											this.after_set_config();

											return this;
										},
										after_set_config: function () {
											this.url_valid = this.config.url ? true : false;
											/* Autoplay is enabled by default */
											if ( typeof this.config.a === 'undefined' ) {
												this.$( 'input[data-setting="a"]' ).prop( 'checked', true ).trigger( 'change' );
											}
										},
										/**
										 * Update DOM elements with values from this.config
										 */
										dom: function () {
											_.each( this.config, function ( value, setting ) {
												var $input = this.$( '[data-setting="' + setting + '"]' );
												if ( $input.attr( 'type' ) === 'checkbox' ) {
													$input.prop( 'checked', value ? true : false );
												} else {
													$input.val( value );
												}
											}, this );

											return this;
										},
										/**
										 * Validator for the video provider
										 *
										 * @returns {boolean}
										 */
										validate: function () {
											if ( ! this.config.url ) {
												TVE.page_message( TVE.t.missing_invalid_url, true );
												return false;
											}
											if ( ! this.url_valid ) {
												TVE.page_message( TVE.t.anim.vu_invalid, true );
												return false;
											}

											return true;
										},
										/**
										 * Get the background embed code for the video
										 *
										 * @return {String} the full embed code
										 */
										get_background_embed: function () {
											if ( ! this.url_valid ) {
												return '';
											}

											return '<iframe data-provider="' + this.key + '" src="' + this.get_background_embed_url() + '" frameborder="0" allowtransparency="true" style="display: block"></iframe>';
										},
										get_responsive_video: function ( queryString ) {

											if ( ! this.url_valid ) {
												return '';
											}

											return '<iframe data-code="' + this.config.id + '" data-provider="' + this.key + '" src="' + this.get_embed_url( queryString ) + '" data-src="' + this.get_embed_url( queryString ) + '" frameborder="0" allowfullscreen></iframe>'
										}
									} );
									TVE.VideoProviders.Youtube = TVE.VideoProviders.Base.extend( {
										api_key: 'AIzaSyD9QcdlSlJ2yEg2DmE_ULM2hZCxChaYMD8',
										/**
										 * get the youtube video id from an URL string
										 *
										 * @param url
										 * @returns {*}
										 */
										yt_id: function ( url ) {
											url = url || this.config.url;
											if ( ! url || ! url.length ) {
												return false;
											}

											return url.match( /^(?:https?:\/\/)?(?:www\.)?(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=))((\w|-){11})(?:\S+)?$/ ) ? RegExp.$1 : false;
										},
										/**
										 * triggered on change on the URL input field
										 * @returns {boolean}
										 */
										validate_url: function ( value ) {
											this.url_valid = false;

											if ( ! value ) {
												//TODO: translations
												this.message( 'You must provide a non-empty URL', 'error' );

												return false;
											}
											var yt_id = this.yt_id( value );
											if ( ! yt_id ) {
												this.message( TVE.t.anim.video_id_err, 'error' );

												return false;
											}
											this.message( 'Getting video information...', 'info' );
											/* fetch the video data from yt api */
											jQuery.getJSON( 'https://www.googleapis.com/youtube/v3/videos?part=snippet&id=' + yt_id + '&key=' + this.api_key )
											      .done( _.bind( function ( data ) {
												      var title = this.get_video_title( data );
												      if ( ! title ) {
													      this.message( TVE.t.anim.video_info_err, 'error' );
													      return;
												      }
												      this.url_valid = true;
												      this.config.id = yt_id;
												      this.message( title, 'success' );
												      this.control.trigger( 'change', this.control.get_data() );
											      }, this ) )
											      .fail( _.bind( function () {
												      this.message( TVE.t.anim.video_info_err, 'error' );
											      }, this ) );

											return true;
										},
										get_video_title: function ( response ) {
											if ( ! response || ! response.items || ! response.items.length || ! response.items[0].snippet || ! response.items[0].snippet.title ) {
												return false;
											}

											return response.items[0].snippet.title;
										},

										/**
										 * Return the full iframe URL according to the settings
										 *
										 */
										get_background_embed_url: function () {

											return 'https://www.youtube.com/embed/' + this.config.id + '?wmode=transparent&enablejsapi=1' +
											       '&rel=0&modestbranding=1&controls=0&showinfo=0&autoplay=1&fs=0';
										},
										get_embed_url: function ( queryString ) {
											queryString = typeof queryString === 'undefined' ? '' : queryString;

											return 'https://www.youtube.com/embed/' + this.config.id + queryString;
										}
									} );

									TVE.VideoProviders.Vimeo = TVE.VideoProviders.Base.extend( {
										validate_url: function ( value ) {
											this.url_valid = false;
											if ( ! value ) {
												this.message( TVE.t.missing_invalid_url, 'error' );

												return false;
											}
											this.message( 'Getting video information...', 'info' );
											jQuery.getJSON( 'https://vimeo.com/api/oembed.json?url=' + value )
											      .done( _.bind( function ( response ) {
												      if ( ! response || ! response.title || ! response.video_id ) {
													      this.message( TVE.t.anim.video_info_err, 'error' );

													      return false;
												      }
												      this.config.id = String( response.video_id );
												      this.url_valid = true;
												      this.message( (response.author_name ? ( response.author_name + ' - ' ) : '' ) + response.title, 'success' );
												      this.control.trigger( 'change', this.control.get_data() );
											      }, this ) )
											      .fail( _.bind( function () {
												      this.message( TVE.t.anim.video_info_err, 'error' );
											      }, this ) );

											return true;
										},
										get_background_embed_url: function () {
											return 'https://player.vimeo.com/video/' + this.config.id + '?loop=1&autoplay=1&background=1';
										},
										after_set_config: function () {
											if ( ! this.config.id && this.config.url ) {
												this.validate_url( this.config.url );
											} else if ( this.config.id ) {
												this.url_valid = true;
											}
										},
										get_embed_url: function ( queryString ) {
											queryString = typeof queryString === 'undefined' ? '' : queryString;

											return 'https://player.vimeo.com/video/' + this.config.id + queryString;
										}
									} );

									TVE.VideoProviders.Wistia = TVE.VideoProviders.Base.extend( {
										validate_url: function ( value ) {
											this.url_valid = false;
											if ( ! value ) {
												this.message( TVE.t.required_url, 'error' );

												return false;
											}
											var _id = this.video_id( value );
											if ( ! _id ) {
												this.message( TVE.t.anim.video_id_err, 'error' );
												return false;
											}
											this.config.id = _id;
											this.message( 'Getting video information...', 'info' );
											jQuery.getJSON( 'http://fast.wistia.net/oembed?url=' + value )
											      .done( _.bind( function ( response ) {
												      this.url_valid = true;
												      this.control.trigger( 'change', this.control.get_data() );
												      if ( ! response || ! response.title ) {
													      this.message( TVE.t.anim.wistia_info_warn, 'warning' );

													      return false;
												      }
												      this.message( response.title, 'success' );
											      }, this ) )
											      .fail( _.bind( function () {
												      this.message( TVE.t.anim.wistia_info_warn, 'warning' );
											      }, this ) );

											return true;
										},
										video_id: function ( url ) {
											var w = new RegExp( 'https?://(.+)?(wistia\.com|wi\.st)/(medias|embed)/(.+)' ),
												f = new RegExp( 'https?://(.+)?fast\.wistia\.net/embed/(.+?)/(.+)' );

											if ( url.match( w ) ) {
												return RegExp.$4;
											}

											if ( url.match( f ) ) {
												return RegExp.$3;
											}

											return false;
										},
										/**
										 * migrate old-style Wistia video popups to the new configuration
										 *
										 * @param {Object} event event configuration data
										 */
										migrate: function ( event ) {
											var config = event.config,
												_data = {
													a: 'thrive_video',
													t: 'click',
													config: {
														s: 'wistia',
														p: {
															url: config.event_video_url || '',
															c: ( config.event_video_color || '' ).replace( '#', '' ),
															p: config.event_option_play_bar ? true : false,
															cv: config.event_option_onload ? true : false,
															hfs: config.event_option_fs ? true : false,
															a: true
														}
													}
												};
											_data.config.p.id = this.video_id( _data.config.p.url );

											if ( ! _data.config.p.id ) {
												return false;
											}

											return _data;
										},
										/**
										 *
										 */
										get_background_embed: function () {
											if ( ! this.url_valid ) {
												return '';
											}
											return '<script src="//fast.wistia.com/embed/medias/' + this.config.id + '.jsonp" async></script>' +
											       '<script src="//fast.wistia.com/assets/external/E-v1.js" async></script>' +
											       '<div data-id="' + this.config.id + '" class="wistia_embed wmode=transparent playButton=false autoPlay=1 controlsVisibleOnLoad=0 fullscreenButton=0 volume=0 wistia_async_' + this.config.id + '" style="width: 100%;height: 100%">&nbsp;</div>';
										},
										get_embed_url: function ( queryString ) {
											queryString = typeof queryString === 'undefined' ? '' : queryString;

											return 'http://fast.wistia.net/embed/iframe/' + this.config.id + queryString;
										}
									} );
									TVE.VideoProviders.Custom = TVE.VideoProviders.Base.extend( {
										after_init: function () {
											this.file_picker = new FilePickerCtrl( {
												labels: {
													choose: TVE.t.ChooseVideo,
													title: TVE.t.Videos
												},
												config: {
													type: 'video'
												}
											} );

											this.$el.prepend( this.file_picker.$el );
											this.file_picker.on( 'select', _.bind( this.on_select, this ) )
											    .on( 'remove', _.bind( this.on_remove, this ) );
										},
										after_set_config: function () {
											TVE.VideoProviders.Base.prototype.after_set_config.apply( this, arguments );
											this.file_picker.set( this.config );
										},
										on_select: function ( attachment ) {
											this.attachment = attachment;
											this.config.id = attachment.id;
											this.config.title = attachment.title;

											this.control.trigger( 'change', this.control.get_data() );
										},
										on_remove: function () {
											this.config = {};
											this.attachment = null;
											this.control.trigger( 'change', this.control.get_data() );
										},
										validate: function () {
											if ( ! this.config.id ) {
												TVE.page_message( 'required_video', true );
												return false;
											}

											return true;
										},
										get_background_embed: function () {
											if ( ! this.attachment ) {
												return '';
											}
											return '<video playsinline autoplay muted loop class="tcb-bg-video" data-title="' + this.attachment.title + '" data-id="' + this.attachment.id + '">' +
											       '<source src="' + this.attachment.url + '" type="' + this.attachment.mime + '">' +
											       '</video>';
										},
										get_responsive_video: function ( queryString ) {
											if ( ! this.attachment && this.config.attachment ) {
												/**
												 * Comes form update component
												 */
												this.attachment = this.config.attachment;
											}

											if ( ! this.attachment ) {
												return '';
											}

											return '<video style="width: 100%;" playsinline class="tcb-responsive-video" data-title="' + this.attachment.title + '" data-id="' + this.attachment.id + '"  ' + queryString + '>' +
											       '<source src="' + this.attachment.url + '" type="' + this.attachment.mime + '">' +
											       '</video>';
										},
										reset: function () {
											this.file_picker.set( {} );
										}
									} );
								}
							},
							"animation.js": function (exports, module, require) {
								(function ( $ ) {
									var base = require( '../base' ),
										views = {},
										event_manager = require( '../../libs/event-manager' ),
										DropPanel = require( '../controls/drop-panel' );

									/**
									 * instantiate a view corresponding to an action
									 *
									 * @param {String} view
									 * @param {Object} params
									 * @private
									 */
									function _instantiate( view, params ) {
										var arr = view.split( '.' ),
											local = views,
											fn;

										for ( var i = 0, part; part = arr[i ++]; ) {
											if ( i === 1 ) {
												if ( local[part] ) {
													fn = local[part];
												} else {
													fn = window[part];
												}
												if ( ! fn ) {
													throw new Error( 'Could not instantiate: ' + view );
												}
												continue;
											}
											if ( ! fn[part] ) {
												throw new Error( 'Could not instantiate: ' + view );
											}
											fn = fn[part];
										}
										fn.prototype.after_init = function ( attr ) {
											if ( attr.key ) {
												this.key = attr.key;
											}
										};

										return new fn( params );
									}

									/**
									 * Holds a tab with multiple actions - each of the actions is represented as a radio button
									 */
									var ActionTab = DropPanel.extend( {
										template: $.noop,
										initialize: function ( attr ) {

											var $el = this.$el,
												self = this;
											this.actions = {};
											this.parent = attr.parent;
											this.$( '.action-settings' ).each( function () {
												var action_view = _instantiate( this.getAttribute( 'data-view' ), {
													el: this,
													options: attr.parent.options,
													key: this.getAttribute( 'data-action' )
												} );
												action_view.parent_tab = self;
												action_view.component = attr.parent;
												self.parent.views[this.getAttribute( 'data-action' )] = action_view;
												self.actions[this.getAttribute( 'data-action' )] = action_view;
											} );

											DropPanel.prototype.initialize.apply( this, arguments );

											this.$( '.popup-content' ).append( $el );
										},
										action_select: function ( e, btn ) {
											var value = _.isString( e ) ? e : btn.value;
											_.each( this.actions, function ( view ) {
												view.hide();
											} );
											this.$( '.action-chooser[value="' + value + '"]' ).prop( 'checked', true );
											if ( this.current_model && ! this.actions[value].model ) {
												this.actions[value].set_model( this.current_model );
											}
											this.actions[value].show();
											/**
											 * Make sure the body scroll bar does not jump when showing / hiding stuff
											 */
											var $panel = this.$( '.action-collection' );
											$panel.css( 'min-height', $panel.outerHeight() + 'px' );
											this.parent.active_view = this.actions[value];
										},
										state_add: function () {
											delete this.current_model;
											_.each( this.actions, function ( view ) {
												view.hide();
												view.set_model(); // this should trigger the reset() call
											} );
											if ( Object.keys( this.actions ).length === 1 ) {
												this.parent.active_view = this.actions[Object.keys( this.actions )[0]].show();
											}
											this.$( '.action-chooser:checked' ).trigger( 'change' );
											return this;
										},
										state_edit: function ( model ) {
											this.current_model = model;
											this.action_select( model.get( 'a' ) );
											return this;
										},
										cancel: function () {
											return this.parent.cancel.apply( this.parent, arguments );
										},
										apply: function () {
											return this.parent.apply.apply( this.parent, arguments );
										},
										onOpen: function () {
											this.parent.opened_tab = this;
										},
										validate: function () {
											if ( ! this.parent.active_view.apply_settings( this.parent.$element ) ) { // the view instance should handle the display of error messages
												return false;
											}

											return true;
										},
										show: function () {
											this.$( '.action-tab' ).show();
											this.visible = true;

											return DropPanel.prototype.show.call( this, arguments );
										}
									} );

									views.ThriveLightbox = require( './animation/thrive-lightbox' );
									views.Animation = require( './animation/css-animation' );
									views.VideoPopup = require( './animation/video-popup' );
									views.ImageZoom = require( './animation/image-zoom' );
									views.Tooltip = require( './animation/tooltip' );
									views.Link = require( './animation/link' );
									views.ActionDefault = base.component.extend( {
										set_model: function ( model ) {
											this.model = typeof model === 'undefined' ? new Backbone.Model() : model;

											return this;
										},
										apply_settings: function () {
											this.model.set( {
												a: this.key,
												t: this.component.options.actions[this.key] ? this.component.options.actions[this.key].trigger : 'click'
											} );

											return true;
										}
									} );

									module.exports =
										{
											views: views,
											component: base.component.extend( {
												migrate: {
													/**
													 * Migrate old-style wistia popups to the new style
													 * @param {Object} event
													 */
													thrive_wistia: function ( event ) {
														if ( ! this.views.thrive_video || ! this.views.thrive_video.get_provider( 'wistia' ) ) {
															/* invalid state */
															return false;
														}
														return this.views.thrive_video.get_provider( 'wistia' ).migrate( event );
													}
												},
												show_hide: function () {
													this.$tabs.show().removeClass( 'active' );
													_.each( this.options.tabs, function ( tab, tab_key ) {
														if ( ! tab.visible ) {
															this.$tabs.filter( '[data-value="' + tab_key + '"]' ).hide();
														}
													}, this );
													this.$sections.hide();
													this.$( '.action-item' ).show();
													_.each( this.options.actions, function ( data, key ) {
														if ( ! data.visible ) {
															this.$( '.action-settings[data-action="' + key + '"]' ).closest( '.action-item' ).hide();
														}
													}, this );
												},
												reinit: function () {
													this.show_hide();
													_.each( this.views, function ( view ) {
														if ( typeof view.reinit === 'function' ) {
															view.options = this.options;
															view.reinit();
														}
													}, this );
												},
												controls_init: function () {
													var self = this;
													this.tabs = {};
													this.views = {};
													this.$tabs = this.$( '#tcb-anim-buttons .tve-btn' );
													this.$sections = this.$( '.action-tab' ).each( function () {
														self.tabs[this.getAttribute( 'data-tab' )] = new ActionTab( {
															el: this,
															parent: self
														} );
													} );
													/* list of currently selected animations */
													this.$list = this.$( '#tcb-anim-list' );

													this.show_hide();
												},
												init_collection: function () {
													this.collection = this.$element.data( 'anim_collection' );
													if ( ! (this.collection instanceof Backbone.Collection) ) {
														this.collection = new Backbone.Collection();
														var $elem = this.$element,
															self = this;
														this.collection.$elem = $elem;
														function write() {
															self.event_write( $elem );
														}

														this.listenTo( this.collection, 'reset', this.render_preview );
														this.listenTo( this.collection, 'add', write );
														this.listenTo( this.collection, 'write_events', write );
														this.listenTo( this.collection, 'remove', write );

														$elem.data( 'anim_collection', this.collection );
													}
												},
												setInlineElement: function ( $element ) {
													this.$previous_element = this.$element;
													this.$element = $element;
													this.initAll();
												},
												restoreInlineElement: function () {
													this.setConfig( {} );
												},
												/**
												 * Called when an element is selected
												 *
												 * @param config
												 */
												setConfig: function ( config ) {
													this.$element = config.to ? TVE.ActiveElement.find( config.to ) : TVE.ActiveElement;
													this.initAll();
												},
												update: function() {
													this.initAll();
												},
												initAll: function () {
													if ( ! this.$element ) {
														return;
													}
													this.element_events = event_manager.read( this.$element );
													var has_outdated_events = this.ensure_bc();
													/* check for link */
													if ( this.views.link ) {
														var link_data = this.views.link.read_element( this.$element );
														if ( link_data ) {
															link_data.skip_save = true;
															this.element_events.push( link_data );
														}
													}

													this.init_collection();

													this.collection.reset( this.element_events );
													if ( has_outdated_events ) {
														this.collection.trigger( 'write_events' );
													}
												},
												/**
												 * This makes sure the events are backwards compatible.
												 * E.g. the 'thrive_wistia' event is no longer used. Instead, it is added as a sub-option of the 'video_popup' event
												 */
												ensure_bc: function () {
													var has_migration = false,
														has_outdated = false;
													do {
														has_migration = false;
														for ( var i = 0, event; event = this.element_events[i ++]; ) {
															if ( typeof this.migrate[event.a] !== 'undefined' ) {
																this.element_events[i - 1] = this.migrate[event.a].call( this, event );
																has_migration = true;
																has_outdated = true;
																break;
															}
														}
														if ( has_migration ) {
															this.element_events = this.element_events.filter( function ( item ) {
																return item !== false;
															} );
														}
													} while ( has_migration );

													return has_outdated;
												},
												/**
												 * Called on each add / remove on collection
												 */
												event_write: function ( $elem ) {
													event_manager.write( $elem.data( 'anim_collection' ).toJSON(), $elem );
													if ( ! $elem.data( 'anim_collection' ).no_preview ) {
														this.render_preview();
													}
												},
												/**
												 * Render the preview section based on every event of the element
												 */
												render_preview: function () {
													this.$list.empty();
													var tpl = TVE.tpl( 'animation/preview' );
													if ( ! this.collection.length ) {
														this.$list.append( tpl( {preview_none: true} ) );
														return;
													}
													this.collection.each( function ( item, i ) {
														this.$list.append( tpl( {
															preview_none: false,
															action: item.get( 'a' ),
															trigger: item.get( 't' ),
															trigger_text: this.get_trigger_text( item ),
															action_text: this.get_action_text( item ),
															has_preview: typeof this.views[item.get( 'a' )].preview === 'function',
															i: i
														} ) );
													}, this );
												},
												get_label: function ( labels, config ) {
													if ( ! labels ) {
														return '_no_label';
													}
													if ( _.isString( labels ) ) {
														return TVE.truncate( labels );
													}

													if ( labels.__config_key ) {
														return TVE.truncate( labels[config[labels.__config_key]] );
													}
												},
												get_action_text: function ( model ) {
													if ( ! model.get( 'a' ) ) {
														return '';
													}
													if ( model.get( 'a' ) === 'link' ) {
														return model.get( 'href' );
													}

													return this.get_label( this.options.actions[model.get( 'a' )].labels, model.get( 'config' ) );
												},
												get_trigger_text: function ( model ) {
													if ( ! model.get( 't' ) ) {
														return '';
													}
													if ( model.get( 'a' ) === 'link' ) {
														return TVE.t.Link;
													}
													return this.options.triggers[model.get( 't' )].label;
												},
												/**
												 * Show the corresponding settings section for the clicked tab
												 *
												 * @param e
												 * @param btn
												 * @returns {boolean}
												 */
												tab_click: function ( e, btn ) {
													if ( btn.className.indexOf( 'active' ) !== - 1 ) {
														this.opened_tab && this.opened_tab.onCancel();
														btn.classList.remove( 'active' );
														this.$sections.hide();
														return false;
													}
													this.opened_tab && this.opened_tab.onCancel();
													this.$tabs.removeClass( 'active' );
													btn.classList.add( 'active' );
													this.$sections.hide().filter( '.action-' + btn.getAttribute( 'data-value' ) ).show();
													this.tabs[btn.getAttribute( 'data-value' )].open( null, btn );
													this.tabs[btn.getAttribute( 'data-value' )].state_add(); // enter the "add" state

													return false;
												},
												cancel: function ( e ) {
													this.$tabs.removeClass( 'active' );
												},
												edit: function ( e, btn ) {
													this.$sections.hide();
													var index = btn.getAttribute( 'data-index' ),
														model = this.collection.at( index ),
														$row = this.$( btn ).closest( '.animation-item' );

													model.index = index;
													if ( model.get( 'elementType' ) ) {
														model.unset( 'elementType' );
													}

													this.find_tab( model.get( 'a' ) ).show().state_edit( model ).position( btn );
													this.active_view = this.views[model.get( 'a' )].set_model( model ).show();
												},
												preview: function ( e, btn ) {
													var index = btn.getAttribute( 'data-index' ),
														model = this.collection.at( index );
													this.views[model.get( 'a' )].preview( model, this.$element, btn );
													return false;
												},
												/**
												 * Check if the current configuration contains an action
												 *
												 * @param trigger
												 * @param action
												 * @returns {boolean}
												 */
												has_action: function ( trigger, action ) {
													return this.collection.findWhere( {t: trigger, a: action} ) ? true : false;
												},
												/**
												 * External entry point for adding a new action
												 *
												 * @param {String} trigger
												 * @param {String} action
												 * @param {Object} [config]
												 */
												add_action: function ( trigger, action, config ) {
													return this._handle_save( new Backbone.Model( {
														t: trigger,
														a: action,
														c: config || {}
													} ) );
												},
												/**
												 * Remove an action from the collection
												 *
												 * @param trigger
												 * @param action
												 */
												remove_action: function ( trigger, action ) {
													var found = this.collection.findWhere( {t: trigger, a: action} );
													if ( found ) {
														this._handle_remove( found );
													}
												},
												/**
												 * Handle add / edit actions
												 *
												 * @param {Backbone.Model} model action model instance
												 * @param {Object} [prev_value] optional, used just for edits
												 *
												 * @private
												 */
												_handle_save: function ( model, prev_value ) {
													var is_add = typeof model.index === 'undefined',
														index = model.index,
														current_value = _.extend( {}, model.toJSON() ),
														existing,
														self = this;
													if ( is_add ) {
														existing = this.collection.findWhere( {t: model.get( 't' )} );
														/* if another action for the same trigger exists, replace it instead of adding a new one */
														if ( existing ) {
															is_add = false;
															index = this.collection.indexOf( existing );
															prev_value = _.extend( {}, existing.toJSON() );
															existing.set( current_value );
															TVE.page_message( TVE.t.anim.evt_replaced );
														}
													}

													if ( ! is_add ) { // For the edit operation - just trigger an event on the collection to re-render the preview and update the DOM
														this.collection.trigger( 'add' );
													} else {
														this.collection.add( model );
													}

													/**
													 * allow model to short-circuit the save
													 */
													if ( model.get( 'settings_applied' ) ) {
														return true;
													}
													var $elem = self.$element;

													TVE.UndoManager.add( {
														undo: function () {
															var c = $elem.data( 'anim_collection' );
															c.no_preview = c !== self.collection;
															if ( is_add ) {
																c.remove( model );
															} else {
																c.at( index ).set( prev_value );
																c.trigger( 'add' );
															}
															delete c.no_preview;
														},
														redo: function () {
															var c = $elem.data( 'anim_collection' );
															c.no_preview = c !== self.collection;
															if ( is_add ) {
																c.add( model );
															} else {
																c.at( index ).set( current_value );
																c.trigger( 'add' );
															}
															delete c.no_preview;
														}
													} );
												},
												/**
												 * Handles the removal of an action
												 * @param {Backbone.Model} model
												 * @private
												 */
												_handle_remove: function ( model ) {
													var self = this,
														index = this.collection.indexOf( model ),
														$elem = self.$element;

													if ( model.get( 'a' ) === 'link' && this.views.link ) {

														this.views.link.remove( model );
														return false;
													}

													TVE.UndoManager.add( {
														undo: function () {
															var c = $elem.data( 'anim_collection' );
															c.no_preview = c !== self.collection;
															c.add( model, {at: index} );
															delete c.no_preview;
														},
														redo: function () {
															var c = $elem.data( 'anim_collection' );
															c.no_preview = c !== self.collection;
															c.remove( c.at( index ) );
															delete c.no_preview;
														}
													} );

													model.destroy();
												},
												apply: function ( e, btn ) {
													var prev_value = _.extend( {}, this.active_view.model.attributes );

													this._handle_save( this.active_view.model, prev_value );
													this.active_view = null;
													this.cancel();
													return false;
												},
												find_tab: function ( action ) {
													return this.views[action].parent_tab;
												},
												remove: function ( e, btn ) {
													var index = btn.getAttribute( 'data-index' ),
														model = this.collection.at( index );

													this._handle_remove( model );

													TVE.Components.image.update( 'ImageFullSize' );
													DropPanel.close_all();

													return false;
												},
												/**
												 * Called when changing the active element, it hill hide all tabs and enter the default state
												 */
												reset: function () {
													this.cancel();
												}
											} )
										};
								})( jQuery );
							},
							"background.js": function (exports, module, require) {
								var BaseModel = require( '../../models/base' ),
									GradientCollection = require( '../../collections/gradient' ),
									base = require( '../base' ),
									gradient_parse = require( '../../libs/gradient-parser' ),
									gradient_build = require( '../../libs/gradient-builder' ),
									ButtonPanelGroup = require( '../controls/button-panel-group' ),
									SolidColor = require( '../controls/background/solid' ),
									BackgroundImage = require( '../controls/background/image' ),
									Gradient = require( '../controls/background/gradient' ),
									GradientPattern = require( '../controls/background/gradient-pattern' ),
									bg_image_collection = new GradientCollection();

								module.exports = base.component.extend( {
									extra_states: true,
									/**
									 * Initializes all controls
									 */
									controls_init: function () {
										this.init_layers();
										this.controls.PreviewList.attach_collection( bg_image_collection );
										this.controls.PreviewList.on( 'item_click', _.bind( this.edit_layer, this ) );

										this.listenTo( bg_image_collection, 'add', this.apply_css );
										this.listenTo( bg_image_collection, 'remove', this.apply_css );
										this.listenTo( bg_image_collection, 'change', this.apply_css );

										this.controls.PreviewList.get_items = _.bind( function ( $element ) {
											var items = gradient_parse( $element.css( 'background-image' ) ),
												sizes = ( $element.css( 'background-size' ) || '' ).split( ',' ),
												attachments = ( $element.css( 'background-attachment' ) || '' ).split( ',' ),
												positions = ( $element.css( 'background-position' ) || '' ).split( ',' ),
												repeats = ( $element.css( 'background-repeat' ) || '' ).split( ',' );

											items.forEach( function ( item, index ) {
												items[index].size = sizes[index] || 'auto auto';
												items[index].attachment = attachments[index] || 'scroll';
												items[index].repeat = repeats[index] || 'scroll';
												items[index].position = positions[index] || 'scroll';
											} );

											return items;
										}, this );

										this.controls.ColorPicker.input = function ( color ) {
											if ( color ) {
												color += '!important';
											}
											this.applyTo().head_css( {'background-color': color}, false, this.config.css_suffix, false, this.config.css_prefix );
										};

										this.controls.ColorPicker.update = function ( $element ) {
											this.read_background( $element );
										};
									},
									/**
									 * Init the Background layers button group
									 */
									init_layers: function () {
										this.tabs = new ButtonPanelGroup( {
											el: this.$( '.gradient-layers' )[0],
											buttons: this.buttons(),
											label: TVE.t.Add_Layer
										} );
										this.tabs.on( 'open', _.bind( this.add_layer, this ) );
									},
									/**
									 * Setup the data for the opened panel
									 *
									 * @param {DropPanel} panel
									 */
									add_layer: function ( panel ) {

										TVE.SKIP_CSS_STATE = true;
										/* save initial state for the undo manager */
										TVE.UndoManager.temp.set( this.controls.PreviewList.applyTo(), this.get_css() );

										var model = new BaseModel( panel.get_default_data() );
										model.set( '__new', true );
										bg_image_collection.add( model );
										model.saveState();

										panel.reset( model );

										return false;
									},
									/**
									 * Edit a background-image row
									 *
									 * @param model
									 * @param row
									 */
									edit_layer: function ( model, row ) {
										TVE.SKIP_CSS_STATE = true;
										/* save initial state for the undo manager */
										TVE.UndoManager.temp.set( this.controls.PreviewList.applyTo(), this.get_css() );
										var type = model.get( 'type' ),
											key = ( type === 'linear-gradient' || type === 'radial-gradient' ) ? 'gradient' : type,
											control = this.tabs.panel( key );

										if ( control.isOpen() ) {
											control.onCancel();
											return false;
										}
										model.saveState();
										control.reset( model );
										control.open( null, row );

										return false;
									},
									/**
									 * Applies the CSS background-image properties
									 */
									apply_css: function () {
										var config = this.controls.PreviewList.config;
										this.controls.PreviewList.applyTo().head_css( this.get_css(), null, config.css_suffix, true, config.css_prefix );
									},
									/**
									 * Get all required CSS rules to apply to the element
									 */
									get_css: function () {
										var items = bg_image_collection.toJSON();

										return {
											'background-image': gradient_build( items ) + ' !important',
											'background-size': _.map( items, function ( item ) {
												return item.size || 'auto auto'
											} ).join( ',' ) + ' !important',
											'background-position': _.map( items, function ( item ) {
												return item.position || '0 0';
											} ).join( ',' ) + ' !important',
											'background-attachment': _.map( items, function ( item ) {
												return item.attachment || 'scroll';
											} ).join( ',' ) + ' !important',
											'background-repeat': _.map( items, function ( item ) {
												return item.repeat || 'no-repeat';
											} ).join( ',' ) + ' !important'
										};
									},
									/**
									 * Buttons configuration for the button group
									 *
									 * @returns {*}
									 */
									buttons: function () {
										return {
											solid: {
												icon: 'color',
												title: TVE.t.solid_color,
												panel: new SolidColor( {
													collection: bg_image_collection
												} )
											},
											url: {
												icon: 'img',
												class: 'icon-medium padded',
												title: TVE.t.image,
												icon_type: 'svg',
												panel: new BackgroundImage( {
													collection: bg_image_collection
												} )
											},
											gradient: {
												icon: 'gradient',
												title: TVE.t.gradient,
												panel: new Gradient( {
													collection: bg_image_collection
												} )
											},
											pattern: {
												icon: 'stripes',
												title: TVE.t.pattern,
												panel: new GradientPattern( {
													collection: bg_image_collection
												} )
											}
										};
									},
									/**
									 * Get the View constructor for the Video control
									 *
									 * @returns {*}
									 */
									video: function () {
										return require( '../controls/background/video' );
									}
								} );
							},
							"borders-corners.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.component.extend({
									extra_states: true
								});
							},
							"button.js": function (exports, module, require) {
								var base = require( '../base' ),
									apply = require( '../../libs/element-snapshot' );

								var IconsModal = require( '../modals/icons' );

								var LINK_CLASS = ' .tcb-button-link',
									ICON_CLASS = ' .tcb-button-icon',
									SEC_TEXT_CLASS = ' .tcb-secondary-text',
									DEFAULT_ICON = '<span class="tcb-button-icon"><svg data-name="credit-card" class="tcb-icon" version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 18 14" xml:space="preserve" preserveAspectRatio="none slice"><g><path d="M17.5,1.9v10.6c0,0.8-0.6,1.4-1.4,1.4h-14c-0.8,0-1.4-0.6-1.4-1.4V1.9c0-0.8,0.6-1.4,1.4-1.4h14 C16.9,0.5,17.5,1.1,17.5,1.9z M1.9,1.9v2h14.5v-2c0-0.1-0.1-0.3-0.3-0.3h-14C2,1.6,1.9,1.7,1.9,1.9z M16.4,12.5V7.2H1.9v5.3 c0,0.1,0.1,0.3,0.3,0.3h14C16.3,12.8,16.4,12.6,16.4,12.5z M3,10.5h2.2v1.1H3V10.5z M6.3,10.5h3.4v1.1H6.3V10.5z"/></g></svg></span>';

								function link( $element ) {
									return $element.find( LINK_CLASS );
								}

								function icon( $element ) {
									return $element.find( ICON_CLASS );
								}

								function secondary_text( $element ) {
									return $element.find( SEC_TEXT_CLASS );
								}

								module.exports = base.component.extend( {
									extra_states: true,
									needs_update: function ( $element ) {
										return $element.hasClass( 'thrv_button_shortcode' );
									},
									migrate_element: function ( $element ) {
										var i = ' !important';
										var main_class = 'thrv_wrapper thrv-button',
											$button = $element.find( '.tve_btn' ),
											$link = $element.find( 'a' ),
											$iTag = $element.find( 'i' ),
											$divider = $element.find( '.tve_btn_divider' ),
											iconBg = $iTag.css( 'background-image' ),
											mainCSS, linkCSS, dividerCSS = {}, mainLinkCSS,
											margin_left = $button.css( 'margin-left' ),
											margin_right = $button.css( 'margin-right' );

										if ( $element.hasClass( 'tve_centerBtn' ) ) {
											margin_left = margin_right = 'auto';
										}
										mainCSS = {
											'min-width': $button.css( 'min-width' ),
											margin: [
												$button.css( 'margin-top' ), margin_right, $button.css( 'margin-bottom' ), margin_left
											].join( ' ' )
										};
										linkCSS = {
											'border-radius': $button.css( 'border-radius' ),
											'background-color': $button.css( 'background-color' ) + i,
											'background-image': $button.css( 'background-image' ) + i,
											'padding-top': $link.css( 'padding-top' ) + i,
											'padding-right': $link.css( 'padding-right' ) + i,
											'padding-bottom': $link.css( 'padding-bottom' ) + i,
											'padding-left': $link.css( 'padding-left' ) + i,
											'border-width': $button.css( 'border-width' ),
											'border-style': $button.css( 'border-style' ),
											'border-color': $button.css( 'border-color' )
										};
										mainLinkCSS = {
											'font-size': $link.css( 'font-size' ),
											'box-shadow': $button.css( 'box-shadow' )
										};

										if ( $divider.length && $divider.is( ':visible' ) && parseInt( $divider.css( 'width' ) ) > 0 && $divider.css( 'background-color' ) !== 'transparent' ) {
											main_class += ' tcb-with-divider';
											dividerCSS = {
												'background-color': $divider.css( 'background-color' ) + ' !important'
											};
										}
										$divider.remove();

										TVE.SKIP_CSS_STATE = true;

										$link.head_css( linkCSS );
										$element.head_css( mainCSS );
										$element.head_css( dividerCSS, null, ' .tcb-button-link > span::before' );
										$element.head_css( mainLinkCSS, null, ' .tcb-button-link' );

										TVE.SKIP_CSS_STATE = false;

										if ( $iTag.is( ':visible' ) && $iTag.attr( 'data-tve-icon' ) ) {
											main_class += ' tcb-with-icon';
										} else if ( iconBg && iconBg !== 'none' ) {
											main_class += ' tcb-with-icon';
											$iTag.css( {
												display: 'block',
												width: $iTag.width(),
												height: $iTag.height(),
												'background-image': iconBg,
												'background-size': 'hover',
												'margin-right': '10px'
											} );
										}

										$element.attr( 'class', main_class );

										$link.unwrap().attr( 'class', 'tcb-button-link' );
										$link.children( '.tve_btn_im' ).attr( 'class', 'tcb-button-icon' );
										$link.children( '.tve_btn_txt' ).wrap( '<span class="tcb-button-texts"></span>' ).attr( 'class', 'tcb-button-text thrv-inline-text' );

										$link.attr( 'rel', ( $link.attr( 'rel' ) || '' ) + ' noopener noreferrer' );
									},
									controls_init: function ( controls ) {
										var component = this;

										this.controls.type.input = function ( $element, dom ) {
											apply( function () {
												$element.toggleClass( 'tcb-with-icon', dom.dataset.value !== 'default' );
												if ( dom.dataset.value !== 'default' && ! $element.find( ICON_CLASS ).length ) {
													link( $element ).prepend( DEFAULT_ICON );
													controls.ModalPicker.update( $element );
												}
												$element.toggleClass( 'tcb-with-divider', dom.dataset.value === 'icon-divider' );
											}, $element );

											component.$( '.tcb-button-icon-controls' ).toggleClass( 'tcb-hidden', dom.dataset.value === 'default' );
											controls.DividerColor.$el.toggleClass( 'tcb-hidden', dom.dataset.value !== 'icon-divider' );

											TVE.Editor_Page.reposition_icons();
										};
										this.controls.type.update = function ( $element ) {
											var type = 'default';
											if ( $element.hasClass( 'tcb-with-divider' ) ) {
												type = 'icon-divider';
											} else if ( $element.hasClass( 'tcb-with-icon' ) ) {
												type = 'icon';
											}

											this.setActive( type );
											component.$( '.tcb-button-icon-controls' ).toggleClass( 'tcb-hidden', type === 'default' );
											controls.DividerColor.$el.toggleClass( 'tcb-hidden', type !== 'icon-divider' );
										};

										this.controls['icon_side'].input = function ( $element, dom ) {
											apply( function () {
												$element.toggleClass( 'tcb-flip', dom.dataset.value === 'right' );
											}, $element );
										};
										this.controls['icon_side'].update = function ( $element ) {
											this.setActive( $element.hasClass( 'tcb-flip' ) ? 'right' : 'left' );
										};

										this.controls['ButtonLink'].change = function ( value ) {
											value = TVE.addHttp( value );

											var $element = link( this.applyTo() );

											this.setValue( value );

											if ( TVE.isValidUrl( value ) || value === '' ) {
												apply( function () {
													$element.attr( 'href', value );
												}, $element.parent() );
												TVE.Components.animation.update();
											} else {
												TVE.page_message( TVE.t.UrlInvalid, true, 5000 );
											}
										};

										this.controls['ButtonLink'].update = function ( $element ) {
											this.setValue( link( $element ).attr( 'href' ) );
										};

										this.controls['LinkNewTab'].update = function ( $element ) {
											var target = link( $element ).attr( 'target' );
											if ( typeof target !== typeof undefined && target !== false && target === '_blank' ) {
												this.setChecked( true );
											} else {
												this.setChecked( false );
											}
										};

										this.controls['LinkNewTab'].change = function ( $element, dom ) {
											apply( function () {
												var $anchor = link( $element ),
													target = $anchor.attr( 'target' );
												if ( dom.checked ) {
													$anchor.attr( 'target', '_blank' );
												} else {
													$anchor.removeAttr( 'target' );
												}
											}, $element );
										};

										this.controls['LinkNoFollow'].update = function ( $element ) {
											var rel = link( $element ).attr( 'rel' );
											this.setChecked( typeof rel !== 'undefined' && rel && rel.indexOf( 'nofollow' ) !== - 1 );
										};

										this.controls['LinkNoFollow'].change = function ( $element, dom ) {
											apply( function () {
												link( $element ).attr( 'rel', dom.checked ? 'noopener noreferrer nofollow' : 'noopener noreferrer' );
											}, $element );
										};

										this.controls['ButtonColor'].change = function ( color ) {
											TVE.Components.background.controls.ColorPicker.input( color );
											TVE.Components.background.controls.ColorPicker.setValue( color );
										};

										this.controls['ButtonColor'].input = function ( color ) {
											TVE.Components.background.controls.ColorPicker.input( color );
										};

										this.controls['ButtonColor'].update = function () {
											this.read_background( link( this.applyTo() ) );
										};

										this.controls.DividerColor.input = function ( color ) {
											this.applyTo().head_css( {'background-color': color + ' !important'}, null, ' .tcb-button-link > span::before' );
										};

										this.controls.DividerColor.update = function ( $element ) {
											var color = $element.head_css( 'background-color', null, ' .tcb-button-link > span::before' );
											this.setValue( color );
										};

										this.controls['SecondaryText'].change = function ( $element, dom ) {
											apply( function () {
												if ( dom.checked ) {
													$element.append( '<span class="tcb-secondary-text thrv-inline-text">Secondary text</span>' );
												} else {
													secondary_text( $element ).remove();
												}
											}, $element.parent() );
										};

										this.controls['SecondaryText'].update = function ( $element ) {
											this.setChecked( secondary_text( $element ).length === 1 );
										};

										this.controls['ButtonSize'].input = function ( $element, dom ) {
											$element.head_css( {'min-width': dom.value + this.getUM()} );
										};

										this.controls['ButtonSize'].change = function ( $element, dom ) {
											$element.head_css( {'min-width': dom.value + this.getUM()} );
											TVE.Editor_Page.reposition_icons();
										};

										this.controls['ButtonSize'].update = function ( $element ) {
											var css = $element.css( 'min-width' );
											if ( ! css || css === '0px' ) {
												css = this.component.config['ButtonSize'].config.default + 'px';
											}
											this.setValue( css );
										};

										this.controls['FullWidth'].update = function ( $element ) {
											this.setChecked( $element.css( 'min-width' ) === '100%' );
											component.controls.ButtonSize.$el.toggleClass( 'tcb-hidden', this.isChecked() );
										};

										this.controls['FullWidth'].change = function ( $element, dom ) {
											$element.head_css( {'min-width': dom.checked ? '100%' : ''} );
											component.controls.ButtonSize.$el.toggleClass( 'tcb-hidden', dom.checked );
											component.controls.ButtonSize.update( $element );
											TVE.Editor_Page.reposition_icons();
										};

										/**
										 * Icon Modal
										 */
										this.controls.ModalPicker.setModal( IconsModal.get_instance( TVE.modal.get_element( 'icons' ) ) );

										/**
										 * Icon input function
										 *
										 * @param $element
										 * @param data
										 */
										this.controls['ModalPicker'].change = function ( $element, data ) {
											$element.removeClass( 'aligncenter' );

											apply( function () {
												var html;
												if ( data.icon.is( '.tve-svg-icon' ) ) {
													var $symbol = jQuery( 'symbol#' + data.icon.data( 'cls' ) );
													html = TVE.svg_icon( {
														path: $symbol.html(),
														viewBox: $symbol[0].getAttribute( 'viewBox' ),
														name: $symbol.find( '> title' ).text()
													} );
												} else {
													html = '<span data-name="' + data.icon.data( 'cls' ).replace( 'icon-', '' ) + '" class="tve_sc_icon ' + data.icon.data( 'cls' ) + '"></span>';
												}

												icon( $element ).html( html );
											}, $element );

											this.update( $element );
										};
										this.controls.ModalPicker.update = function ( $element ) {
											var _name = icon( $element ).children().first().attr( 'data-name' );
											this.updateValue( _name );
										};
									}
								} );
							},
							"cell.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.component.extend( {
									controls_init: function () {

										this.controls.width.update = function ( $element ) {
											this.setValue( $element.width() );
										};
										this.controls.width.input = function ( $element, dom ) {
											$element.__col.head_css( {'width': dom.value + this.getUM()}, null, '', false, '#tve_editor ' );
										};

										this.controls.height.update = function ( $element ) {
											this.setValue( $element.height() );
										};
										this.controls.height.input = function ( $element, dom ) {
											$element.__row.head_css( {'height': dom.value + this.getUM()}, null, '', false, '#tve_editor ' );
										};
										this.controls.height.change = function ( $element, dom ) {
											this.input( $element, dom );
											TVE.plugins.table.refresh();
										};

										this.controls.valign.update = function ( $element ) {
											this.setActive( $element.css( 'text-align' ) || '' );
										};
										this.controls.valign.change = function ( $element, dom ) {
											var value = this.getValue();
											$element.head_css( {'vertical-align': value}, null, '', false, '#tve_editor ' );
											this.readFrom().removeClass( 'tve_valign_top tve_valign_middle tve_valign_bottom' );
										};

									}
								} );
							},
							"click-tweet.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.component.extend( {
									template: TVE.tpl( 'controls/responsive' ),
									events: function () {
										return _.extend( base.component.prototype.events, {
											'keyup .tve-input-control': 'setTwitterCount',
											'keyup .tve-tweet-via-control input': 'setTwitterCount'
										} );
									},
									controls_init: function () {
										var self = this;

										this.controls['LabelText'].update = function () {
											var value = this.applyTo().find( '.thrv_tw_qs_button_text' ).html();

											this.setValue( self.stripHtml( value ) );
										};
										this.controls['LabelText'].change = function () {
											var $element = this.applyTo(),
												$label = $element.find( '.thrv_tw_qs_button_text' ),
												before = TVE.renderers.base.read_element_props( $element ),
												after;

											$label.html( self.stripHtml( this.$('input' ).val() ) );

											after = TVE.renderers.base.read_element_props( $element );
											self.addUndoManagerAction( $element, before, after );
										};

										this.controls['TweetText'].update = function ( $element ) {
											var value = $element.find( '.thrv_tw_quote' ).html(),
												text = self.stripHtml( value ).replace( /^\s+|\s+$/g, '' ),
												$label = $element.find( '.thrv_tw_qs_button_text' );

											this.setValue( text );
											self.setTwitterCount();
										};

										this.controls['TweetText'].input = function () {
											var text = self.stripHtml( this.$('textarea' ).val() ),
												$element = this.applyTo(),
												before = TVE.renderers.base.read_element_props( $element ),
												after;

											self.setTwitterCount();
											if ( $element.find( '.thrv_tw_quote p' ).hasClass( 'tve-froala' ) ) {
												$element.find( '.thrv_tw_quote p' ).froalaEditor( 'html.set', text );
											} else {
												$element.find( '.thrv_tw_quote p' ).html( text );
											}

											after = TVE.renderers.base.read_element_props( $element );
											self.addUndoManagerAction( $element, before, after );
										};

										this.controls['ShareUrlCheckbox'].update = function ( $element ) {
											var checked = $element.attr( 'data-use_custom_url' ) ? true : false;
											self.controls['ShareUrlInput'].$el.hide();
											if ( checked ) {
												self.controls['ShareUrlInput'].$el.show();
											}
											if ( this.isChecked() !== checked ) {
												this.setChecked( checked );
											}
										};
										this.controls['ShareUrlCheckbox'].change = function ( $element, dom ) {
											var before = TVE.renderers.base.read_element_props( $element ),
												after;

											if ( dom.checked ) {
												$element.attr( 'data-use_custom_url', true );
												self.controls['ShareUrlInput'].$el.show();
											} else {
												$element.attr( 'data-use_custom_url', '' );
												self.controls['ShareUrlInput'].$el.hide();
											}

											after = TVE.renderers.base.read_element_props( $element );
											self.addUndoManagerAction( $element, before, after );
										};

										this.controls['ShareUrlInput'].update = function ( $element ) {
											var value = $element.attr( 'data-custom_url' );
											this.setValue( value );
										};
										this.controls['ShareUrlInput'].change = function ( value ) {
											var $element = this.applyTo(),
												before = TVE.renderers.base.read_element_props( $element ),
												after;

											value = TVE.addHttp( value );
											this.setValue( value );
											if ( TVE.isValidUrl( value ) ) {
												$element.attr( 'data-custom_url', value );
											} else {
												TVE.page_message( TVE.t.UrlInvalid, true, 5000 );
											}

											after = TVE.renderers.base.read_element_props( $element );
											self.addUndoManagerAction( $element, before, after );
										};

										this.controls['ViaUsername'].update = function ( $element ) {
											var value = $element.attr( 'data-via' );
											this.setValue( value );
										};
										this.controls['ViaUsername'].change = function ( value ) {
											var $element = this.applyTo(),
												before = TVE.renderers.base.read_element_props( $element ),
												after;

											self.setTwitterCount();
											$element.attr( 'data-via', value );

											after = TVE.renderers.base.read_element_props( $element );
											self.addUndoManagerAction( $element, before, after );
										};
									},

									setTwitterCount: function () {
										var text = this.controls['TweetText'].getValue(),
											twitter_count = 116 - text.length,
											username = this.controls['ViaUsername'].getValue();

										if ( username.length ) {
											twitter_count -= 6 + username.length;
										}
										this.$( '.tve-twitter-count' ).html( twitter_count );
										this.$( '.tve-twitter-count' ).toggleClass( 'red', twitter_count < 0 );
									},

									stripHtml: function ( html ) {
										var tmp = document.createElement( "DIV" );
										tmp.innerHTML = html;
										return tmp.textContent || tmp.innerText || "";
									},

									preview: function () {
										window.open( this.getUrl(), '_blank' );
									},

									addUndoManagerAction: function ( $element, before, after ) {
										var self = this;
										TVE.UndoManager.add( {
											undo: function () {
												self.undo_sequence( $element, before );
											},
											redo: function () {
												self.undo_sequence( $element, after );
											}
										} );
									},

									undo_sequence: function ( $element, recorded ) {
										$element.html( recorded.html );
										for ( var key in recorded.data ) {
											$element.attr( key, recorded.data[key] );
										}
									},

									getUrl: function () {
										var $element = TVE.ActiveElement;
										var has_custom_url = $element.attr( 'data-use_custom_url' ) && $element.attr( 'data-custom_url' ),
											page_url = has_custom_url ? $element.attr( 'data-custom_url' ) : window.location.href,
											url = $element.attr( 'data-url' ) + '?text=' + encodeURIComponent( $element.find( 'p' ).text() ) + '&url=' + encodeURIComponent( page_url );
										if ( $element.attr( 'data-via' ).length > 0 ) {
											url += '&via=' + $element.attr( 'data-via' );
										}
										return url;
									}
								} );
							},
							"columns.js": function (exports, module, require) {
								var base = require( '../base' ),
									ColumnOptions = require( '../inline/column-options' );

								module.exports = base.component.extend( {
									needs_update: function ( $element ) {
										return $element.hasClass( 'thrv_columns' );
									},
									migrate_element: function ( $element ) {
										TVE.drag.convert_old_columns( $element );
										TVE.Editor_Page.blur();
										TVE.Editor_Page.focus_element( $element.parent() );
									},
									/**
									 * initialize all the controls and extend the change and update function so they can handle the events
									 */
									controls_init: function ( controls ) {
										controls['GutterWidth'].input = function ( $element, dom ) {
											$element.head_css( {'padding-left': dom.value + 'px'}, false, this.config.css_suffix );
											$element.head_css( {'margin-left': - dom.value + 'px'} );
										};

										controls['GutterWidth'].update = function ( $element ) {
											this.setValue( $element.css( 'padding-left' ) );
										};

										controls['GutterWidth'].change = function ( $element, dom ) {
											this.input( $element, dom );
											TVE.drag.position_resizables( $element, dom.value );
										};

										controls['ColumnsOrder'].change = function ( $element, dom ) {
											if ( dom.checked ) {
												$element.addClass( 'tcb-reverse' );
											} else {
												$element.removeClass( 'tcb-reverse' );
											}
										};

										controls['ColumnsOrder'].update = function () {
											this.setChecked( this.applyTo().hasClass( 'tcb-reverse' ) )
										};

										controls['VerticalPosition'].change = function ( $element, dom ) {
											var alignment = dom.getAttribute( 'data-value' );

											$element.removeClass( 'tcb-flex-center tcb-flex-end' );
											if ( alignment != 'default' ) {
												$element.addClass( 'tcb-flex-' + alignment );
											}
										};

										controls['VerticalPosition'].update = function () {
											var classes = this.readFrom().attr( 'class' ),
												pattern = /tcb-flex-(center|end)/,
												result = pattern.exec( classes );

											if ( result && result[1] ) {
												this.setActive( result[1] );
											} else {
												this.setActive( 'default' );
											}
										};

										controls['MediumWrap'].change = function ( $element, dom ) {

											$element.removeClass( 'tcb-medium-no-wrap tcb-medium-wrap' );

											if ( dom.checked ) {
												$element.addClass( 'tcb-medium-wrap' );
											} else {
												$element.addClass( 'tcb-medium-no-wrap' );
											}

											controls['ColumnWidth'].update();

											controls['ColumnWidth'].$el.slideToggle();
										};

										controls['MediumWrap'].update = function () {
											var $element = this.applyTo(),
												checked = $element.css( 'flex-wrap' ).indexOf( 'nowrap' ) === - 1;

											this.setChecked( checked );

											if ( checked && ! $element.hasClass( 'tcb-medium-wrap' ) ) {
												$element.addClass( 'tcb-medium-wrap' )
											}
											controls['ColumnWidth'].$el[checked ? 'show' : 'hide']();

										};

										controls['ColumnWidth'].input = function ( $element, dom ) {
											$element.head_css( {'flex-basis': dom.value + 'px!important'}, false, ' .tcb-flex-col' );
										};

										controls['ColumnWidth'].update = function () {
											this.setValue( this.applyTo().find( '.tcb-flex-col' ).css( 'flex-basis' ) );
										};

										TVE.main.on( 'device_change', function () {
											if ( TVE.ActiveElement ) {
												controls['MediumWrap'].update();
												controls['ColumnWidth'].update();
											}
										} );

										this.placeholder_panel = new ColumnOptions( {
											component: this,
											minWidth: 300,
											no_buttons: true
										} );

										/**
										 * Columns full width
										 */
										controls['FullWidth'].change = function ( $element, dom ) {
											$element.toggleClass( 'tcb-window-width', dom.checked );
											if ( dom.checked ) {
												TVE.inner.window.TCB_Front.resizePageSection( $element );
											} else {
												$element.css( {
													width: '',
													left: ''
												} );
											}
											TVE.Editor_Page.reposition_icons();
										};
										controls['FullWidth'].update = function ( $element ) {
											var checked = $element.hasClass( 'tcb-window-width' );

											if ( this.isChecked() !== checked ) {
												this.setChecked( checked );
											}
										};

										/**
										 * Section height
										 */
										controls.MinHeight.input = function ( $element, dom ) {
											$element.head_css( {'min-height': dom.value + this.getUM()} );
										};

										controls.MinHeight.update = function ( $element ) {
											var value = $element.head_css( 'min-height', false, '', true );
											if ( ! value ) {
												value = $element.height();
											}
											this.setValue( value );
										};
									},
									/**
									 * Triggered when clicking "Select Columns Layout" button
									 * Opens up an inline drop panel
									 */
									placeholder_action: function () {
										this.placeholder_panel.open( TVE.ActiveElement, TVE.ActiveElement.find( '.tcb-inline-placeholder-action' ) )
									}
								} );
							},
							"comments-disqus.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 5/3/2017.
								 */
								var base = require( '../base' );
								module.exports = base.component.extend( {
									controls_init: function ( controls ) {
										var self = this;

										this.controls['ForumName'].update = function ( $element ) {
											this.setValue( $element.find( '#disqus_thread' ).attr( 'data-disqus_shortname' ) );
										};

										this.controls['ForumName'].change = function ( value ) {
											var $element = this.applyTo().find( '#disqus_thread' ),
												oldValue = $element.attr( 'data-disqus_shortname' );

											$element.attr( 'data-disqus_shortname', value );

											/** save it directly to the server */
											TVE.ajax( 'update_option', 'post', {
												option_name: 'tve_comments_disqus_shortname',
												option_value: value
											} );

											self.undo_manager_api( $element, 'data-disqus_shortname', oldValue, value );
										};


										this.controls['URL'].update = function ( $element ) {
											this.setValue( $element.find( '#disqus_thread' ).attr( 'data-disqus_url' ) );
										};

										this.controls['URL'].change = function ( value ) {
											value = TVE.addHttp( value );

											var $element = this.applyTo().find( '#disqus_thread' ),
												oldValue = $element.attr( 'data-disqus_url' );

											this.setValue( value );

											if ( TVE.isValidUrl( value ) || value === '' ) {
												$element.attr( 'data-disqus_url', value );

												self.undo_manager_api( $element, 'data-disqus_url', oldValue, value );
											} else {
												TVE.page_message( TVE.t.UrlInvalid, true, 5000 );
											}
										};
									},

									/**
									 * Undo Manager API
									 *
									 * @param $element
									 * @param attr_name
									 * @param old_attr_value
									 * @param new_attr_value
									 */
									undo_manager_api: function ( $element, attr_name, old_attr_value, new_attr_value ) {
										var self = this;
										TVE.UndoManager.add( {
											undo: function () {
												$element.attr( attr_name, old_attr_value );
											},
											redo: function () {
												$element.attr( attr_name, new_attr_value );
											}
										} );
									}
								} );
							},
							"comments-facebook.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 5/4/2017.
								 */
								var base = require( '../base' );

								module.exports = base.component.extend( {
									nrOfPosts: null,
									controls_init: function () {
										var self = this;

										this.controls['moderators'].update = function ( $element ) {
											var moderatorIds = $element.find( '.tve-fb-comments' ).attr( 'data-fb-moderator-ids' ),
												arr, objArr = [];
											if ( moderatorIds ) {
												arr = moderatorIds.split( ';' );
												arr.forEach( function ( _value ) {
													objArr.push( {'value': _value} );
												} );
											}
											this.resetCollection( objArr );
										};

										this.controls['moderators'].change = function ( $element, arrayOfItems ) {
											var arr = [], _str;

											arrayOfItems.forEach( function ( object ) {
												arr.push( object['value'] );
											} );
											_str = arr.join( ';' );
											$element.find( '.tve-fb-comments' ).attr( 'data-fb-moderator-ids', _str );

											/** save it directly to the server */
											TVE.ajax( 'update_option', 'post', {
												option_name: 'tve_comments_facebook_admins',
												option_value: _str
											} );
										};


										this.controls['color_scheme'].update = function ( $element ) {
											this.setValue( $element.find( '.tve-fb-comments' ).attr( 'data-colorscheme' ) );
										};

										this.controls['color_scheme'].input = function ( $element, dom ) {
											var $cElement = $element.find( '.tve-fb-comments' ),
												oldValue = $element.attr( 'data-colorscheme' ),
												value = dom.value;

											$cElement.attr( 'data-colorscheme', value );

											self.undo_manager_api( $cElement, 'data-colorscheme', oldValue, value );
										};

										this.controls['order_by'].update = function ( $element ) {
											this.setValue( $element.find( '.tve-fb-comments' ).attr( 'data-order-by' ) );
										};

										this.controls['order_by'].input = function ( $element, dom ) {
											var $cElement = $element.find( '.tve-fb-comments' ),
												oldValue = $element.attr( 'data-order-by' ),
												value = dom.value;

											$cElement.attr( 'data-order-by', value );

											self.undo_manager_api( $cElement, 'data-order-by', oldValue, value );
										};

										this.controls['nr_of_comments'].input = function ( $element, dom ) {
											$element.find( '.tve-fb-comments' ).attr( 'data-numposts', dom.value );
										};
										this.controls['nr_of_comments'].update = function ( $element ) {
											var value = $element.find( '.tve-fb-comments' ).attr( 'data-numposts' );
											this.setValue( value );
											this.nrOfPosts = value;
										};
										this.controls['nr_of_comments'].change = function ( $element, dom ) {
											$element.find( '.tve-fb-comments' ).attr( 'data-numposts', dom.value );
											self.undo_manager_api( $element, 'data-numposts', this.nrOfPosts, dom.value );
										};


										this.controls['URL'].update = function ( $element ) {
											this.setValue( $element.find( '.tve-fb-comments' ).attr( 'data-href' ) );
										};

										this.controls['URL'].change = function ( value ) {
											value = TVE.addHttp( value );

											var $element = this.applyTo().find( '.tve-fb-comments' ),
												oldValue = $element.attr( 'data-href' );

											this.setValue( value );

											if ( TVE.isValidUrl( value ) || value === '' ) {
												$element.attr( 'data-href', value );

												self.undo_manager_api( $element, 'data-href', oldValue, value );
											} else {
												TVE.page_message( TVE.t.UrlInvalid, true, 5000 );
											}
										};
									},

									/**
									 * Undo Manager API
									 *
									 * @param $element
									 * @param attr_name
									 * @param old_attr_value
									 * @param new_attr_value
									 */
									undo_manager_api: function ( $element, attr_name, old_attr_value, new_attr_value ) {
										TVE.UndoManager.add( {
											undo: function () {
												$element.attr( attr_name, old_attr_value );
											},
											redo: function () {
												$element.attr( attr_name, new_attr_value );
											}
										} );
									}
								} );
							},
							"content-templates.js": function (exports, module, require) {
								var base = require( '../base' ),
									SearchPanel = require( '../inline/content-templates' );

								module.exports = base.component.extend( {
									controls_init: function () {
										this.placeholder_panel = new SearchPanel( {
											component: this,
											minWidth: 250,
											no_buttons: true
										} );
										TVE.main.on( 'insert_element', function ( element ) {
											if ( element.type === 'ct' && ! TVE.CONST.content_templates.length ) {
												element.prevent_insert = true;
												TVE.modal_open( 'base', 'no-content-templates' );
											}
										} );
									},
									placeholder_action: function () {
										this.placeholder_panel.open( TVE.ActiveElement, TVE.ActiveElement.find( '.tcb-inline-placeholder-action' ) )
									}
								} );
							},
							"contentbox.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.component.extend( {
									needs_update: function ( $element ) {
										return ! $element.hasClass( 'thrv-content-box' );
									},
									migrate_element: function ( $element ) {
										var tempCss, tempContent, backgroundCSS, outsideTmpCss,
											$cb = $element.find( '.tve_cb' ),
											$innerHeader = $cb.find( '.tve_hd' );

										$element.addClass( 'thrv-content-box' );
										$element.prepend( '<div class="tve-content-box-background"></div>' );
										$cb.find( 'hr' ).remove();

										backgroundCSS = $cb.css( [
											'background-color',
											'border-width',
											'border-style',
											'border-color',
											'border-image',
											'border-radius'
										] );

										outsideTmpCss = $cb.css( [
											'padding'
										] );

										$cb.css( {
											'background-color': 'transparent',
											'border-width': '0px',
											'border-style': 'none',
											'border-color': 'transparent',
											'border-image': 'none',
											'border-radius': '0px',
											'box-sizing': 'border-box !important'
										} );

										$element.find( '>.tve-content-box-background' ).head_css( backgroundCSS );
										$element.head_css( outsideTmpCss );

										var header_css = $element.find( 'h1, h2, h3' ).css( [
											'color',
											'margin-top',
											'margin-bottom'
										] );

										var text_css = $element.find( 'p' ).css( [
											'color',
											'margin-top',
											'margin-bottom'
										] );

										if ( $innerHeader.length && $innerHeader.find( 'h1, h2, h3' ).length ) {
											$innerHeader.addClass( 'thrv-content-box' ).addClass( 'thrv_wrapper' );
											tempContent = $innerHeader.html();
											$innerHeader.html( '<div class="tve-content-box-background"></div><div class="tve-cb" ></div>' );
											$innerHeader.find( '.tve-cb' ).html( tempContent ).css( {
												'background-color': 'transparent',
												'background-image': 'none'
											} );

											backgroundCSS = $innerHeader.css( [
												'background-color',
												'border-width',
												'border-style',
												'border-color',
												'border-image',
												'border-radius'
											] );

											tempCss = $innerHeader.css( [
												'padding',
												'margin'
											] );
											tempCss.margin += ' !important';
											if ( $cb.hasClass( 'tve_cb1' ) ) {
												tempCss.margin = 0;
											}

											tempCss['min-height'] = '0px';
											$innerHeader.css( {
												'background-color': 'transparent',
												'border-width': '0px',
												'border-style': 'none',
												'border-color': 'transparent',
												'border-image': 'none',
												'border-radius': '0px',
												'box-sizing': 'border-box !important',
												'margin': '0px',
												'width': 'auto'
											} );

											$innerHeader.find( '>.tve-content-box-background' ).head_css( backgroundCSS );
											$innerHeader.head_css( tempCss );
										}
										$element.head_css( header_css, null, ' .tve-cb h3' );
										$element.head_css( text_css, null, ' .tve-cb p' );
										$cb.removeClass( 'tve_cb' ).removeClass( 'tve_cb1 tve_cb2 tve_cb3 tve_cb4 tve_cb5' ).addClass( 'tve-cb' );
									},
									controls_init: function ( controls ) {
									}
								} );
							},
							"countdown-evergreen.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 5/16/2017.
								 */
								var countdown = require( './countdown' ),
									StylePicker = require( '../controls/countdown/style' );

								module.exports = countdown.extend( {
									needs_update: function ( $element ) {
										return ! $element.find( '.t-caption' ).hasClass( 'thrv-inline-text' );
									},
									migrate_element: function ( $element ) {
										$element.find( '.t-caption' ).addClass( 'thrv-inline-text' );
										$element.removeClass( 'tve_countdown_timer_evergreen tve_cd_timer_plain' ).addClass( 'thrv-countdown_timer_evergreen' );
									},
									controls_init: function ( controls ) {
										var opts = this.config.style;
										this.controls['style'].set_drop_panel( new StylePicker( {model: opts, component: this} ) );

										/**
										 * Color Functions
										 */
										this.controls['Color'].change = function ( color ) {
											var $element = this.applyTo();

											var styleProps = this.config.config.style_default_color;
											_.each( styleProps, function ( v, k ) {
												for ( var i in v ) {
													var tempObj = {};
													if ( v[i] === '' ) {
														tempObj[i] = color + '!important';
														$element.head_css( tempObj, false, k );
													}
												}
											} );
											$element.head_css( {'color': color + '!important'}, false, ' .t-caption' );
										};

										this.controls['Color'].input = function ( color ) {
											var $element = this.applyTo(),
												styleProps = this.config.config.style_default_color;

											_.each( styleProps, function ( v, k ) {
												for ( var i in v ) {
													var tempObj = {};
													if ( v[i] === '' ) {
														tempObj[i] = color + '!important';
														$element.head_css( tempObj, false, k );
													}
												}
											} );
											$element.head_css( {'color': color + '!important'}, false, ' .t-caption' );
										};

										this.controls['Color'].update = function () {
											this.setValue( this.applyTo().find( '.t-caption' ).css( 'color' ) );
										};

										/**
										 * Text to show when complete functions
										 */
										this.controls['CompleteText'].change = function ( value ) {
											var $element = this.applyTo(),
												oldValue = $element.attr( 'data-text' );

											$element.attr( 'data-text', value );
											this.component.undo_manager_api_for_attributes( $element, 'data-text', oldValue, value, false );
										};

										this.controls['CompleteText'].update = function ( $element ) {
											this.setValue( $element.attr( 'data-text' ) );
										};

										/**
										 * Day control code
										 */
										this.controls['Day'].input = function ( $element, dom ) {
											this.component.set_date_values( $element.find( '.tve_t_day .t-digits' ), dom.value );
											this.component.change_digits_width( $element, '.tve_t_day .t-digits', dom.value );
										};
										this.controls['Day'].update = function ( $element ) {
											this.setValue( parseInt( $element.attr( 'data-day' ) ) );
										};
										this.controls['Day'].change = function ( $element, dom ) {
											var oldValue = $element.attr( 'data-day' );
											$element.attr( 'data-day', dom.value );
											this.component.time_undo_redo_manager( $element, 'data-day', oldValue, dom.value, $element.find( '.tve_t_day .t-digits' ) );
										};

										/**
										 * Hour control code
										 */
										this.controls['Hour'].input = function ( $element, dom ) {
											this.component.set_date_values( $element.find( '.tve_t_hour .t-digits' ), dom.value );
										};
										this.controls['Hour'].update = function ( $element ) {
											this.setValue( parseInt( $element.attr( 'data-hour' ) ) );
										};
										this.controls['Hour'].change = function ( $element, dom ) {
											var oldValue = $element.attr( 'data-hour' );
											$element.attr( 'data-hour', dom.value );
											this.component.time_undo_redo_manager( $element, 'data-hour', oldValue, dom.value, $element.find( '.tve_t_hour .t-digits' ) );
										};

										/**
										 * Minute control code
										 */
										this.controls['Minute'].input = function ( $element, dom ) {
											this.component.set_date_values( $element.find( '.tve_t_min .t-digits' ), dom.value );
										};
										this.controls['Minute'].update = function ( $element ) {
											this.setValue( parseInt( $element.attr( 'data-min' ) ) );
										};
										this.controls['Minute'].change = function ( $element, dom ) {
											var oldValue = $element.attr( 'data-min' );
											$element.attr( 'data-min', dom.value );
											this.component.time_undo_redo_manager( $element, 'data-min', oldValue, dom.value, $element.find( '.tve_t_min .t-digits' ) );
										};

										/**
										 * Second control code
										 */
										this.controls['Second'].input = function ( $element, dom ) {
											this.component.set_date_values( $element.find( '.tve_t_sec .t-digits' ), dom.value );
										};
										this.controls['Second'].update = function ( $element ) {
											this.setValue( parseInt( $element.attr( 'data-sec' ) ) );
										};
										this.controls['Second'].change = function ( $element, dom ) {
											var oldValue = $element.attr( 'data-sec' );
											$element.attr( 'data-sec', dom.value );
											this.component.time_undo_redo_manager( $element, 'data-sec', oldValue, dom.value, $element.find( '.tve_t_sec .t-digits' ) );
										};

										/**
										 * Exp Day control code
										 */
										this.controls['ExpDay'].input = function ( $element, dom ) {
										};
										this.controls['ExpDay'].update = function ( $element ) {
											this.setValue( parseInt( $element.attr( 'data-expday' ) ) );
										};
										this.controls['ExpDay'].change = function ( $element, dom ) {
											var oldValue = $element.attr( 'data-expday' );
											$element.attr( 'data-expday', dom.value );
											this.component.undo_manager_api_for_attributes( $element, 'data-expday', oldValue, dom.value, false );
										};


										/**
										 * Exp Hour control code
										 */
										this.controls['ExpHour'].input = function ( $element, dom ) {
										};
										this.controls['ExpHour'].update = function ( $element ) {
											this.setValue( parseInt( $element.attr( 'data-exphour' ) ) );
										};
										this.controls['ExpHour'].change = function ( $element, dom ) {
											var oldValue = $element.attr( 'data-exphour' );
											$element.attr( 'data-exphour', dom.value );
											this.component.undo_manager_api_for_attributes( $element, 'data-exphour', oldValue, dom.value, false );
										};

										/**
										 * Start again after control
										 */
										this.controls['StartAgain'].update = function ( $element ) {
											var restart = $element.attr( 'data-norestart' );
											if ( typeof restart !== 'undefined' && parseInt( restart ) === 0 ) {
												this.setChecked( true );
												this.component.$el.find( '.tcb-start-again-control' ).removeClass( 'tcb-hidden' );
											} else {
												this.setChecked( false );
												this.component.$el.find( '.tcb-start-again-control' ).addClass( 'tcb-hidden' );
											}
										};

										this.controls['StartAgain'].change = function ( $element, dom ) {
											if ( dom.checked ) {
												$element.attr( 'data-norestart', 0 );
												this.component.$el.find( '.tcb-start-again-control' ).removeClass( 'tcb-hidden' );
											} else {
												$element.attr( 'data-norestart', 1 );
												this.component.$el.find( '.tcb-start-again-control' ).addClass( 'tcb-hidden' );
											}
										};
									},

									/**
									 * Trigger Change on Day Input
									 */
									trigger_change_date: function () {
										this.controls['Day'].$( '.tve-input' ).trigger( 'input' );
									},

									/**
									 * Change digits min width span
									 *
									 * @param $element
									 * @param selector
									 * @param value
									 */
									change_digits_width: function ( $element, selector, value ) {
										var day_digits = 2;
										if ( value > 99 ) {
											day_digits = value.toString().length;
										}
										$element.find( selector ).css( 'min-width', ( day_digits * $element.find( '.tve_t_sec .t-digits > span' ).first().outerWidth()) + 'px' );
									},

									/**
									 * Time Undo/Redo Manager
									 *
									 * @param $element
									 * @param attr_name
									 * @param old_attr_value
									 * @param new_attr_value
									 * @param $selector
									 */
									time_undo_redo_manager: function ( $element, attr_name, old_attr_value, new_attr_value, $selector ) {
										var self = this;
										TVE.UndoManager.add( {
											undo: function () {
												$element.attr( attr_name, old_attr_value );
												self.set_date_values( $selector, old_attr_value );
											},
											redo: function () {
												$element.attr( attr_name, new_attr_value );
												self.set_date_values( $selector, new_attr_value );
											}
										} );
									}
								} );
							},
							"countdown.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 5/12/2017.
								 */
								var base = require( '../base' ),
									StylePicker = require( '../controls/countdown/style' );

								module.exports = base.component.extend( {
									needs_update: function ( $element ) {
										return ! $element.find( '.t-caption' ).hasClass( 'thrv-inline-text' );
									},
									migrate_element: function ( $element ) {
										$element.find( '.t-caption' ).addClass( 'thrv-inline-text' );
										$element.removeClass( 'tve_cd_timer_plain' ).addClass( 'thrv-countdown_timer_plain' );
									},
									controls_init: function ( controls ) {
										this.controls['CompleteText'].change = function ( value ) {
											var $element = this.applyTo(),
												oldValue = $element.attr( 'data-text' );

											$element.attr( 'data-text', value );
											this.component.undo_manager_api_for_attributes( $element, 'data-text', oldValue, value, false );
										};

										this.controls['CompleteText'].update = function ( $element ) {
											this.setValue( $element.attr( 'data-text' ) );
										};

										var opts = this.config.style;
										this.controls['style'].set_drop_panel( new StylePicker( {model: opts, component: this} ) );

										this.controls['EndDate'].update = function ( $element ) {
											var date = $element.attr( 'data-date' ),
												dateArr = date.split( '-' ),
												month = dateArr[1] - 1; // Months in JS starts with 0

											this.setValue( dateArr[0], month, dateArr[2] );
										};
										this.controls['EndDate'].input = function ( $element, value ) {
											var dateArr = value.split( ' ' ),
												_date = dateArr[0],
												_dateYMD = _date.split( '-' ).reverse().join( '-' ),
												oldValue = $element.attr( 'data-date' );

											$element.attr( 'data-date', _dateYMD );

											this.component.compute_time_until( $element, _dateYMD, $element.attr( 'data-hour' ), $element.attr( 'data-min' ) );
											this.component.undo_manager_api_for_attributes( $element, 'data-date', oldValue, _dateYMD, true );
										};

										this.controls['Color'].change = function ( color ) {
											var $element = this.applyTo(),
												styleProps = this.config.config.style_default_color;
											_.each( styleProps, function ( v, k ) {
												for ( var i in v ) {
													var tempObj = {};
													if ( v[i] === '' ) {
														tempObj[i] = color + '!important';
														$element.head_css( tempObj, false, k );
													}
												}
											} );
											$element.head_css( {'color': color + '!important'}, false, ' .t-caption' );
										};

										this.controls['Color'].input = function ( color ) {
											var $element = this.applyTo(),
												styleProps = this.config.config.style_default_color;

											_.each( styleProps, function ( v, k ) {
												for ( var i in v ) {
													var tempObj = {};
													if ( v[i] === '' ) {
														tempObj[i] = color + '!important';
														$element.head_css( tempObj, false, k );
													}
												}
											} );
											$element.head_css( {'color': color + '!important'}, false, ' .t-caption' );
										};

										this.controls['Color'].update = function () {
											this.setValue( this.applyTo().find( '.t-caption' ).css( 'color' ) );
										};

										this.controls['Hour'].input = function ( $element, dom ) {
											var value = dom.value,
												value_digits = value.toString().length;

											if ( value_digits === 1 ) {
												value = '0' + value;
											}

											this.component.compute_time_until( $element, $element.attr( 'data-date' ), value, $element.attr( 'data-min' ) );
										};
										this.controls['Hour'].update = function ( $element ) {
											this.setValue( parseInt( $element.attr( 'data-hour' ) ) );
										};
										this.controls['Hour'].change = function ( $element, dom ) {
											var value = dom.value,
												value_digits = value.toString().length,
												oldValue = $element.attr( 'data-hour' );

											if ( value_digits === 1 ) {
												value = '0' + value;
											}

											$element.attr( 'data-hour', value );
											this.component.undo_manager_api_for_attributes( $element, 'data-hour', oldValue, value, true );
										};

										this.controls['Minute'].input = function ( $element, dom ) {
											var value = dom.value,
												value_digits = value.toString().length;

											if ( value_digits === 1 ) {
												value = '0' + value;
											}

											this.component.compute_time_until( $element, $element.attr( 'data-date' ), $element.attr( 'data-hour' ), value );
										};
										this.controls['Minute'].update = function ( $element ) {
											this.setValue( parseInt( $element.attr( 'data-min' ) ) );
										};
										this.controls['Minute'].change = function ( $element, dom ) {
											var value = dom.value,
												value_digits = value.toString().length,
												oldValue = $element.attr( 'data-min' );

											if ( value_digits === 1 ) {
												value = '0' + value;
											}

											$element.attr( 'data-min', value );
											this.component.undo_manager_api_for_attributes( $element, 'data-min', oldValue, value, true );
										};
									},
									/**
									 * Computes the time until for the countdown timer
									 *
									 * @param $element - active element
									 * @param dateYMD - date YY-mm-dd format
									 * @param h - hour
									 * @param m - minute
									 */
									compute_time_until: function ( $element, dateYMD, h, m ) {
										var now = new Date(),
											event_date = new Date( dateYMD + 'T' + h + ':' + m + ':00' + $element.attr( 'data-timezone' ) );

										var sec = 0, min = 0, hour = 0, day = 0, day_digits;

										if ( now < event_date ) {
											sec = Math.floor( (event_date.getTime() - now.getTime()) / 1000 );
											min = Math.floor( sec / 60 );
											hour = Math.floor( min / 60 );
											day = Math.floor( hour / 24 );
											day_digits = 2;
											sec = sec % 60;
											min = min % 60;
											hour = hour % 24;
											if ( day > 99 ) {
												day_digits = day.toString().length;
											}
										}

										this.set_date_values( $element.find( '.tve_t_day .t-digits' ), day );
										this.set_date_values( $element.find( '.tve_t_hour .t-digits' ), hour );
										this.set_date_values( $element.find( '.tve_t_min .t-digits' ), min );
										this.set_date_values( $element.find( '.tve_t_sec .t-digits' ), sec );

										if ( now < event_date ) {
											$element.find( '.tve_t_day .t-digits' ).css( 'min-width', (day_digits * $element.find( '.tve_t_sec .t-digits > span' ).first().outerWidth()) + 'px' );
										} else {
											$element.find( '.tve_t_day .t-digits' ).css( 'min-width', '' );
										}
									},

									/**
									 * Trigger Change on EndDate input
									 */
									trigger_change_date: function () {
										this.controls['EndDate'].$( '.tve-input-control' ).trigger( 'change' );
									},

									/**
									 * set each of the new values on a group (seconds, minutes, hours, days)
									 * @param container
									 * @param value
									 */
									set_date_values: function ( container, value ) {
										container.empty();
										if ( value <= 99 ) {
											container.prepend( '<span class="part-1">' + value % 10 + '</span>' );
											container.prepend( '<span class="part-2">' + Math.floor( value / 10 ) + '</span>' );
										} else {
											var index = 0;
											while ( value ) {
												index ++;
												container.prepend( '<span class="part-' + index + '">' + (value % 10) + '</span>' );
												value = Math.floor( value / 10 );
											}
										}
									},

									/**
									 * Countdown style initializer
									 */
									countdown_style_control: function () {
										return require( '../controls/style-change' );
									},

									/**
									 * Undo Manager API
									 * Only for modifying element attributes
									 *
									 * @param $element
									 * @param attr_name
									 * @param old_attr_value
									 * @param new_attr_value
									 * @param changeTimer - bool
									 */
									undo_manager_api_for_attributes: function ( $element, attr_name, old_attr_value, new_attr_value, changeTimer ) {
										var self = this;
										changeTimer = typeof changeTimer === 'undefined' ? false : changeTimer;
										TVE.UndoManager.add( {
											undo: function () {

												if ( typeof old_attr_value === 'undefined' ) {
													old_attr_value = '';
												}
												$element.attr( attr_name, old_attr_value );
												if ( changeTimer ) {
													this.changeTimer();
												}
											},
											redo: function () {
												$element.attr( attr_name, new_attr_value );
												if ( changeTimer ) {
													this.changeTimer();
												}
											},
											changeTimer: function () {
												self.compute_time_until( $element, $element.attr( 'data-date' ), $element.attr( 'data-hour' ), $element.attr( 'data-min' ) );
											}
										} );
									}
								} );
							},
							"credit.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 4/4/2017.
								 */
								var base = require( '../base' ),
									StylePicker = require( '../controls/credit/style' ),
									CardsPicker = require( '../controls/credit/cards' );

								module.exports = base.component.extend( {
									cardsCollection: new Backbone.Collection( {} ),
									/**
									 * Change and update functions
									 */
									controls_init: function () {
										this.controls.size.update = function ( $element ) {
											var css = $element.head_css( 'font-size', null, null, true );
											if ( ! css ) {
												css = $element.find( 'svg' ).first().width();
											}
											this.setValue( css );
										};
										this.controls.size.input = function ( $element ) {
											$element.head_css( {'font-size': this.value( 'px' )} );
										};

										this.listenTo( this.cardsCollection, 'reset-for-preview', _.bind( function () {
											var $element = this.controls.cards_list.applyTo();
											this.controls.preview.update( $element );
										}, this ) );

										this.listenTo( this.cardsCollection, 'change', _.bind( function ( model ) {
											var elementCards = [],
												$element = this.controls.cards_list.applyTo();

											this.cardsCollection.each( function ( model ) {
												elementCards.push( model.get( 'key' ) );
											}, this );
											this.renderer.sort_element_cards( elementCards );
											this.renderer.render_to( $element );
										}, this ) );

										this.listenTo( this.cardsCollection, 'remove', _.bind( function ( model ) {
											var $element = this.controls.cards_list.applyTo(),
												elementCards = $element.attr( 'data-cards' ).split( ',' ),
												indexToRemove = elementCards.indexOf( model.get( 'key' ) );

											if ( indexToRemove > - 1 ) {
												elementCards.splice( indexToRemove, 1 );
											}

											$element.attr( 'data-cards', elementCards );
											$element.find( '.tcb-' + model.get( 'key' ) + '-card' ).remove();
										}, this ) );

										this.controls.preview.attach_collection( this.cardsCollection );
										this.controls.preview.update = function ( $element ) {
											var cardsArr = [],
												elementCards = $element.attr( 'data-cards' ).split( ',' );

											_.each( elementCards, function ( item, index ) {
												cardsArr.push( {icon: this.component.renderer.get_card_template( elementCards[index], true ), key: elementCards[index], label: this.component.renderer.cards[item]} )
											}, this );
											this.component.cardsCollection.reset( cardsArr );
										};

										var opts = this.config.stylePicker;
										opts.config.items = this.renderer.get_styles();
										this.controls.style.set_drop_panel( new StylePicker( {model: opts, renderer: this.renderer, collection: this.cardsCollection} ) );


										var cards = this.config.cards;
										cards.config.items = this.renderer.get_cards();
										this.controls.cards_list.set_drop_panel( new CardsPicker( {model: cards, renderer: this.renderer, collection: this.cardsCollection} ) );
									},
									/**
									 * Rating style initializer
									 */
									credit_style_control: function () {
										return require( '../controls/style-change' );
									},
									card_preview_control: function () {
										return require( '../controls/preview-list' );
									}
								} );
							},
							"decoration.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.component.extend( {
									/**
									 * Get the View constructor for the decoration control
									 *
									 * @returns {*}
									 */
									decoration: function () {
										return require( '../controls/decoration/decoration' );
									}
								} );
							},
							"divider.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 4/20/2017.
								 */
								var base = require( '../base' ),
									StylePicker = require( '../controls/divider/style' );

								module.exports = base.component.extend( {
									oldColor: null,
									oldThickness: null,
									needs_update: function ( $element ) {
										return ! $element.hasClass( 'thrv-divider' );
									},
									migrate_element: function ( $element ) {
										$element.addClass( 'thrv-divider' );
										$element.attr( 'data-color', 'rgb(217, 217, 217)' );
										$element.attr( 'data-thickness', '10' );
										var $hr = $element.find( 'hr' ),
											classes = $hr.attr( 'class' ).split( ' ' ),
											existingStyle = 'tve_sep1';

										var index = classes.indexOf( 'tve_sep' );
										if ( index > - 1 ) {
											classes.splice( index, 1 );
										}

										if ( classes.length === 1 ) {
											existingStyle = classes[0];
										}
										var styleNumber = existingStyle.slice( - 1 ),
											convertedStyle = 'tve_sep-' + styleNumber;
										$hr.removeClass( existingStyle ).addClass( convertedStyle );
										$element.attr( 'data-style', 'tve_sep-' + styleNumber );
										this.addDividerHeadCss( $element )
									},
									controls_init: function ( controls ) {
										this.controls['divider_color'].input = function ( color ) {
											var $element = this.applyTo();

											$element.attr( 'data-color', this.component.$el.find( '.color-input' ).val() );
											this.component.addDividerHeadCss( $element );
										};
										this.controls['divider_color'].change = function ( color ) {
											var $element = this.applyTo();

											$element.attr( 'data-color', this.component.$el.find( '.color-input' ).val() );
											this.component.addDividerHeadCss( $element );
											this.component.undo_manager_api( $element, 'data-color', this.oldColor, $element.attr( 'data-color' ) );
										};
										this.controls['divider_color'].update = function ( $element ) {
											this.setValue( $element.attr( 'data-color' ) );
											this.oldColor = $element.attr( 'data-color' );
										};


										this.controls['thickness'].input = function ( $element, dom ) {
											$element.attr( 'data-thickness', dom.value );
											this.component.addDividerHeadCss( $element );
										};
										this.controls['thickness'].update = function ( $element ) {
											this.setValue( $element.attr( 'data-thickness' ) );
											this.oldThickness = $element.attr( 'data-thickness' );
										};
										this.controls['thickness'].change = function ( $element, dom ) {
											$element.attr( 'data-thickness', dom.value );
											this.component.addDividerHeadCss( $element );
											this.component.undo_manager_api( $element, 'data-thickness', this.oldThickness, dom.value );
										};

										var opts = this.config.style;
										this.controls['style'].set_drop_panel( new StylePicker( {model: opts, component: this} ) );
									},

									/**
									 * Constructs a CSS Javascript Object
									 *
									 * @param $element
									 * @returns {{class: string, background-image: string, height: string, background-size: string, border-width: string, border-color: string}}
									 */
									constructObject: function ( $element ) {
										var style = $element.attr( 'data-style' ),
											color = $element.attr( 'data-color' ) ? $element.attr( 'data-color' ) : 'rgb(217, 217, 217)',
											thickness = $element.attr( 'data-thickness' ) ? $element.attr( 'data-thickness' ) : 10,
											css = {
												'background-image': '',
												'height': '',
												'background-size': '',
												'border-width': '',
												'border-color': ''
											};

										if ( style && style.length > 0 ) {
											if ( this.config.style.config.items[style] ) {
												if ( style === 'tve_sep-1' ) {
													css['border-width'] = thickness + 'px';
													css['border-color'] = color;
												} else {
													css['height'] = thickness + 'px';
													css['background-size'] = thickness + 'px ' + thickness + 'px';
													css['background-image'] = 'url("' + this.config.style.config.items[style].background_image.replace( '%thrive%', color ) + '")';
												}
											}
										}

										return css;
									},

									/**
									 * Adds Head CSS to Divider Active Element
									 *
									 * @param $element
									 */
									addDividerHeadCss: function ( $element ) {
										var css = this.constructObject( $element );

										TVE.SKIP_CSS_STATE = true;
										$element.head_css( css, null, '.thrv-divider .tve_sep' );
										TVE.SKIP_CSS_STATE = false;
									},

									/**
									 * Undo Manager API
									 *
									 * @param $element
									 * @param attr_name
									 * @param old_attr_value
									 * @param new_attr_value
									 */
									undo_manager_api: function ( $element, attr_name, old_attr_value, new_attr_value ) {
										var self = this;
										TVE.UndoManager.add( {
											undo: function () {
												$element.attr( attr_name, old_attr_value );
												self.addDividerHeadCss( $element );
											},
											redo: function () {
												$element.attr( attr_name, new_attr_value );
												self.addDividerHeadCss( $element );
											}
										} );
									},

									/**
									 * Divider style initializer
									 */
									divider_style_control: function () {
										return require( '../controls/style-change' );
									}
								} );
							},
							"fillcounter.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.component.extend( {
									extra_states: true,
									needs_update: function ( $element ) {
										return ! $element.hasClass( 'thrv-fill-counter' );
									},
									migrate_element: function ( $element ) {
										var label = $element.find( '.tve_fill_text_value' ).html(),
											before = $element.find( '.tve_fill_text_value .tve_fill_text_before' ).css( 'color' ),
											middle = $element.find( '.tve_fill_text_value .tve_fill_text' ).css( 'color' ),
											after = $element.find( '.tve_fill_text_value .tve_fill_text_after' ).css( 'color' );

										$element.head_css( $element.css( [
											'margin',
											'padding',
											'border-width',
											'border-width',
											'border-style',
											'border-color',
											'border-image'
										] ) );
										$element.attr( 'style', '' );
										$element.find( '.tve_fill_text_value' ).html( '<div class="thrv-inline-text tve_fill_text tve_editable">' + label.replace( /(\n|\r)/g, '' ) + '</div>' );

										$element.find( '.tve_fill_text_value .tve_fill_text_before' ).head_css( {'color': before + ' ! important'} ).removeAttr( 'data-tve-custom-colour' );
										$element.find( '.tve_fill_text_value .tve_fill_text' ).head_css( {'color': middle + ' ! important'} ).removeAttr( 'data-tve-custom-colour' );
										$element.find( '.tve_fill_text_value .tve_fill_text_after' ).head_css( {'color': after + ' ! important'} ).removeAttr( 'data-tve-custom-colour' );

										$element.find( '.tve_data_element_label' ).addClass( 'thrv-inline-text tve_editable' );

										$element.find( '.tve_fill_text' ).head_css( {'color': $element.find( '.tve_fill_text' ).css( 'color' ) + ' ! important'} );
										$element.find( '.tve_fill_text_in' ).head_css( {'background-color': $element.find( '.tve_fill_text_in' ).css( 'background-color' )} ).removeAttr( 'data-tve-custom-colour' );
										$element.find( '.tve_data_element_label' ).head_css( {color: $element.find( '.tve_data_element_label' ).css( 'color' ) + ' ! important'} );
										$element.find( '.tve_data_element_label' ).head_css( {
											color: $element.find( '.tve_fill_text_in' ).css( 'color' )
										} );
										$element.find( '.tve_fill_counter_circle circle' ).head_css( {'stroke': $element.find( '.tve_fill_counter_circle circle' ).css( 'stroke' ) + ' ! important'} );

										$element.addClass( 'thrv-fill-counter' ).removeClass( 'thrv_fill_counter' );
									},
									controls_init: function ( controls ) {
										var self = this;
										this.controls['CircleColor'].change = function ( color ) {
											this.input( color );
										};
										this.controls['CircleColor'].input = function ( color ) {
											this.applyTo().find( '.tve_fill_counter_circle' ).head_css( {'background-color': (color + '! important')} );
										};
										this.controls['CircleColor'].update = function ( $element ) {
											this.setValue( $element.find( '.tve_fill_counter_circle' ).css( 'background-color' ) );
										};

										this.controls['FillColor'].change = function ( color ) {
											this.input( color );
										};
										this.controls['FillColor'].input = function ( color ) {
											this.applyTo().find( '.tve_fill_counter_circle circle' ).head_css( {'stroke': (color + '! important')} );
										};
										this.controls['FillColor'].update = function ( $element ) {
											this.setValue( $element.find( '.tve_fill_counter_circle circle' ).css( 'stroke' ) );
										};

										this.controls['InnerColor'].change = function ( color ) {
											this.input( color );
										};
										this.controls['InnerColor'].input = function ( color ) {
											this.applyTo().find( '.tve_fill_text_in' ).head_css( {'background-color': color} );
										};
										this.controls['InnerColor'].update = function ( $element ) {
											this.setValue( $element.find( '.tve_fill_text_in' ).css( 'background-color' ) );
										};

										this.controls['CounterSize'].input = function ( $element, dom ) {
											self.apply_size( $element, dom.value );
											TVE.Editor_Page.reposition_icons();
										};
										this.controls['CounterSize'].change = function ( $element, dom ) {
											var value = dom.value;
											this.input( $element, dom );
											TVE.UndoManager.add( {
												undo: function () {
													TVE.SKIP_CSS_STATE = true;
													self.apply_size( $element, undo_size_value );
													TVE.SKIP_CSS_STATE = false;
												},
												redo: function () {
													TVE.SKIP_CSS_STATE = true;
													self.apply_size( $element, value );
													TVE.SKIP_CSS_STATE = false;
												}
											} )
										};
										var undo_size_value;
										this.controls['CounterSize'].update = function ( $element ) {
											undo_size_value = $element.find( '.tve_fill_counter_circle' ).width();
											this.setValue( undo_size_value );
										};
										controls['CounterSize'].afterConfig = function () {
											this.model.config.max = parseInt( this.applyTo().parent().width() );
										};

										this.controls['FillPercent'].input = function ( $element, dom ) {
											self.apply_fill( $element, dom.value );
										};
										this.controls['FillPercent'].change = function ( $element, dom ) {
											var value = dom.value;
											this.input( $element, dom );

											TVE.UndoManager.add( {
												undo: function () {
													TVE.SKIP_CSS_STATE = true;
													self.apply_fill( $element, undo_fill_value );
													TVE.SKIP_CSS_STATE = false;
												},
												redo: function () {
													TVE.SKIP_CSS_STATE = true;
													self.apply_fill( $element, value );
													TVE.SKIP_CSS_STATE = false;
												}
											} )
										};
										var undo_fill_value;
										this.controls['FillPercent'].update = function ( $element ) {
											undo_fill_value = $element.attr( 'data-fill' );
											if ( ! undo_fill_value ) {
												undo_fill_value = 75;
												$element.attr( 'data-fill', undo_fill_value );
												$element.head_css( {'width': (undo_fill_value + '%')} );
											}
											this.setValue( undo_fill_value );

										};
									},
									apply_fill: function ( $element, value ) {
										var percent = Number( value ),
											r = $element.find( '.tve_fill_counter_circle circle' ).attr( 'r' ),
											c = Math.PI * (r * 2);

										$element.attr( 'data-fill', percent );
										if ( percent < 0 ) {
											percent = 0;
										}
										if ( percent > 100 ) {
											percent = 100;
										}
										$element.attr( 'style', '' );
										var pct = ( percent / 100) * c;
										$element.head_css( {'stroke-dasharray': (pct + ' ' + c)} );
									},
									apply_size: function ( $element, value ) {
										var r = value / 2,
											percent = $element.find( '.tve_fill_counter_n' ).attr( 'data-fill' ),
											offset = value / 20;
										$element.find( '.tve_fill_counter_circle circle' ).attr( 'r', r ).attr( 'cx', r ).attr( 'cy', r );
										$element.find( '.tve_fill_counter_circle' ).get( 0 ).setAttribute( 'viewBox', '0 0 ' + value + ' ' + value );
										$element.find( '.tve_fill_counter_circle' ).head_css( {
											width: value + 'px !important',
											height: value + 'px !important'
										} );

										$element.find( '.tve_fill_counter_circle circle' ).head_css( {
											'stroke-width': ((offset * 2) + 1) + 'px !important'
										} );

										$element.find( '.tve_fill_text_in' ).head_css( {
											width: (value - offset * 2 ) + 'px !important',
											height: (value - offset * 2 ) + 'px !important',
											top: offset + 'px !important',
											bottom: offset + 'px !important',
											left: offset + 'px !important',
											right: offset + 'px !important'
										} );

										$element.find( '.tve_fill_text_value' ).head_css( {
											'margin-top': (value * 0.25 ) + 'px !important'
										} );
										$element.find( '.tve_fill_text' ).head_css( {
											'font-size': (value * 0.3 ) + 'px !important',
											'line-height': (value * 0.3 ) + 'px !important'
										} );
										$element.find( '.tve_fill_text .fr-element span' ).css( 'font-size', '' );
										$element.find( '.tve_data_element_label' ).head_css( {
											'font-size': (value * 0.085 ) + 'px !important',
											'line-height': (value * 0.085 ) + 'px !important'
										} );

										this.apply_fill( $element.find( '.tve_fill_counter_n' ), percent );
									}
								} );
							},
							"gmap.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 4/28/2017.
								 */
								var base = require( '../base' );
								module.exports = base.component.extend( {
									controls_init: function ( controls ) {
										this.controls['zoom'].input = function ( $element, dom ) {
										};

										this.controls['zoom'].update = function ( $element ) {
											if ( $element.find( 'iframe' ).length > 0 ) {
												var iframeURL = $element.find( 'iframe' ).attr( 'src' ),
													zoomLevel = TVE.getUrlParam( iframeURL, 'z' );
												this.setValue( zoomLevel );
											}
										};

										this.controls['zoom'].change = function ( $element, dom ) {
											var iframeURL = $element.find( 'iframe' ).attr( 'src' ),
												value = dom.value;
											if ( iframeURL ) {
												$element.find( 'iframe' ).attr( 'src', TVE.setOrReplaceUrlParam( iframeURL, 'z', value ) );
											}
										};

										this.controls['address'].update = function ( $element ) {
											if ( $element.find( 'iframe' ).length > 0 ) {
												var iframeURL = $element.find( 'iframe' ).attr( 'src' ),
													address = TVE.getUrlParam( iframeURL, 'q' );
												this.setValue( address );
											}
										};

										this.controls['address'].change = function ( value ) {
											var $element = this.applyTo(),
												iframeURL = $element.find( 'iframe' ).attr( 'src' );
											if ( iframeURL ) {
												$element.find( 'iframe' ).attr( 'src', TVE.setOrReplaceUrlParam( iframeURL, 'q', value ) );
											}
										};
									}
								} );
							},
							"html.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 4/18/2017.
								 */
								TVE.CustomHTML = require( '../modals/custom-html' );
								var base = require( '../base' );

								module.exports = base.component.extend( {
									controls_init: function ( controls ) {
										this.customHtmlInstance = TVE.CustomHTML.get_instance( TVE.modal.get_element( 'custom-html' ) )
									},
									/**
									 * Callback for "EDIT HTML CONTENT" button
									 */
									edit_html_content: function () {
										this.placeholder_action();
									},
									/**
									 * Triggered when clicking "Insert Custom HTML" button
									 * Opens up an inline drop panel
									 */
									placeholder_action: function () {
										this.customHtmlInstance.open( {
											css: {
												width: '60%',
												left: '20%'
											}
										} );
									}
								} );
							},
							"icon.js": function (exports, module, require) {
								/**
								 * Created by dan bilauca on 4/28/2017.
								 */
								var base = require( '../base' );

								TVE.IconsModal = require( '../modals/icons' );

								module.exports = base.component.extend( {
									extra_states: true,
									controls_init: function () {

										/**
										 * Slider Control
										 */
										this.controls.Slider.update = function ( $element ) {
											this.setValue( $element.head_css( 'font-size', false, '', true, this.config.css_prefix ) );
										};
										this.controls.Slider.input = function ( $element, dom ) {
											$element.head_css( {
												'font-size': dom.value + this.getUM(),
												'width': dom.value + this.getUM(),
												'height': dom.value + this.getUM()
											}, null, this.config.css_suffix, true, this.config.css_prefix );
										};
										this.controls.Slider.change = function ( $element, dom ) {
											this.input( $element, dom );
											TVE.Editor_Page.reposition_icons();
										};
										/**
										 * Overwriting the Slider.onChange()
										 *
										 * @param $element
										 * @param dom
										 */
										this.controls.Slider.onChange = function ( $element, dom ) {

											var _value = parseInt( dom.value );
											_value = isNaN( _value ) ? 0 : _value;

											if ( _value > parseInt( this.model.config.max ) ) {
												dom.value = this.model.config.max;
											}
											if ( _value < parseInt( this.model.config.min ) ) {
												dom.value = this.model.config.min;
											}
											this.setValue( dom.value + this.getUM() );

											TVE.SkipUpdate = false;
											/* triggered only when the user exits the input */
											this.change( $element, dom );
										};

										/**
										 * ColorPicker Control
										 */
										this.controls.ColorPicker.update = function ( $element ) {
											this.setValue( $element.css( 'color' ) );
										};
										this.controls.ColorPicker.input = function ( color ) {
											this.applyTo().head_css( {color: color}, false, this.config.css_suffix, true, this.config.css_prefix );
										};

										/**
										 * ModalPicker Control
										 */
										this.controls.ModalPicker.setModal( TVE.IconsModal.get_instance( TVE.modal.get_element( 'icons' ) ) );

										this.controls.ModalPicker.input = function ( $element, data ) {

											var html;

											if ( data.icon.is( '.tve-svg-icon' ) ) {
												var $symbol = jQuery( 'symbol#' + data.icon.data( 'cls' ) );
												html = TVE.svg_icon( {
													path: $symbol.html(),
													viewBox: $symbol[0].getAttribute( 'viewBox' ),
													name: $symbol.find( '> title' ).text()
												} );

											} else {
												html = '<span data-name="' + data.icon.data( 'cls' ).replace( 'icon-', '' ) + '" class="tve_sc_icon ' + data.icon.data( 'cls' ) + '"></span>';
											}

											if ( $element.head_css( 'font-size' ).length <= 0 && ! $element.hasClass( 'tcb-icon-inherit-style' ) ) {
												$element.head_css( {
													'font-size': '60px' // Constant impose by Shane for newly added icons. Not to depend on slider and on previously modified icons
												} );
											}

											$element.html( html );

											this.update( $element );
										};
										this.controls.ModalPicker.update = function ( $element ) {

											var $icon = $element.children().first(),
												_name = $icon.attr( 'data-name' );

											_name = _name ? _name : $icon.attr( 'data-tve-icon' ) ?
												$icon.attr( 'data-tve-icon' ).replace( 'icon-', '' ) : '';

											this.updateValue( _name );
										};
									},

									placeholder_action: function () {

										this.controls.ModalPicker.openModal();
									}
								} );
							},
							"image-effects.js": function (exports, module, require) {
								(function ( $ ) {
									var base = require( '../base' );

									module.exports = base.component.extend( {
										extra_states: true,
										controls_init: function () {
											var self = this;

											/* on input we store css in style and move it to head only at the end */
											this.controls['ImageGreyscale'].input = function ( $element, dom ) {
												var blur = self.controls['ImageBlur'].value(),
													value = 'grayscale(' + dom.value + this.getUM() + ') blur(' + blur + self.controls['ImageBlur'].getUM() + ')';

												$element.head_css( {'filter': value}, null, ' img' );
											};

											this.controls['ImageGreyscale'].update = function ( $element ) {
												var css = $element.head_css( 'filter', null, ' img', true ),
													value = 0,
													arr = css.split( ' ' );

												$.each( arr, function ( key, val ) {
													if ( val.indexOf( 'grayscale' ) === 0 ) {
														var regExp = /\(([^)]+)\)/,
															matches = regExp.exec( val );
														value = matches[1];
													}
												} );

												this.setValue( value );
											};

											/**
											 * Handle Opacity changes and updates
											 */
											this.controls['ImageOpacity'].input = function ( $element, dom ) {
												$element.head_css( {'opacity': dom.value / 100}, null, ' img' );
											};

											this.controls['ImageOpacity'].update = function ( $element ) {
												var css = $element.head_css( 'opacity', false, ' img', true );

												this.setValue( css * 100 );
											};

											/**
											 * Handle Blur changes and updates
											 */
											this.controls['ImageBlur'].input = function ( $element, dom ) {
												var gray = self.controls['ImageGreyscale'].value(),
													value = 'grayscale(' + gray + self.controls['ImageGreyscale'].getUM() + ') blur(' + dom.value + this.getUM() + ')';

												$element.head_css( { 'filter': value }, false, ' img' );
											};

											this.controls['ImageBlur'].update = function ($element) {
												var css = $element.head_css( 'filter', false, ' img', true ),
													value = 0,
													arr = css.split( ' ' );

												$.each( arr, function ( key, val ) {
													if ( val.indexOf( 'blur' ) === 0 ) {
														var regExp = /\(([^)]+)\)/,
															matches = regExp.exec( val );
														value = matches[1];
													}
												} );

												this.setValue( value );
											};

											this.controls['ImageOverlay'].input = function ( color ) {

												var $selector = this.applyTo(),
													$overlay = $selector.find( '.tve-image-overlay' );

												//check for the overlay
												if ( $overlay.length == 0 ) {
													$selector.find( '.tve_image_frame' ).append( '<div class="tve-image-overlay"></div>' );
													$overlay = $selector.find( '.tve-image-overlay' );
												}

												$overlay.head_css( {'background': color} );
											};

											this.controls['ImageOverlay'].update = function () {
												var $selector = this.applyTo().find( '.tve-image-overlay' ),
													css = '';
												if ( $selector.length > 0 ) {
													css = $selector.css( 'background-color' );
												}

												this.setValue( css );
											};
										}
									} );
								})( jQuery );
							},
							"image.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.component.extend( {
									placeholder_action: function () {
										this.controls.ImagePicker.change_placeholder();
									},
									controls_init: function () {
										this.controls['ImageSize'].input = function ( $element, dom ) {
											var css = {};
											css[this.config.config.css] = dom.value + this.getUM();

											$element.head_css( css );
											$element.css( 'width', '' );
											$element.find( 'img' ).css( 'width', '100%' ).end().find( '.tve_image_frame' ).css( 'width', '100%' );
											TVE.Editor_Page.reposition_icons();
										};

										this.controls['ImageSize'].change = function ( $element, dom ) {
											/*The change event can be executed from slider, entering a value in input or input arrows*/
											var css = {};
											if ( dom.value === 'auto' ) {
												dom.value = this.model.config.max;
											}
											if ( parseInt( dom.value ) < this.config.config.min ) {
												dom.value = this.config.config.min;
											}
											css[this.config.config.css] = dom.value + this.getUM();
											$element.head_css( css );

											$element.css( 'width', '' );
											$element.find( 'img' ).css( 'width', '100%' );
										};

										this.controls['ImageSize'].update = function ( $element ) {
											var css = $element.head_css( this.config.config.css, null, null, true );

											if ( ! css ) {
												css = $element.css( 'width' );
											}

											this.setValue( css );
										};
										this.controls['ImageTitle'].update = function () {
											var $element = this.applyTo().find( 'img' ),
												value = $element.attr( 'title' );

											this.setValue( value );
										};

										this.controls['ImageTitle'].change = function ( value ) {
											this.applyTo().find( 'img' ).attr( 'title', value );
										};

										this.controls['ImageAltText'].update = function () {
											var $element = this.applyTo().find( 'img' ),
												value = $element.attr( 'alt' );

											this.setValue( value );
										};

										this.controls['ImageAltText'].change = function ( value ) {
											this.applyTo().find( 'img' ).attr( 'alt', value );
										};

										this.controls['ImageCaption'].update = function () {
											this.setChecked( this.applyTo().find( '.wp-caption-text' ).length > 0 );
										};

										this.controls['ImageCaption'].change = function ( $element, dom ) {
											if ( dom.checked ) {
												$element.append( '<p class="wp-caption-text">The caption should be here</p>' );
											} else {
												$element.find( '.wp-caption-text' ).remove();
												// todo: maybe we should remove this ? ? ?  in case the caption was added via media library we need to remove the wrapper too
												$element.find( '.thrv_wrapper' ).remove();
											}
										};

										this.controls['ImageFullSize'].update = function () {
											this.setChecked( TVE.Components.animation.has_action( 'click', 'thrive_zoom' ) );
										};

										this.controls['ImageFullSize'].change = function ( $element, dom ) {
											if ( dom.checked ) {
												var $img = this.applyTo().find( 'img' ),
													config = {};
												if ( $img.attr( 'data-id' ) ) {
													config.id = $img.attr( 'data-id' );
													config.size = 'full';
												}
												TVE.Components.animation.add_action( 'click', 'thrive_zoom', config );
												return;
											}
											TVE.Components.animation.remove_action( 'click', 'thrive_zoom' );
										};

										this.controls.ImagePicker.update = function () {
										};
										this.controls.ImagePicker.on( 'change', function ( thumb ) {
											/**
											 * TCB GitHub issue #63 - slack discussion: media manager in sync with TCB
											 */
											if ( thumb.link_url ) {
												var $link = TVE.ActiveElement.parent();
												if ( ! $link.is( 'a' ) ) {
													TVE.ActiveElement.wrap( '<a href="' + thumb.link_url + '" rel="noopener noreferrer"></a>' ).data( 'link-wrap', true );
												} else {
													$link.attr( 'href', thumb.link_url );
												}
											}

											TVE.ActiveElement.head_css( {'width': thumb.width + 'px'} );
											TVE.Editor_Page.reposition_icons();

											this.component.controls.ImageSize.update( TVE.ActiveElement );
											TVE.Components.animation.update();
											TVE.drag.refresh();
										} );
									},
									open_style_picker: function ( e, dom ) {
										this.controls.StylePicker.open( null, dom );

										return false;
									},
									style_picker_control: function () {
										return require( '../controls/image/style' );
									}
								} );
							},
							"landing-page": {
								"lp-advanced.js": function (exports, module, require) {
									var base = require( '../../base' ),
										checkbox = require( '../../controls/checkbox' );

									module.exports = base.component.extend( {
										controls_init: function () {
											var check = new checkbox( {
												el: this.$el.find( '.strip-css' ),
												model: {
													config: {
														label: 'Do not strip out Custom CSS from the <b>&lt;head&gt;</b> section'
													}
												}
											} );

											check.change = function () {
												TVE.CONST.tve_globals['do_not_strip_css'] = this.isChecked() ? 1 : 0;
											};

											check.update = function () {
												this.setChecked( TVE.CONST.tve_globals['do_not_strip_css'] );
											};

											check.update();
										}
									} );
								},
								"lp-fonts.js": function (exports, module, require) {
									(function ( $ ) {

										var base = require( '../../base' );

										module.exports = base.component.extend( {
											initialize: function ( attr ) {
												var self = this;

												this.components = {};

												this.key = 'lp-fonts';

												/* controls configs that will be shared for all elements */
												this.configs = {
													FontManager: {
														template: 'controls/font-manager',
														tinymce: false
													},
													ColorPicker: {
														icon: true,
														label: ' '
													},
													FontSize: {
														default: '16',
														min: '1',
														max: '100',
														label: 'Font Size',
														um: ['px', 'em'],
														css: 'fontSize'
													},
													LineHeight: {
														default: '16',
														min: '1',
														max: '100',
														label: 'Line Height',
														um: ['px', 'em'],
														css: 'lineHeight'
													}
												};

												/* Go through all the elements and all controls and instantiatle them */
												this.$( '.dropdown-content' ).each( function () {
													/* read the element that all the controls will apply to */
													var applyTo = this.getAttribute( 'data-apply' ),
														$self = $( this );

													if ( ! applyTo ) {
														return;
													}

													/* all elements have the same template  */
													$self.html( TVE.tpl( 'landing-pages/font-settings' )( {selector: applyTo} ) );

													self.components[applyTo] = {
														controls: {}
													};

													$self.find( '.tve-control' ).each( function () {
														var $this = $( this ),
															control = $this.data( 'view' ),
															key = $this.data( 'key' ) || control,
															model = {
																config: self.configs[key] || {}
															};

														self.components[applyTo].controls[key] = new TVE.Views.Controls[control]( {
															model: model,
															el: $this,
															component: $self
														} );

														self.components[applyTo].controls[key].setConfig( {}, applyTo );
													} );
												} );

												this.$buttons = this.$( '.tve-button.apply-to-all' );

												this.components_init( this.components );

											},
											/**
											 * Initialize components with their controls. All components have the same behaviour, the only difference is the element they apply to
											 * @param components
											 */
											components_init: function ( components ) {
												var self = this;
												_.each( components, function ( component, selector ) {

													component.controls.FontManager.update = function () {
														this.initial_font = self.readCSS( selector, 'font-family' );

														this.readFont();

														this.setInputValue( this.initial_font );
													};

													component.controls.FontManager.setInputValue = function ( value ) {
														if ( typeof value === 'undefined' ) {
															value = self.readCSS( selector, 'font-family' );
														}
														
														value = value.length && this.section === 'inherit' ? 'Inherit: [' + value + ']' : value;

														this.component.find( '.font-face-input' ).val( value );
													};

													component.controls.FontManager.writeCSS = function ( $element, value ) {
														self.writeCSS( selector, {'font-family': value} );
													};

													component.controls.ColorPicker.update = function () {
														this.setValue( self.readCSS( selector, 'color' ) );
													};

													component.controls.ColorPicker.input = function ( color ) {
														self.writeCSS( selector, {'color': color} );
													};

													component.controls.FontSize.update = function () {
														this.setValue( self.readCSS( selector, 'font-size' ) );
													};

													component.controls.FontSize.input = function ( $element, dom ) {
														self.writeCSS( selector, {'font-size': dom.value + this.getUM()} );
													};

													component.controls.LineHeight.update = function () {
														this.setValue( self.readCSS( selector, 'line-height' ) );
													};

													component.controls.LineHeight.input = function ( $element, dom ) {
														self.writeCSS( selector, {'line-height': dom.value + this.getUM()} );
													};
												} );
											},
											/**
											 * Open fonts drop panel for current element
											 * @param $element
											 * @param dom
											 * @returns {boolean}
											 */
											openFonts: function ( $element, dom ) {
												var selector = dom.getAttribute( 'data-selector' );
												this.components[selector].controls['FontManager'].open( $element, dom );
												this.components[selector].controls['FontManager'].readFont();

												return false;
											},
											/**
											 * Clear font for current element
											 * @param $element
											 * @param dom
											 */
											clearFont: function ( $element, dom ) {
												var selector = dom.getAttribute( 'data-selector' );

												this.writeCSS( selector, {'font-family': ''} );

												this.components[selector].controls['FontManager'].update();
											},
											/**
											 * Read CSS rule for the specified selector
											 * @param selector
											 * @param rule
											 * @returns {{}}
											 */
											readCSS: function ( selector, rule ) {
												var css = TVE.head_css_get( '#tve_editor ' + selector, [rule] );

												css = css && css.length ? css[0] : '';

												if ( css === '' ) {
													css = TVE.ActiveElement.find( selector ).first().css( rule ) || css;
												}

												return css;
											},
											/**
											 * Write general css in head for all elements from the editor
											 * @param selector
											 * @param rule
											 */
											writeCSS: function ( selector, rule ) {
												var media = TVE.main.media_query_tpl();

												media = media === '_ALL' ? TVE.main.all_media() : [media];

												TVE.write_css( '#tve_editor ' + selector, rule, media, true );

												this.$buttons.removeClass( 'tcb-disabled' );
											},
											/**
											 * Toggle slide down/up components
											 * @param e
											 */
											toggleControls: function ( e ) {
												var prop = e.currentTarget.getAttribute( 'data-prop' );

												this.toggleDropdown( prop );
											},
											/**
											 * Update components when setConfig is called
											 */
											setConfig: function () {
												this.update();
											},
											/**
											 * Update all controls from all the landing page font components
											 */
											update: function () {
												_.each( this.components, function ( component ) {
													_.each( component.controls, function ( control ) {
														control.update( control.applyTo() );
													} );
												} );
											},

											applyToAll: function ( $element, dom ) {
												if ( dom.classList.contains( 'tcb-disabled' ) ) {
													return;
												}

												var selector = dom.getAttribute( 'data-selector' ),
													values = {
														FontManager: {'font-family': this.readCSS( selector, 'font-family' )},
														ColorPicker: {'color': this.readCSS( selector, 'color' )}
													}, self = this;

												_.each( this.components, function ( component, sel ) {
													if ( sel === selector || sel.indexOf( 'h' ) === - 1 ) {
														return;
													}

													_.each( component.controls, function ( control, style ) {
														self.writeCSS( sel, values[style] );
													} );
												} );

												this.update();

												this.$buttons.addClass( 'tcb-disabled' )
											}
										} );
									})( jQuery );
								},
								"lp-scripts.js": function (exports, module, require) {
									var base = require( '../../base' );

									module.exports = base.component.extend( {
										controls_init: function () {
											this.$( 'textarea' ).each( function () {
												this.value = TVE.CONST.tve_global_scripts[this.getAttribute( 'data-location' )] || '';
											} ).on( 'blur', function () {
												TVE.CONST.tve_global_scripts[this.getAttribute( 'data-location' )] = this.value;
											} );
										}
									} );
								}
							},
							"layout.js": function (exports, module, require) {
								var base = require( '../base' ),
									marginAndPadding = require( '../controls/margin-padding' ),
									maxWidth = require( '../controls/max-width' ),
									buttonGroup = require( '../controls/button-group' ),
									input = require( '../controls/input' ),
									positionFrom = require( '../controls/position-from' );

								module.exports = base.component.extend( {
									template: TVE.tpl( 'controls/layout' ),
									initialize: function () {
										var self = this;

										this.render();

										this.hide();

										this.controls = {
											MarginAndPadding: new marginAndPadding( {
												el: this.$( '.tve-control[data-view="MarginAndPadding"]' )
											} ),
											MaxWidth: new maxWidth( {
												el: this.$( '.tve-control[data-view="MaxWidth"]' ),
												model: {
													config: {
														min: 1,
														max: 100,
														label: 'Max width',//TODO: add translations
														um: ['px', '%'],
														css: 'maxWidth'
													}
												}
											} ),
											Alignment: new buttonGroup( {
												el: this.$( '.tve-control[data-view="Alignment"]' ),
												model: {
													config: {
														name: 'Alignment',
														is_advanced: true,
														buttons: [
															{icon: 'none', value: 'none', default: true},
															{icon: 'left', value: 'left'},
															{icon: 'center', value: 'center'},
															{icon: 'right', value: 'right'}//TODO: change icons
														]
													}
												}
											} ),
											Float: new buttonGroup( {
												el: this.$( '.tve-control[data-view="Float"]' ),
												model: {
													config: {
														name: 'Float',
														buttons: [
															{icon: 'none', value: 'both'},
															{icon: 'check', value: 'none', default: true}
														]
													}
												}
											} ),
											Position: new buttonGroup( {
												el: this.$( '.tve-control[data-view="Position"]' ),
												model: {
													config: {
														name: 'Position',
														buttons: [
															{icon: '', text: 'Auto', value: 'auto', default: true},
															{icon: '', text: 'Relative', value: 'relative'},
															{icon: '', text: 'Absolute', value: 'absolute'}
														]
													}
												}
											} ),
											zIndex: new input( {
												el: this.$( '.tve-control[data-view="zIndex"]' ),
												model: {
													config: {
														name: 'Z-index',
														type: 'number',
														min: 0
													}
												}
											} ),
											PositionFrom: new positionFrom( {
												el: this.$( '.tve-control[data-view="PositionFrom"]' )
											} )
										};

										this.controls_init( this.controls );

									},
									controls_init: function ( controls ) {

										controls.Alignment.change = function ( $element, dom ) {
											var alignment = dom.getAttribute( 'data-value' );
											if ( ['left', 'right'].indexOf( alignment ) !== - 1 ) {
												$element.head_css( {float: alignment, position: 'relative', 'z-index': 4} );
												if ( ! $element.attr( 'data-clear' ) ) {
													$element.attr( 'data-clear', 'both' );
													$element.head_css( {'clear': 'both'}, null, ' + div' );
												}
												controls.Float.update();
											} else if ( alignment === 'center' ) {
												$element.head_css( {'margin-left': 'auto !important', 'margin-right': 'auto !important'} );
												controls.MarginAndPadding.update( controls.MarginAndPadding.readFrom() );
												$element.head_css( {'float': ''} );
											} else {
												$element.head_css( {'float': ''} );
												$element.head_css( {'margin-left': '', 'margin-right': ''} );
												controls.MarginAndPadding.update( controls.MarginAndPadding.readFrom() );
											}

											TVE.Editor_Page.reposition_icons();
										};

										controls.Alignment.update = function () {
											var $element = this.applyTo(),
												float = $element.css( 'float' );

											if ( ['left', 'right'].indexOf( float ) !== - 1 ) {
												this.setActive( float );
											} else {
												var marginL = controls.MarginAndPadding.getValue( 'margin', 'left' ),
													marginR = controls.MarginAndPadding.getValue( 'margin', 'right' );

												if ( marginL === 'auto' && marginR === 'auto' ) {
													this.setActive( 'center' );
												} else {
													this.setActive( 'none' );
												}
											}
										};

										controls.Position.change = function ( $element, dom ) {
											var position = dom.getAttribute( 'data-value' );

											position = position === 'auto' ? '' : position;

											$element.head_css( {'position': position} );
										};

										controls.Position.update = function () {
											var position = this.applyTo().head_css( 'position' ) || this.applyTo().css( 'position' );
											this.setActive( position );
										};

										controls.Float.change = function ( $element, dom ) {
											var clear = dom.getAttribute( 'data-value' );
											$element.head_css( {'clear': clear}, null, ' + div' );
											$element.attr( 'data-clear', clear );
											TVE.Editor_Page.reposition_icons();
										};

										controls.Float.update = function () {
											var value = this.applyTo().attr( 'data-clear' ),
												clear = value ? value : 'none';
											this.setActive( clear );
										};

										controls.zIndex.input = function ( $element, dom ) {
											$element.head_css( {'z-index': dom.value} );
										};

										controls.zIndex.update = function () {
											var zIndex = this.applyTo().head_css( 'z-index' ) || this.applyTo().css( 'z-index' );

											if ( zIndex === 'auto' || isNaN( zIndex ) ) {
												zIndex = 0;
											}

											this.setValue( zIndex );
										};
									},
									render: function () {
										this.$el.html( this.template() );
									},
									disable_extra_controls: function ( disabled_controls ) {
										if ( disabled_controls.indexOf( 'padding' ) !== - 1 ) {
											this.controls.MarginAndPadding.disable_control( 'padding' );
										}
									}
								} );
							},
							"lead-generation": {
								"checkbox.js": function (exports, module, require) {
									/**
									 * Created by dan bilauca on 6/2/2017.
									 */

									var base = require( '../../base' );

									module.exports = base.component.extend( {

										$active_element: null,

										controls_init: function () {

											this.controls['columns_number'].update = function ( $element ) {
												var _value = $element.attr( 'data-column' ) ? $element.attr( 'data-column' ) : '';

												if ( _value.length <= 0 ) {
													for ( var i = 1; i <= 10; i ++ ) {
														if ( $element.is( '.tve_lg_column' + i ) ) {
															_value = i;
															$element.attr( 'data-column', i );
															break;
														}
													}
												}

												this.setValue( _value );
											};
											this.controls['columns_number'].input = function ( $element, dom ) {
												$element.removeClass( 'tve_lg_column' + $element.attr( 'data-column' ) );
												$element.addClass( 'tve_lg_column' + dom.value );
												$element.attr( 'data-column', dom.value );
											};

											/**
											 * required field control
											 */
											this.controls['required'].update = function ( $element ) {
												var _required = $element.find( 'input' )[0].dataset.required;
												this.setChecked( _required && _required === '1' );
											};
											this.controls['required'].input = function ( $element, dom ) {
												$element.find( 'input' ).attr( 'data-required', dom.checked ? 1 : 0 );
											};

										},

										exit_edit_mode: function () {
											TVE.ActiveElement = TVE.ActiveElement.parents( '.thrv_lead_generation' ).first().click();
											TVE.Components['lead_generation'].$el.find( '[data-fn="cancel_components"]' ).click();
										}
									} );
								},
								"input.js": function (exports, module, require) {
									/**
									 * Created by dan bilauca on 6/2/2017.
									 */

									var base = require( '../../base' );

									module.exports = base.component.extend( {

										$active_element: null,

										controls_init: function () {

											var self = this;

											/**
											 * Icon Side Control
											 * @param $element
											 */
											this.controls['icon_side'].update = function ( $element ) {

												if ( this.applyTo().filter( '.edit_mode' ).find( '.thrv_icon' ).length <= 0 ) {
													this.$el.hide();
													this.$el.next().hide();
													return;
												} else {
													this.$el.show();
													this.$el.next().show();
												}

												var right = this.applyTo().head_css( 'right', true, this.config.css_suffix, true, this.config.css_prefix ),
													left = this.applyTo().head_css( 'left', true, this.config.css_suffix, true, this.config.css_prefix );

												right = parseInt( right );
												left = parseInt( left );

												var value = right === 0 ? 'right' : 'left';

												this.setActive( value );

											};
											this.controls['icon_side'].input = function ( $element, dom ) {
												var value = dom.dataset.value,
													css = value === 'left' ? {
														left: 0,
														right: 'auto',
														transform: 'translate(50%, -50%)'
													} : {
														right: 0,
														left: 'auto',
														transform: 'translate(-50%, -50%)'
													};

												this.applyTo().head_css( css, null, this.config.css_suffix, true, this.config.css_prefix );
											};

											/**
											 * checkbox to modify similar elements
											 * @param $element
											 */
											this.controls['multiple_elements'].update = function ( $element ) {

												//set it local to be used elsewhere
												self.$active_element = $element;

												if ( this.isChecked() ) {
													TVE.ActiveElement = self._get_similar_elements();
												}
											};
											this.controls['multiple_elements'].input = function ( $element, input ) {

												if ( this.isChecked() ) {
													TVE.ActiveElement = self._get_similar_elements();
												} else {
													TVE.ActiveElement = $element.filter( '.edit_mode' );
												}
											};

											/**
											 * placeholder control
											 */
											this.controls['placeholder'].update = function ( $element ) {
												//filter $element because it might contain similar elements too
												this.setValue( $element.filter( '.edit_mode' ).find( 'input' ).attr( 'placeholder' ) );
											};
											this.controls['placeholder'].input = function ( $element, input ) {
												//filter $element because it might contain similar elements too
												$element.filter( '.edit_mode' ).find( 'input' )
												        .attr( 'placeholder', this.getValue() )
												        .attr( 'data-placeholder', this.getValue() );
											};

											/**
											 * Icon Modal Picker
											 */
											this.controls['ModalPicker'].setModal( TVE.IconsModal.get_instance( TVE.modal.get_element( 'icons' ) ) );
											this.controls['ModalPicker'].input = function ( $element, data ) {
												var html;

												$element = $element.removeClass( 'aligncenter' ).filter( '.edit_mode' );
												$element.find( '.thrv_icon' ).remove();

												if ( data.icon.is( '.tve-svg-icon' ) ) {
													var $symbol = jQuery( 'symbol#' + data.icon.data( 'cls' ) );
													html = TVE.svg_icon( {
														path: $symbol.html(),
														viewBox: $symbol[0].getAttribute( 'viewBox' ),
														name: $symbol.find( '> title' ).text()
													} );

												} else {
													html = '<span data-name="' + data.icon.data( 'cls' ).replace( 'icon-', '' ) + '" class="tve_sc_icon ' + data.icon.data( 'cls' ) + '"></span>';
												}

												$element.prepend( '<div class="thrv_wrapper thrv_icon">' + html + '</div>' );
												this.update();
												this.component.controls['icon_side'].update();
											};
											this.controls['ModalPicker'].update = function () {
												var $icon = this.applyTo().filter( '.edit_mode' ).find( '.thrv_icon' );
												if ( $icon.length ) {
													this.$el.hide();
													this.$el.prev().hide();
												} else {
													this.updateValue( 'none' );
													this.$el.show();
													this.$el.prev().show();
												}
											};

											/**
											 * required field control
											 */
											this.controls['required'].update = function ( $element ) {
												var _required = $element.find( 'input' )[0].dataset.required;
												this.setChecked( _required && _required === '1' );
											};
											this.controls['required'].input = function ( $element, dom ) {
												$element.find( 'input' ).attr( 'data-required', dom.checked ? 1 : 0 );
											};
										},

										/**
										 * get all similar elements from parent
										 * @returns {*|{}}
										 * @private
										 */
										_get_similar_elements: function () {

											return this.$active_element
											           .parents( '.tve_lead_generated_inputs_container' )
											           .first()
											           .find( '.tve_lg_input ' );
										},

										exit_edit_mode: function () {
											TVE.ActiveElement = TVE.ActiveElement.parents( '.thrv_lead_generation' ).first().click();
											TVE.Components['lead_generation'].$el.find( '[data-fn="cancel_components"]' ).click();
										}
									} );
								},
								"radio.js": function (exports, module, require) {
									/**
									 * Created by dan bilauca on 6/2/2017.
									 */

									var base = require( '../../base' );

									module.exports = base.component.extend( {

										$active_element: null,

										controls_init: function () {

											this.controls['columns_number'].update = function ( $element ) {
												var _value = $element.attr( 'data-column' ) ? $element.attr( 'data-column' ) : '';

												if ( _value.length <= 0 ) {
													for ( var i = 1; i <= 10; i ++ ) {
														if ( $element.is( '.tve_lg_column' + i ) ) {
															_value = i;
															$element.attr( 'data-column', i );
															break;
														}
													}
												}

												this.setValue( _value );
											};
											this.controls['columns_number'].input = function ( $element, dom ) {
												$element.removeClass( 'tve_lg_column' + $element.attr( 'data-column' ) );
												$element.addClass( 'tve_lg_column' + dom.value );
												$element.attr( 'data-column', dom.value );
											};

											/**
											 * required field control
											 */
											this.controls['required'].update = function ( $element ) {
												var _required = $element.find( 'input' )[0].dataset.required;
												this.setChecked( _required && _required === '1' );
											};
											this.controls['required'].input = function ( $element, dom ) {
												$element.find( 'input' ).attr( 'data-required', dom.checked ? 1 : 0 );
											};

										},

										exit_edit_mode: function () {
											TVE.ActiveElement = TVE.ActiveElement.parents( '.thrv_lead_generation' ).first().click();
											TVE.Components['lead_generation'].$el.find( '[data-fn="cancel_components"]' ).click();
										}
									} );
								},
								"select.js": function (exports, module, require) {
									/**
									 * Created by dan bilauca on 6/2/2017.
									 */

									var base = require( '../../base' );

									module.exports = base.component.extend( {

										$active_element: null,

										controls_init: function () {

											var self = this;

											/**
											 * Icon Side Control
											 * @param $element
											 */
											this.controls['icon_side'].update = function ( $element ) {

												if ( this.applyTo().filter( '.edit_mode' ).find( '.thrv_icon' ).length <= 0 ) {
													this.$el.hide();
													this.$el.next().hide();
													return;
												} else {
													this.$el.show();
													this.$el.next().show();
												}

												var right = this.applyTo().head_css( 'right', true, this.config.css_suffix, true, this.config.css_prefix ),
													left = this.applyTo().head_css( 'left', true, this.config.css_suffix, true, this.config.css_prefix );

												right = parseInt( right );
												left = parseInt( left );

												var value = right === 0 ? 'right' : 'left';

												this.setActive( value );

											};
											this.controls['icon_side'].input = function ( $element, dom ) {
												var value = dom.dataset.value,
													css = value === 'left' ? {
														left: 0,
														right: 'auto',
														transform: 'translate(50%, -50%)'
													} : {
														right: 0,
														left: 'auto',
														transform: 'translate(-50%, -50%)'
													};

												this.applyTo().head_css( css, null, this.config.css_suffix, true, this.config.css_prefix );
											};

											/**
											 * checkbox to modify similar elements
											 * @param $element
											 */
											this.controls['multiple_elements'].update = function ( $element ) {

												//set it local to be used elsewhere
												self.$active_element = $element;

												if ( this.isChecked() ) {
													TVE.ActiveElement = self._get_similar_elements();
												}
											};
											this.controls['multiple_elements'].input = function ( $element, input ) {

												if ( this.isChecked() ) {
													TVE.ActiveElement = self._get_similar_elements();
												} else {
													TVE.ActiveElement = $element.filter( '.edit_mode' );
												}
											};

											/**
											 * placeholder control
											 */
											this.controls['placeholder'].update = function ( $element ) {
												//filter $element because it might contain similar elements too
												this.setValue( $element.filter( '.edit_mode' ).find( 'select' ).attr( 'data-placeholder' ) );
											};
											this.controls['placeholder'].input = function ( $element, input ) {
												var $select = $element.filter( '.edit_mode' ).find( 'select' ).first();
												$select
													.attr( 'data-placeholder', this.getValue() )
													.find( 'option' ).first().text( this.getValue() );
											};

											/**
											 * Icon Modal Picker
											 */
											this.controls['ModalPicker'].setModal( TVE.IconsModal.get_instance( TVE.modal.get_element( 'icons' ) ) );
											this.controls['ModalPicker'].input = function ( $element, data ) {
												var html;

												$element = $element.removeClass( 'aligncenter' ).filter( '.edit_mode' );
												$element.find( '.thrv_icon' ).remove();

												if ( data.icon.is( '.tve-svg-icon' ) ) {
													var $symbol = jQuery( 'symbol#' + data.icon.data( 'cls' ) );
													html = TVE.svg_icon( {
														path: $symbol.html(),
														viewBox: $symbol[0].getAttribute( 'viewBox' ),
														name: $symbol.find( '> title' ).text()
													} );

												} else {
													html = '<span data-name="' + data.icon.data( 'cls' ).replace( 'icon-', '' ) + '" class="tve_sc_icon ' + data.icon.data( 'cls' ) + '"></span>';
												}

												$element.prepend( '<div class="thrv_wrapper thrv_icon">' + html + '</div>' );
												this.update();
												this.component.controls['icon_side'].update();
											};
											this.controls['ModalPicker'].update = function () {
												var $icon = this.applyTo().filter( '.edit_mode' ).find( '.thrv_icon' );
												if ( $icon.length ) {
													this.$el.hide();
													this.$el.prev().hide();
												} else {
													this.updateValue( 'none' );
													this.$el.show();
													this.$el.prev().show();
												}
											};

											/**
											 * required field control
											 */
											this.controls['required'].update = function ( $element ) {
												var _required = $element.find( 'select' )[0].dataset.required;
												this.setChecked( _required && _required === '1' );
											};
											this.controls['required'].input = function ( $element, dom ) {
												$element.find( 'select' ).attr( 'data-required', dom.checked ? 1 : 0 );
											};
										},

										/**
										 * get all similar elements from parent
										 * @returns {*|{}}
										 * @private
										 */
										_get_similar_elements: function () {

											return this.$active_element
											           .parents( '.tve_lead_generated_inputs_container' )
											           .first()
											           .find( '.tve_lg_dropdown' );
										},

										exit_edit_mode: function () {
											TVE.ActiveElement = TVE.ActiveElement.parents( '.thrv_lead_generation' ).first().click();
											TVE.Components['lead_generation'].$el.find( '[data-fn="cancel_components"]' ).click();
										}
									} );
								},
								"submit.js": function (exports, module, require) {
									/**
									 * Created by dan bilauca on 6/2/2017.
									 */

									var base = require( '../../base' );

									module.exports = base.component.extend( {

										controls_init: function () {

											/**
											 * Icon Side Control
											 * @param $element
											 */
											this.controls['icon_side'].update = function ( $element ) {

												if ( $element.length <= 0 ) {
													this.$el.hide();
													this.$el.next().hide();
													return;
												} else {
													this.$el.show();
													this.$el.next().show();
												}

												var right = this.applyTo().head_css( 'right', true, this.config.css_suffix, true, this.config.css_prefix ),
													left = this.applyTo().head_css( 'left', true, this.config.css_suffix, true, this.config.css_prefix );

												right = parseInt( right );
												left = parseInt( left );

												var value = right === 0 ? 'right' : 'left';

												this.setActive( value );

											};
											this.controls['icon_side'].input = function ( $element, dom ) {
												var value = dom.dataset.value,
													css = value === 'left' ? {
														left: 0,
														right: 'auto',
														transform: 'translate(50%, -50%)'
													} : {
														right: 0,
														left: 'auto',
														transform: 'translate(-50%, -50%)'
													};

												this.applyTo().head_css( css, null, this.config.css_suffix, true, this.config.css_prefix );
											};

											/**
											 * Icon Modal Picker
											 */
											this.controls['ModalPicker'].setModal( TVE.IconsModal.get_instance( TVE.modal.get_element( 'icons' ) ) );
											this.controls['ModalPicker'].input = function ( $element, data ) {
												var html;

												$element = $element.removeClass( 'aligncenter' ).filter( '.edit_mode' );
												$element.find( '.thrv_icon' ).remove();

												if ( data.icon.is( '.tve-svg-icon' ) ) {
													var $symbol = jQuery( 'symbol#' + data.icon.data( 'cls' ) );
													html = TVE.svg_icon( {
														path: $symbol.html(),
														viewBox: $symbol[0].getAttribute( 'viewBox' ),
														name: $symbol.find( '> title' ).text()
													} );

												} else {
													html = '<span data-name="' + data.icon.data( 'cls' ).replace( 'icon-', '' ) + '" class="tve_sc_icon ' + data.icon.data( 'cls' ) + '"></span>';
												}

												$element.prepend( '<div class="thrv_wrapper thrv_icon">' + html + '</div>' );
												this.update();
												this.component.controls['icon_side'].update( $element );
											};
											this.controls['ModalPicker'].update = function () {
												var $icon = this.applyTo().find( '.thrv_icon' );
												if ( $icon.length ) {
													this.$el.hide();
													this.$el.next().hide();
													var $child = $icon.children().first(),
														icon_name = $child.data( 'tve-icon' ) || $child.data( 'name' );
													this.updateValue( icon_name );
												} else {
													this.updateValue( 'none' );
													this.$el.show();
													this.$el.next().show();
												}
											};
										},

										exit_edit_mode: function () {
											TVE.ActiveElement = TVE.ActiveElement.parents( '.thrv_lead_generation' ).first().click();
											TVE.Components['lead_generation'].$el.find( '[data-fn="cancel_components"]' ).click();
										}
									} );
								},
								"textarea.js": function (exports, module, require) {
									/**
									 * Created by dan bilauca on 6/2/2017.
									 */

									var base = require( '../../base' );

									module.exports = base.component.extend( {

										$active_element: null,

										controls_init: function () {

											var self = this;

											/**
											 * Icon Side Control
											 * @param $element
											 */
											this.controls['icon_side'].update = function ( $element ) {

												if ( this.applyTo().filter( '.edit_mode' ).find( '.thrv_icon' ).length <= 0 ) {
													this.$el.hide();
													this.$el.next().hide();
													return;
												} else {
													this.$el.show();
													this.$el.next().show();
												}

												var right = this.applyTo().head_css( 'right', true, this.config.css_suffix, true, this.config.css_prefix ),
													left = this.applyTo().head_css( 'left', true, this.config.css_suffix, true, this.config.css_prefix );

												right = parseInt( right );
												left = parseInt( left );

												var value = right === 0 ? 'right' : 'left';

												this.setActive( value );

											};
											this.controls['icon_side'].input = function ( $element, dom ) {
												var value = dom.dataset.value,
													css = value === 'left' ? {
														left: 0,
														right: 'auto',
														transform: 'translate(50%, -50%)'
													} : {
														right: 0,
														left: 'auto',
														transform: 'translate(-50%, -50%)'
													};

												this.applyTo().head_css( css, null, this.config.css_suffix, true, this.config.css_prefix );
											};

											/**
											 * checkbox to modify similar elements
											 * @param $element
											 */
											this.controls['multiple_elements'].update = function ( $element ) {

												//set it local to be used elsewhere
												self.$active_element = $element;

												if ( this.isChecked() ) {
													TVE.ActiveElement = self._get_similar_elements();
												}
											};
											this.controls['multiple_elements'].input = function ( $element, input ) {

												if ( this.isChecked() ) {
													TVE.ActiveElement = self._get_similar_elements();
												} else {
													TVE.ActiveElement = $element.filter( '.edit_mode' );
												}
											};

											/**
											 * placeholder control
											 */
											this.controls['placeholder'].update = function ( $element ) {
												//filter $element because it might contain similar elements too
												this.setValue( $element.filter( '.edit_mode' ).find( 'textarea' ).attr( 'placeholder' ) );
											};
											this.controls['placeholder'].input = function ( $element, input ) {
												//filter $element because it might contain similar elements too
												$element.filter( '.edit_mode' ).find( 'textarea' )
												        .attr( 'placeholder', this.getValue() )
												        .attr( 'data-placeholder', this.getValue() );
											};

											/**
											 * Icon Modal Picker
											 */
											this.controls['ModalPicker'].setModal( TVE.IconsModal.get_instance( TVE.modal.get_element( 'icons' ) ) );
											this.controls['ModalPicker'].input = function ( $element, data ) {
												var html;

												$element = $element.removeClass( 'aligncenter' ).filter( '.edit_mode' );
												$element.find( '.thrv_icon' ).remove();

												if ( data.icon.is( '.tve-svg-icon' ) ) {
													var $symbol = jQuery( 'symbol#' + data.icon.data( 'cls' ) );
													html = TVE.svg_icon( {
														path: $symbol.html(),
														viewBox: $symbol[0].getAttribute( 'viewBox' ),
														name: $symbol.find( '> title' ).text()
													} );

												} else {
													html = '<span data-name="' + data.icon.data( 'cls' ).replace( 'icon-', '' ) + '" class="tve_sc_icon ' + data.icon.data( 'cls' ) + '"></span>';
												}

												$element.prepend( '<div class="thrv_wrapper thrv_icon">' + html + '</div>' );
												this.update();
												this.component.controls['icon_side'].update();
											};
											this.controls['ModalPicker'].update = function () {
												var $icon = this.applyTo().filter( '.edit_mode' ).find( '.thrv_icon' );
												if ( $icon.length ) {
													this.$el.hide();
													this.$el.prev().hide();
												} else {
													this.updateValue( 'none' );
													this.$el.show();
													this.$el.prev().show();
												}
											};

											/**
											 * required field control
											 */
											this.controls['required'].update = function ( $element ) {
												var _required = $element.find( 'textarea' )[0].dataset.required;
												this.setChecked( _required && _required === '1' );
											};
											this.controls['required'].input = function ( $element, dom ) {
												$element.find( 'textarea' ).attr( 'data-required', dom.checked ? 1 : 0 );
											};
										},

										/**
										 * get all similar elements from parent
										 * @returns {*|{}}
										 * @private
										 */
										_get_similar_elements: function () {

											return this.$active_element
											           .parents( '.tve_lead_generated_inputs_container' )
											           .first()
											           .find( '.tve_lg_textarea ' );
										},

										exit_edit_mode: function () {
											TVE.ActiveElement = TVE.ActiveElement.parents( '.thrv_lead_generation' ).first().click();
											TVE.Components['lead_generation'].$el.find( '[data-fn="cancel_components"]' ).click();
										}
									} );
								}
							},
							"lead-generation.js": function (exports, module, require) {
								/**
								 * Created by dan bilauca on 5/22/2017.
								 */
								(function ( $ ) {

									var filter_dragenter_icon = function ( value, $elem ) {
										if ( ! value ) {
											return value;
										}

										if ( $elem.is( '.thrv_icon' ) ) {
											value = false;
										}

										return value;
									};

									var base = require( '../base' ),
										lead_generation = require( '../../models/lead-generation' ),
										draggable = {},
										selection_manager = {
											canvas_mode: true,
											elements: {
												mouseover: '.canvas-mode .tve_lg_input_container',
												editable: '.canvas-mode .tve_lg_input_container'
											}
										};

									TVE.LGErrorMessages = require( '../modals/lg-error-messages' );
									TVE.LGSubmitOptions = require( '../modals/lg-submit-options' );

									module.exports = base.component.extend( {

										migrate_element: function ( $element ) {

											var $container = $element.find( '.tve_lead_generated_inputs_container' ),
												$columns = $( '<div class="thrv_wrapper thrv-columns"><div class="tcb-flex-row"></div></div>' ),
												$row = $columns.find( '.tcb-flex-row' ),
												$inputs = $container.find( '.tve_lg_input_container' );

											$inputs.each( function () {
												var $this = $( this ),
													$input = $this.clone();

												$row.append( $input );
												$input.wrap( '<div class="tcb-flex-col"></div>' );

												$this.remove();
											} );

											$row.addClass( 'tcb--cols--' + $inputs.length );
											$container.append( $columns );

											$element.removeClass( 'thrv_lead_generation_horizontal' );
										},

										needs_update: function ( $element ) {

											return $element.hasClass( 'thrv_lead_generation_horizontal' );
										},

										controls_init: function () {

											var self = this;

											TVE.add_filter( 'draggable_elements', function ( elements ) {
												return elements + ', .canvas-mode .tve_lg_input_container';
											} );

											TVE.add_filter( 'non_draggable', function ( elements ) {
												return elements + ', .tve_lead_generated_inputs_container .thrv-columns';
											} );

											/**
											 * Captcha control
											 */
											this.controls['Captcha'].update = function () {

												var _site_key = this.config.config.site_key;
												this.$el.next().toggleClass( 'tcb-hidden', _site_key.length > 0 );

												if ( ! _site_key.length > 0 ) {
													this.disable();

													return this;
												}

												var is_checked = self.leadGenerationModel.get( 'captcha' )._use_captcha === '1';

												self.leadGenerationModel.get( 'captcha' ).site_key = _site_key;

												this.setChecked( is_checked );
												this.$el.parent().find( '#tcb-lg-captcha-controls' ).toggleClass( 'tcb-hidden', ! is_checked );
											};
											this.controls['Captcha'].input = function ( $element, dom ) {

												var use_captcha = dom.checked ? 1 : 0,
													_captcha = self.leadGenerationModel.get( 'captcha' );

												_captcha = $.extend( _captcha, {
													_use_captcha: use_captcha
												} );

												this.$el.parent().find( '#tcb-lg-captcha-controls' ).toggleClass( 'tcb-hidden', ! dom.checked );

												self.leadGenerationModel.set( 'captcha', _captcha );
												self.leadGenerationView.write( 'captcha' );

											};

											/**
											 * Captcha Theme
											 */
											this.controls['CaptchaTheme'].update = function () {
												var _theme = self.leadGenerationModel.get( 'captcha' )._captcha_theme;
												this.setValue( _theme );
											};
											this.controls['CaptchaTheme'].input = function ( $element, dom ) {

												var _captcha_settings = self.leadGenerationModel.get( 'captcha' );

												_captcha_settings._captcha_theme = dom.value;

												self.leadGenerationModel.set( {
													captcha: _captcha_settings,
													write: 'captcha'
												} );
											};

											/**
											 * Captcha Type
											 */
											this.controls['CaptchaType'].update = function () {
												var _type = self.leadGenerationModel.get( 'captcha' )._captcha_type;
												this.setValue( _type );
											};
											this.controls['CaptchaType'].input = function ( $element, dom ) {

												var _captcha_settings = self.leadGenerationModel.get( 'captcha' );

												_captcha_settings._captcha_type = dom.value;

												self.leadGenerationModel.set( {
													captcha: _captcha_settings,
													write: 'captcha'
												} );
											};

											/**
											 * Captcha Size
											 */
											this.controls['CaptchaSize'].update = function () {
												var _size = self.leadGenerationModel.get( 'captcha' )._captcha_size;
												this.setValue( _size );
											};
											this.controls['CaptchaSize'].input = function ( $element, dom ) {
												var _captcha_settings = self.leadGenerationModel.get( 'captcha' );

												_captcha_settings._captcha_size = dom.value;

												self.leadGenerationModel.set( {
													captcha: _captcha_settings,
													write: 'captcha'
												} );
											};
										},

										placeholder_action: function () {

											this.before_update();
											this.controls['ApiConnections'].serviceConnect();
										},

										cancel_components: function ( event, dom ) {

											this.toggle_controls( true );

											dom.innerHTML = 'Edit Components';//todo: translate this
											dom.setAttribute( 'data-fn', 'edit_components' );

											TVE.Editor_Page.enable();
											TVE.ActiveElement.removeClass( 'canvas-mode' );
											TVE.drag.editorActions();

											TVE.prevent_blur = false;

											TVE.remove_filter( 'allow_dragenter', filter_dragenter_icon );
										},

										toggle_controls: function ( show ) {

											if ( typeof show !== 'boolean' ) {
												return;
											}

											var _method = show ? 'show' : 'hide';

											this.$( '.tve-advanced-controls' )[_method]();

											_.each( this.controls, function ( control_view ) {
												control_view[_method]();
												control_view.$el.siblings( 'hr' )[_method]();
											} );
										},

										edit_components: function ( event, dom ) {

											this.toggle_controls( false );

											dom.innerHTML = 'Exit Edit Components';//todo: translate this
											dom.setAttribute( 'data-fn', 'cancel_components' );

											TVE.add_filter( 'allow_dragenter', filter_dragenter_icon );

											/**
											 * Copy icon styles on main parent element
											 */
											TVE.ActiveElement.find( '.thrv_icon' ).each( function ( index, dom ) {

												if ( this.getAttribute( 'data-css' ) ) {
													return;
												}

												var $this = TVE.inner.jQuery( this ),
													$span = $this.children().first(),
													wrapper_css = [
														'border-style',
														'border-radius',
														'border-width',
														'border-color',
														'margin'
													],
													span_css = [
														'padding',
														'border-radius',
														'font-size',
														'width',
														'height',
														'color'
													];

												var span_styles = $span.head_css( span_css, false, '', true ),
													wrapper_styles = $this.head_css( wrapper_css, false, '', true );

												wrapper_styles.padding = span_styles.padding;
												delete span_styles.padding;


												wrapper_styles.width = span_styles.width;
												delete span_styles.width;

												wrapper_styles.height = span_styles.height;
												delete span_styles.height;

												wrapper_styles['font-size'] = span_styles['font-size'];
												delete span_styles['font-size'];

												$span.removeAttr( 'style' );
												//$this.head_css( span_styles );

												$this.removeAttr( 'style' );
												$this.head_css( wrapper_styles, null, '', false, '#tve_editor ' );
											} );

											/**
											 * Make button text editable
											 */
											TVE.ActiveElement.find( 'button' ).each( function () {
												this.innerHTML = '<span>' + this.innerText + '</span>';
											} );

											TVE.Editor_Page.disable( true );

											TVE.ActiveElement.addClass( 'canvas-mode' );

											TVE.Editor_Page.selection_manager.init( TVE.ActiveElement );
											TVE.state( TVE.STATE_DEFAULT );
											TVE.prevent_blur = true;

											TVE.drag.editorActions( TVE.ActiveElement );
										},
										/* After update we read the config from the form */
										before_update: function () {

											if ( this.leadGenerationModel ) {
												/* just clear all attributes of the model. all the attributes will be completed after the  */
												this.leadGenerationModel.clear( {silent: true} );
											} else {
												this.leadGenerationModel = new lead_generation.model();
											}

											/* save a reference of the model in the element so we can have easier access to it */
											TVE.ActiveElement.data( 'lg', this.leadGenerationModel );

											if ( this.leadGenerationView ) {
												/* change the current active element */
												this.leadGenerationView.setElement( TVE.ActiveElement[0] );
												/* read the config from the new element */
												this.leadGenerationView.read();
											} else {
												/* instantiate a new Backbone View over the active form that will handle the read and write */
												this.leadGenerationView = new lead_generation.view( {
													el: TVE.ActiveElement[0],
													model: this.leadGenerationModel
												} );
											}
										},

										/**
										 * opens a modal that allows user to set what happens
										 * after a LG Element is submitted
										 */
										manage_submit_options: function () {

											var self = this,
												_options = [
													{
														key: 'redirect',
														label: 'Redirect to Custom URL', //todo: translate this
														css_class: 'tcb-lg-option-redirect'
													},
													{
														key: 'message',
														label: 'Show success notification',//todo: translate this
														css_class: 'tcb-lg-option-custom_message'
													}
													//todo: allow others/vendors to hook into
												],
												_instance = TVE.modal.get_element( 'lg-submit-options' );

											var _modal = TVE.LGSubmitOptions.get_instance( _instance, this.leadGenerationModel );
											_modal.collection = new Backbone.Collection( _options );
											_modal.render_options();

											_modal.before_save = function () {

												if ( this.model.get( 'submit_option' ) === 'message' ) {
													this.model.get( 'custom_messages' ).success = this.get_editor_content();
												}

												self.leadGenerationView.write( 'submit_option' );
											};

											_modal.open();
										},
										/**
										 * opens the error messages modal
										 * and before save action on modal sets the new errors on lgModel
										 */
										manage_error_messages: function () {

											var self = this,
												_errors = this.leadGenerationModel.get( 'error_messages' ),
												_modal = TVE.LGErrorMessages.get_instance( TVE.modal.get_element( 'lg-error-messages' ), new Backbone.Model( _errors ) );

											_modal.type = this.leadGenerationModel.get( 'type' );
											_modal.display_editor = this.leadGenerationModel.get( 'display_custom_error_message' );
											_modal.custom_messages = this.leadGenerationModel.get( 'custom_messages' );
											_modal.render_errors();

											/**
											 * read the modal settings and apply them to element
											 * by setting the leadGeneralModel
											 */
											_modal.before_save = function () {

												/**
												 * validation errors
												 */
												var _errors = this.model.toJSON();
												self.leadGenerationModel.set( {
													error_messages: _errors,
													write: 'error_messages'
												} );

												/**
												 * custom messages
												 */
												var custom_messages = {
													success: _modal.custom_messages.success || '',
													error: this.get_editor_content()
												};
												self.leadGenerationModel.set( {
													custom_messages: custom_messages,
													write: 'custom_messages'
												} );

												/**
												 * display custom error message
												 */
												self.leadGenerationModel.set( {
													display_custom_error_message: _modal.display_editor,
													write: 'display_custom_error_message'
												} );
											};

											_modal.open();
										}
									} )
								})( jQuery );
							},
							"lightbox.js": function (exports, module, require) {
								var base = require( '../base' ),
									remove_border_cls = require( '../../libs/remove-border-classes' ),
									tinycolor = require( '../../libs/tinycolor' ),
									CC_OLD_ATTR = 'data-tve-custom-colour';

								module.exports = base.component.extend( {
									/**
									 * Automatically re-apply styles on the element
									 */
									before_update: function () {
										this.auto_update_overlay();

										if ( ! TVE.ActiveElement.attr( 'style' ) && ! TVE.ActiveElement.attr( CC_OLD_ATTR ) ) {
											return;
										}
										this.auto_update( TVE.ActiveElement )
											.auto_update( TVE.ActiveElement.children( '.tve_p_lb_close' ) );

										TVE.ActiveElement.children( '.tve_p_lb_close' ).head_css( {
											'border-style': 'inherit !important',
											'border-width': 'inherit !important'
										} );

										this.update_globals( TVE.ActiveElement );
									},
									auto_update: function ( $element ) {
										var _style = {};
										if ( $element[0].style.borderWidth ) {
											_style['border-width'] = $element[0].style.borderWidth + ' !important';
										}
										if ( $element[0].style.maxWidth ) {
											_style['max-width'] = $element[0].style.maxWidth + ' !important';
										}
										if ( $element[0].style.backgroundImage ) {
											_style['background-image'] = $element[0].style.backgroundImage + ' !important';
										}
										_style['border-style'] = $element.css( 'border-style' ) + ' !important';
										_style['background-color'] = $element.css( 'background-color' ) + ' !important';
										_style['border-color'] = $element.css( 'border-color' ) + ' !important';

										if ( $element.hasClass( 'tve_p_lb_close' ) ) {
											_style['color'] = $element.css( 'color' ) + ' !important';
											_style['border-width'] = _style['border-style'] = 'inherit !important';
										}
										remove_border_cls( $element );

										$element.removeAttr( CC_OLD_ATTR ).removeAttr( 'style' ).head_css( _style );

										return this;
									},
									auto_update_overlay: function () {
										var $overlay = TVE.inner_$( '.tve_p_lb_overlay' );
										if ( $overlay[0].style.opacity || $overlay.attr( CC_OLD_ATTR ) ) {
											var color = tinycolor( $overlay.css( 'background-color' ) ),
												opacity = parseFloat( $overlay.css( 'opacity' ) || 1 );
											color.setAlpha( opacity );

											$overlay.head_css( {'background-color': color.toString() + ' !important'} );
											$overlay.removeAttr( 'style' ).removeAttr( CC_OLD_ATTR );
										}
									},
									update_globals: function ( $lb ) {
										if ( ! $lb.length ) {
											return;
										}
										/**
										 * remove old attributes from the globals config for the lightbox
										 */
										var globals = TVE.CONST.tve_globals,
											css;
										/**
										 * Content CSS attr
										 */
										if ( css = $lb.attr( 'data-css' ) ) {
											globals.content_css = css;

											/* Delete old stuff */
											delete globals.l_cb; // Content - data-tve-custom-colour attribute
											delete globals.l_cbs; // Content - custom border class
											delete globals.l_cmw; // Content - max width
											delete globals.l_ccls; // Content - class
											delete globals.l_cimg; // Content - background image
											delete globals.l_cbw; // Content - border width
										}

										if ( css = $lb.children( '.tve_p_lb_close' ).attr( 'data-css' ) ) {
											globals.close_css = css;

											delete globals.l_ccc; // Close icon - custom colors attribute
										}

										if ( css = TVE.inner_$( '.tve_p_lb_overlay' ).attr( 'data-css' ) ) {
											globals.overlay_css = css;

											delete globals.l_ob; // Overlay custom color attribute
											delete globals.l_oo; // Overlay opacity
										}
									},
									controls_init: function ( controls ) {
										var self = this;

										/**
										 * This is only loaded when editing a Thrive TCB Lightbox
										 *
										 * Before saving, make sure lightbox globals get updated
										 */
										TVE.add_filter( 'tcb_save_post_data_before', function ( data ) {

											self.update_globals( TVE.inner_$( '.tve_p_lb_content' ) );

											return data;
										} );

										function update_controls( show ) {
											self.$( '.close-controls' )[show ? 'show' : 'hide']();
										}

										controls.Switch.update = function ( $element ) {
											var visible = $element.is( ':visible' );
											this.setChecked( visible );
											update_controls( visible );
										};
										controls.Switch.change = function ( $element ) {
											$element.head_css( {display: ( this.isChecked() ? 'block' : 'none') + ' !important'} );
											update_controls( this.isChecked() );
										};

										controls.CloseColor.update = function ( $element ) {
											this.setValue( $element.css( 'color' ) );
										};
										controls.CloseColor.input = function ( color ) {
											this.applyTo().head_css( {color: color + ' !important'} );
										};

										controls.BorderColor.update = function ( $element ) {
											this.setValue( $element.css( 'border-color' ) );
										};
										controls.BorderColor.input = function ( color ) {
											this.applyTo().head_css( {'border-color': color + ' !important'} );
										};

										controls.IconBg.update = function ( $element ) {
											this.setValue( $element.css( 'background-color' ) );
										};
										controls.IconBg.input = function ( color ) {
											this.applyTo().head_css( {'background-color': color + ' !important'} );
										};

										controls.OverlayColor.update = function ( $element ) {
											this.setValue( $element.css( 'background-color' ) );
										};
										controls.OverlayColor.input = function ( color ) {
											this.applyTo().head_css( {'background-color': color + ' !important'} );
										};
									}
								} );
							},
							"menu.js": function (exports, module, require) {
								var base = require( '../base' ),
									shortcode_base = require( '../../libs/shortcode-manager' );

								module.exports = base.component.extend( {
									controls_init: function ( controls ) {
										var self = this;
										controls['MakePrimary'].change = function ( $element, dom ) {
											self.changeConfig( 'primary', dom.checked, true );
										};
										controls['MakePrimary'].update = function ( $element ) {
											var checked = self.model.get( 'primary' );
											this.setChecked( checked );
										};

										this.controls['MainColor'].input = function ( color ) {
											this.applyTo().find( '.thrive-shortcode-html' ).head_css( {'color': color + ' !important'}, null, ' .tve_w_menu > li > a' );
										};
										this.controls['MainColor'].change = function ( color ) {
											self.updateHeadCssAttr( '.thrive-shortcode-html', 'head_css' );
											this.input( color );
										};
										this.controls['MainColor'].update = function ( $element ) {
											this.setValue( $element.find( '.tve_w_menu > li a' ).css( 'color' ) );
										};

										this.controls['ChildColor'].input = function ( color ) {
											this.applyTo().find( '.thrive-shortcode-html' ).head_css( {'color': color + ' !important'}, null, ' .tve_w_menu .sub-menu li a' );
										};
										this.controls['ChildColor'].change = function ( color ) {
											self.updateHeadCssAttr( '.thrive-shortcode-html', 'head_css' );
											this.input( color );
										};
										this.controls['ChildColor'].update = function ( $element ) {
											this.setValue( $element.find( '.sub-menu li a' ).css( 'color' ) );
										};

										this.controls['ChildBackground'].input = function ( color ) {
											this.applyTo().find( '.thrive-shortcode-html' ).head_css( {'background-color': color + ' !important'}, null, ' .tve_w_menu .sub-menu .menu-item a' );
										};
										this.controls['ChildBackground'].change = function ( color ) {
											self.updateHeadCssAttr( '.thrive-shortcode-html', 'head_css' );
											this.input( color );
										};
										this.controls['ChildBackground'].update = function ( $element ) {
											this.setValue( $element.find( '.tve_w_menu .sub-menu .menu-item a' ).css( 'background-color' ) );
										};

										this.controls['HoverMainColor'].input = function ( color ) {
											this.applyTo().find( '.thrive-shortcode-html' ).head_css( {'color': color + ' !important'}, null, ' .tve_w_menu > li > a:hover' );
										};
										this.controls['HoverMainColor'].change = function ( color ) {
											self.updateHeadCssAttr( '.thrive-shortcode-html', 'head_css' );
											self.changeConfig( 'main_hover', color.toString() );
											this.input( color );
										};
										this.controls['HoverMainColor'].update = function ( $element ) {
											var color = self.model.get( 'main_hover' );
											if ( color ) {
												this.setValue( color );
											} else {
												this.setValue( self.config['HoverMainColor'].config.default );
											}
										};

										this.controls['HoverChildColor'].input = function ( color ) {
											this.applyTo().find( '.thrive-shortcode-html' ).head_css( {'color': color + ' !important'}, null, ' .tve_w_menu .sub-menu li a:hover' );
										};
										this.controls['HoverChildColor'].change = function ( color ) {
											self.updateHeadCssAttr( '.thrive-shortcode-html', 'head_css' );
											self.changeConfig( 'child_hover', color.toString() );
											this.input( color );
										};
										this.controls['HoverChildColor'].update = function ( $element ) {
											var color = self.model.get( 'child_hover' );
											if ( color ) {
												this.setValue( color );
											} else {
												this.setValue( self.config['HoverChildColor'].config.default );
											}
										};

										this.controls['HoverChildBackground'].input = function ( color ) {
											this.applyTo().find( '.thrive-shortcode-html' ).head_css( {'background-color': color + ' !important'}, null, ' .tve_w_menu .sub-menu .menu-item a:hover' );
										};
										this.controls['HoverChildBackground'].change = function ( color ) {
											self.updateHeadCssAttr( '.thrive-shortcode-html', 'head_css' );
											self.changeConfig( 'background_hover', color.toString() );
											this.input( color );
										};
										this.controls['HoverChildBackground'].update = function ( $element ) {
											var color = self.model.get( 'background_hover' );
											if ( color ) {
												this.setValue( color );
											} else {
												this.setValue( self.config['HoverChildBackground'].config.default );
											}
										};

										this.controls['TriggerColor'].input = function ( color ) {
											this.applyTo().find( '.thrive-shortcode-html' ).head_css( {'color': color + ' !important'}, null, ' .tve-m-trigger' );
											self.updateHeadCssAttr( '.thrive-shortcode-html', 'head_css' );
										};
										this.controls['TriggerColor'].update = function ( $element ) {
											this.setValue( $element.find( '.tve-m-trigger' ).css( 'color' ) );
										};
									},
									updateHeadCssAttr: function ( selector, configAttr ) {
										var css_id = this.$element.find( selector ).attr( 'data-css' );
										this.changeConfig( configAttr, css_id );
									},
									setConfig: function ( config ) {
										this.config = config;
										this.$element = TVE.ActiveElement;
										this.setModel();
										base.component.prototype.setConfig.apply( this, arguments );
									},

									setModel: function () {
										this.shortcode = shortcode_base( this.$element.find( ".thrive-shortcode-config" ), 'widget_menu' );
										this.model = new Backbone.Model( this.shortcode.get() );
										this.changeEditLink( this.model.get( 'menu_id' ) );
									},

									/**
									 * Get the View constructor for the select menu control
									 *
									 * @returns {*}
									 */
									selectMenu: function () {
										return require( '../controls/custom-menu/select-menu' );
									},

									menuDirection: function () {
										return require( '../controls/custom-menu/menu-direction' );
									},

									changeEditLink: function ( id ) {
										this.$( '.tve-edit-menu' ).attr( 'href', this.$( '.tve-edit-menu' ).attr( 'href' ).replace( /&menu=(\d*)/, '&menu=' + id ) );
									},

									changeConfig: function ( key, value, triggerChange ) {
										var self = this;
										this.model.set( key, value );
										this.shortcode.update( value, key );
										if ( key == 'menu_id' ) {
											this.changeEditLink( value );
										}

										if ( triggerChange ) {
											TVE.main.overlay();
											this.model.attributes.nowrap = true;
											TVE.ajax( 'custom_menu', 'post', this.model.attributes )
											   .success( function ( response ) {
												   self.$element.html( response.response );
											   } )
											   .always( function () {
												   TVE.main.overlay( 'close' );
											   } );
										}
									}
								} );
							},
							"post-grid-filter.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 5/30/2017.
								 */
								var base = require( './post-grid' );

								module.exports = base.extend( {
									before_update: jQuery.noop,
									controls_init: function ( controls ) {
										/**
										 *  Categories Controls
										 */
										this.controls['categories'].update = function ( $element ) {
											var config = this.component.get_config(),
												_value = [];

											if ( typeof config['filters']['category'] === 'string' && config['filters']['category'].length > 1 ) {
												config['filters']['category'] = config['filters']['category'].split( ',' );
											}

											_.each( config['filters']['category'], function ( item ) {
												_value.push( {id: item, text: item} );
											}, this );

											this.setValueRemote( _value );
										};

										this.controls['categories'].input = function ( $element, value ) {
											var config = this.component.get_config();
											config['filters']['category'] = _.pluck( value, 'id' );

											this.component.update_config( config['filters'], 'filters' );

											this.component.generate_post_grid( $element );
										};

										/**
										 *  Tags Controls
										 */
										this.controls['tags'].update = function ( $element ) {
											var config = this.component.get_config(),
												_value = [];

											if ( typeof config['filters']['tag'] === 'string' && config['filters']['tag'].length > 1 ) {
												config['filters']['tag'] = config['filters']['tag'].split( ',' );
											}

											_.each( config['filters']['tag'], function ( item ) {
												_value.push( {id: item, text: item} );
											}, this );

											this.setValueRemote( _value );
										};

										this.controls['tags'].input = function ( $element, value ) {
											var config = this.component.get_config();
											config['filters']['tag'] = _.pluck( value, 'id' );

											this.component.update_config( config['filters'], 'filters' );

											this.component.generate_post_grid( $element );
										};

										/**
										 *  Authors Controls
										 */
										this.controls['authors'].update = function ( $element ) {
											var config = this.component.get_config(),
												_value = [];

											if ( typeof config['filters']['author'] === 'string' && config['filters']['author'].length > 1 ) {
												config['filters']['author'] = config['filters']['author'].split( ',' );
											}

											_.each( config['filters']['author'], function ( item ) {
												_value.push( {id: item, text: item} );
											}, this );

											this.setValueRemote( _value );
										};

										this.controls['authors'].input = function ( $element, value ) {
											var config = this.component.get_config();
											config['filters']['author'] = _.pluck( value, 'id' );

											this.component.update_config( config['filters'], 'filters' );

											this.component.generate_post_grid( $element );
										};

										/**
										 *  Custom Taxonomies Controls
										 */
										this.controls['custom_taxonomies'].update = function ( $element ) {
											var config = this.component.get_config(),
												_value = [];

											if ( typeof config['filters']['tax'] === 'string' && config['filters']['tax'].length > 1 ) {
												config['filters']['tax'] = config['filters']['tax'].split( ',' );
											}

											_.each( config['filters']['tax'], function ( item ) {
												_value.push( {id: item, text: item} );
											}, this );

											this.setValueRemote( _value );
										};

										this.controls['custom_taxonomies'].input = function ( $element, value ) {
											var config = this.component.get_config();
											config['filters']['tax'] = _.pluck( value, 'id' );

											this.component.update_config( config['filters'], 'filters' );

											this.component.generate_post_grid( $element );
										};

										/**
										 *  Individual Posts / Pages Controls
										 */
										this.controls['individual_post_pages'].update = function ( $element ) {
											var config = this.component.get_config(),
												_value = [];

											if ( typeof config['filters']['posts'] === 'string' ) {
												config['filters']['posts'] = config['filters']['posts'].split( ',' );
											}

											_.each( config['filters']['posts'], function ( item ) {
												if ( typeof config['filters']['posts'] === 'string' ) {
													_value.push( {id: item, text: item} );
												} else {
													_value.push( {id: item.id, text: item.text} );
												}

											}, this );

											this.setValueRemote( _value );
										};

										this.controls['individual_post_pages'].input = function ( $element, value ) {
											var config = this.component.get_config();

											config['filters']['posts'] = _.map( value, function ( elm ) {
												return {id: elm.id, text: elm.text};
											} );

											this.component.update_config( config['filters'], 'filters' );

											this.component.generate_post_grid( $element );
										};
									}
								} );
							},
							"post-grid-layout.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 5/30/2017.
								 */
								var base = require( './post-grid' );

								module.exports = base.extend( {
									teaserLayoutCollection: new Backbone.Collection( {} ),
									before_update: jQuery.noop,
									controls_init: function ( controls ) {
										var self = this;
										/**
										 * Number of Columns controls
										 */
										this.controls['number_of_columns'].input = function ( $element, dom ) {
										};
										this.controls['number_of_columns'].update = function ( $element ) {
											var config = this.component.get_config();

											this.setValue( config['columns'] );
										};
										this.controls['number_of_columns'].change = function ( $element, dom ) {
											this.component.update_config( dom.value, 'columns' );

											this.component.generate_post_grid( $element );
										};

										/**
										 * Display controls
										 */
										this.controls['display'].update = function ( $element ) {
											var config = this.component.get_config();

											this.setValue( config['display'] );
										};

										this.controls['display'].input = function ( $element, dom ) {
											this.component.update_config( dom.value, 'display' );

											this.component.generate_post_grid( $element );
										};

										/**
										 * Grid Layout controls
										 */
										this.controls['grid_layout'].update = function ( $element ) {
											var config = this.component.get_config();

											if ( config['grid_layout'] === 'vertical' ) {
												this.component.$( ".post-grid-layout-number-of-columns" ).hide();
												this.component.$( ".post-grid-layout-display" ).hide();
											} else {
												this.component.$( ".post-grid-layout-number-of-columns" ).show();
												this.component.$( ".post-grid-layout-display" ).show();
											}


											this.setValue( config['grid_layout'] );
										};

										this.controls['grid_layout'].input = function ( $element, dom ) {
											this.component.update_config( dom.value, 'grid_layout' );


											if ( dom.value === 'vertical' ) {

												this.component.update_config( 'grid', 'display' );
												this.component.update_config( 1, 'columns' );

												this.component.$( ".post-grid-layout-number-of-columns" ).hide();
												this.component.$( ".post-grid-layout-display" ).hide();
											} else {

												this.component.update_config( 'grid', 'display' );
												this.component.update_config( 2, 'columns' );

												this.component.controls['display'].update( $element );
												this.component.controls['number_of_columns'].update( $element );

												this.component.$( ".post-grid-layout-number-of-columns" ).show();
												this.component.$( ".post-grid-layout-display" ).show();
											}

											this.component.generate_post_grid( $element );
										};

										/**
										 * Teaser Layout checkboxes
										 */
										this.controls['featured_image'].update = function ( $element ) {
											var config = this.component.get_config();

											this.setChecked( config['teaser_layout']['featured_image'] === 'true' );
										};

										this.controls['featured_image'].change = function ( $element, dom ) {
											var config = this.component.get_config();

											config['teaser_layout']['featured_image'] = (dom.checked) ? 'true' : 'false';

											this.component.update_config( config['teaser_layout'], 'teaser_layout' );

											this.component.generate_post_grid( $element );

											self.controls['preview'].update();
										};

										this.controls['title'].update = function ( $element ) {
											var config = this.component.get_config();

											this.setChecked( config['teaser_layout']['title'] === 'true' );
										};

										this.controls['title'].change = function ( $element, dom ) {
											var config = this.component.get_config();

											config['teaser_layout']['title'] = (dom.checked) ? 'true' : 'false';

											this.component.update_config( config['teaser_layout'], 'teaser_layout' );

											this.component.generate_post_grid( $element );

											self.controls['preview'].update();
										};
										this.controls['read_more_lnk'].update = function ( $element ) {
											var config = this.component.get_config();

											this.setChecked( config['teaser_layout']['read_more'] === 'true' );
										};

										this.controls['read_more_lnk'].change = function ( $element, dom ) {
											var config = this.component.get_config();

											config['teaser_layout']['read_more'] = (dom.checked) ? 'true' : 'false';

											this.component.update_config( config['teaser_layout'], 'teaser_layout' );

											this.component.generate_post_grid( $element );

											self.controls['preview'].update();
										};
										this.controls['text'].update = function ( $element ) {
											var config = this.component.get_config();

											this.setChecked( config['teaser_layout']['text'] === 'true' );
										};

										this.controls['text'].change = function ( $element, dom ) {
											var config = this.component.get_config();

											config['teaser_layout']['text'] = (dom.checked) ? 'true' : 'false';

											this.component.update_config( config['teaser_layout'], 'teaser_layout' );

											this.component.generate_post_grid( $element );

											self.controls['preview'].update();
										};

										/**
										 * Text Type controls
										 */
										this.controls['text_type'].update = function ( $element ) {
											var config = this.component.get_config();

											this.setValue( config['text_type'] );
										};

										this.controls['text_type'].input = function ( $element, dom ) {
											this.component.update_config( dom.value, 'text_type' );

											this.component.generate_post_grid( $element );
											self.controls['preview'].update();
										};

										var previewConfig = this.config.preview.config;
										this.controls['preview'].attach_collection( this.teaserLayoutCollection );
										this.controls['preview'].update = function ( $element ) {
											var listItemsArr = [],
												config = this.component.get_config();

											_.each( config['layout'], function ( item, index ) {
												listItemsArr.push( {icon: '', key: item, label: previewConfig.labels[item]} );
											}, this );

											this.component.teaserLayoutCollection.reset( listItemsArr );
										};

										/**
										 * Teaser Layout Items Collection change listener
										 */
										this.listenTo( this.teaserLayoutCollection, 'change', _.bind( function ( model ) {
											var _arr = [];
											this.teaserLayoutCollection.each( function ( model ) {
												_arr.push( model.get( 'key' ) );
											}, this );

											this.update_config( _arr, 'layout' );

											this.generate_post_grid();
										}, this ) );
									},
									order_control: function () {
										return require( '../controls/preview-list' );
									}
								} );
							},
							"post-grid-query.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 5/30/2017.
								 */
								var base = require( './post-grid' );

								module.exports = base.extend( {
									before_update: jQuery.noop,
									controls_init: function ( controls ) {

										/**
										 *  Content Controls
										 */
										this.controls['content'].update = function ( $element ) {
											var config = this.component.get_config();

											//Backwards compatibility. replace post_typs with content_types
											if ( ! config['content_types'] && config['post_types'] && Object.keys( config['post_types'] ).length > 0 ) {
												var _arr = [];
												for ( var prop in  config['post_types'] ) {
													if ( config['post_types'][prop] === 'true' ) {
														_arr.push( prop );
													}
												}
												config['content_types'] = _arr;
											}

											this.setValue( config['content_types'] );
										};

										this.controls['content'].input = function ( $element, value ) {
											this.component.update_config( _.pluck( value, 'id' ), 'content_types' );

											this.component.generate_post_grid( $element );
										};

										/**
										 * Order By controls
										 */
										this.controls['order_by'].update = function ( $element ) {
											var config = this.component.get_config();
											this.setValue( config['orderby'] );
										};

										this.controls['order_by'].input = function ( $element, dom ) {
											this.component.update_config( dom.value, 'orderby' );

											this.component.generate_post_grid( $element );
										};

										/**
										 * Order Mode controls
										 */
										this.controls['order_mode'].update = function ( $element ) {
											var config = this.component.get_config();
											this.setValue( config['order'] );
										};

										this.controls['order_mode'].input = function ( $element, dom ) {
											this.component.update_config( dom.value, 'order' );

											this.component.generate_post_grid( $element );
										};

										/**
										 * Number of posts controls
										 */
										this.controls['number_of_posts'].update = function ( $element ) {
											var config = this.component.get_config();
											this.setValue( config['posts_per_page'] );
										};

										this.controls['number_of_posts'].input = function ( $element, dom ) {
											this.component.update_config( dom.value, 'posts_per_page' );

											this.component.generate_post_grid( $element );
										};

										/**
										 * Recent Days control
										 */
										this.controls['recent_days'].input = function ( $element, dom ) {
										};
										this.controls['recent_days'].update = function ( $element ) {
											var config = this.component.get_config();

											this.setValue( config['recent_days'] );
										};
										this.controls['recent_days'].change = function ( $element, dom ) {
											this.component.update_config( dom.value, 'recent_days' );

											this.component.generate_post_grid( $element );
										};

										/**
										 * Start control
										 */
										this.controls['start'].input = function ( $element, dom ) {
										};
										this.controls['start'].update = function ( $element ) {
											var config = this.component.get_config();

											this.setValue( config['posts_start'] );
										};
										this.controls['start'].change = function ( $element, dom ) {
											this.component.update_config( dom.value, 'posts_start' );

											this.component.generate_post_grid( $element );
										};

									}
								} );
							},
							"post-grid.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 5/27/2017.
								 */
								var base = require( '../base' ),
									shortcode_base = require( '../../libs/shortcode-manager' ),
									shortcode_config = null,
									shortcode_settings = null;

								module.exports = base.component.extend( {
									before_update: function () {
										shortcode_config = null;
										shortcode_settings = null;
									},
									controls_init: function ( controls ) {
										this.controls['read_more'].update = function ( $element ) {
											var config = this.component.get_config();

											/*Backwards Compatibility*/
											if ( ! config['read-more-text'] ) {
												config['read-more-text'] = 'Read More';
											}

											this.setValue( config['read-more-text'] );
										};

										this.controls['read_more'].change = function ( value ) {
											this.component.update_config( value, 'read-more-text' );
											this.applyTo().find( '.tve_pg_more a' ).text( value );
										};

										this.controls['read_more_color'].change = function ( color ) {
											var $element = this.applyTo();
											$element.head_css( {'color': color}, false, ' .tve_pg_container .tve_pg_more a' );
										};

										this.controls['read_more_color'].input = function ( color ) {
											var $element = this.applyTo();
											$element.head_css( {'color': color}, false, ' .tve_pg_container .tve_pg_more a' );
										};

										this.controls['read_more_color'].update = function ( $element ) {
											this.setValue( this.applyTo().find( '.tve_pg_container .tve_pg_more a' ).css( 'color' ) );
										};

										this.controls['img_height'].input = function ( $element, dom ) {
											$element.find( '.tve_post_grid_image_wrapper' ).css( 'height', dom.value );
											this.component.after_generate( $element );
										};

										this.controls['img_height'].change = function ( $element, dom ) {
											$element.find( '.tve_post_grid_image_wrapper' ).css( 'height', dom.value );
											this.component.update_config( dom.value, 'image-height' );
										};

										this.controls['img_height'].update = function ( $element ) {
											this.setValue( $element.find( '.tve_post_grid_image_wrapper' ).css( 'height' ) );
										};

									},

									/**
									 * Returns the Post Grid Config Options
									 *
									 * @returns {*}
									 */
									get_config: function () {
										if ( shortcode_config === null ) {
											shortcode_config = shortcode_base( TVE.ActiveElement.find( '.thrive-shortcode-config' ), 'post_grid' );
										}

										if ( shortcode_settings === null ) {
											shortcode_settings = shortcode_config.get();
										}

										return shortcode_settings;
									},

									/**
									 * Updates the Post Grid Config Option
									 * @param value
									 * @param key
									 */
									update_config: function ( value, key ) {
										if ( shortcode_config === null ) {
											shortcode_config = shortcode_base( TVE.ActiveElement.find( '.thrive-shortcode-config' ), 'post_grid' );
										}

										shortcode_settings[key] = value;
										shortcode_config.update( value, key )
									},

									/**
									 * Open Grid Option Menu
									 */
									edit_grid_options: function () {
										TVE.Editor_Page.disable();
										TVE.ActiveElement.addClass( 'canvas-mode' );
										TVE.main.switch_menu_to( 'custom', 'postgrid' );
										TVE.inner_$( '#tcb-postgrid-panel' ).show();

										TVE.inner_$( '#tcb-postgrid-panel' ).find( '.tcb-close-postgrid-btn' ).off( 'click' ).on( 'click', jQuery.proxy( this.close_grid_options, this ) );

										this.position_buttons();
									},

									/**
									 * Close Grid Option Menu
									 */
									close_grid_options: function () {
										TVE.main.switch_menu_to( 'components' );
										TVE.ActiveElement.removeClass( 'canvas-mode' );
										TVE.inner_$( '#tcb-postgrid-panel' ).hide();
										TVE.Editor_Page.enable();
									},

									/**
									 * Position the menu bellow the Post Grid Element
									 */
									position_buttons: function () {
										var position = TVE.ActiveElement.offset(),
											body_offset = TVE.Editor_Page.$body.offset();

										TVE.inner_$( '#tcb-postgrid-panel' ).css( {
											left: ( position.left - body_offset.left ) + 'px',
											top: ( position.top - body_offset.top ) + TVE.ActiveElement.outerHeight() + 'px',
											width: TVE.ActiveElement.outerWidth()
										} );
									},

									/**
									 * Placeholder Action Function
									 */
									placeholder_action: function () {
										this.generate_post_grid();
									},

									/**
									 * Generate Post Grid Element Request
									 *
									 * @param $element
									 */
									generate_post_grid: function ( $element ) {
										var $elem = typeof $element === 'undefined' ? TVE.ActiveElement : $element,
											_config = {},
											self = this;

										if ( $elem.find( '.thrive-shortcode-config' ).length ) {
											_config = self.get_config();
										}

										/**
										 * Backwards compatibility
										 */
										delete _config['action'];
										delete _config['tve_lb_type'];

										$elem.addClass( 'tcb-el-loading' );
										TVE.ajax( 'post_grid', 'post', _config )
										   .success( function ( response ) {
											   $elem.html( response.html );
											   self.after_generate( $elem );
											   $elem.trigger( 'click' );
										   } )
										   .always( function () {
											   $elem.removeClass( 'tcb-el-loading' );
										   } );
									},

									/**
									 * After Post Grid Generation computations
									 *
									 * @param $element
									 */
									after_generate: function ( $element ) {
										/*If the Grid is dropped on the page it has the placeholder class. The class must be removed*/
										$element.removeClass( 'tcb-elem-placeholder' );

										if ( $element.find( '.tve_post_grid_masonry' ).length ) {
											$element.find( '.tve_post_grid_masonry' ).masonry();
										} else {
											$element.find( '.tve_pg_row' ).css( 'height', '' );
											$element.find( '.tve_pg_row' ).each( function () {
												var _maxHeight = 0,
													$row = jQuery( this );

												$row.find( '.tve_post' ).each( function () {
													var _this = jQuery( this ),
														_elHeight = parseInt( _this.outerHeight() );
													if ( _elHeight > _maxHeight ) {
														_maxHeight = _elHeight;
													}
													_this.css( 'height', '100%' );
												} );
												$row.css( 'height', (_maxHeight - 1) + 'px' );
											} );
										}

										this.position_buttons();
									}
								} );
							},
							"progress-bar.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.component.extend( {
									needs_update: function ( $element ) {
										return ! $element.hasClass( 'thrv-progress-bar' );
									},
									migrate_element: function ( $element ) {
										var tempCss, labelCss, width;

										tempCss = $element.css( [
											'margin'
										] );
										$element.head_css( tempCss );

										tempCss = $element.css( [
											'border-width',
											'border-style',
											'border-color',
											'border-image',
											'border-radius'
										] );
										$element.find( '.tve_progress_bar' ).head_css( tempCss );

										labelCss = $element.find( '.tve_data_element_label' ).css( [
											'background-color'
										] );

										tempCss = $element.find( '.tve_progress_bar' ).css( [
											'background-color'
										] );
										$element.find( '.tve_progress_bar' ).addClass( 'tve-progress-bar' ).removeClass( 'tve_progress_bar' ).head_css( tempCss );

										tempCss = $element.find( '.tve_progress_bar_fill' ).css( [
											'background-color'
										] );
										$element.find( '.tve_progress_bar_fill' ).head_css( tempCss );

										width = $element.find( '.tve_progress_bar_fill_wrapper' ).css( ['width'] );

										$element.find( '.tve_progress_bar_fill_wrapper' ).head_css( {width: width.width} );
										$element.find( '.tve_progress_bar_fill_wrapper' ).attr( 'style', '' );

										$element.find( '.tve-progress-bar' ).append( '<div class="tve-progress-bar-label"><div class="thrv-inline-text tve_editable">' + $element.find( '.tve_data_element_label' ).html() + '</div></div>' );
										$element.find( '.tve_data_element_label' ).remove();

										$element.find( '.thrv-inline-text' ).head_css( labelCss );

										$element.addClass( 'thrv-progress-bar' ).removeClass( 'thrv_progress_bar' );
									},
									controls_init: function ( controls ) {
										var self = this;
										this.controls['BackgroundColor'].change = function ( color ) {
											this.input( color );
										};
										this.controls['BackgroundColor'].input = function ( color ) {
											this.applyTo().head_css( {'background-color': color} );
										};
										this.controls['BackgroundColor'].update = function ( $element ) {
											this.setValue( $element.css( 'background-color' ) );
										};

										this.controls['FillColor'].change = function ( color ) {
											this.input( color );
										};
										this.controls['FillColor'].input = function ( color ) {
											this.applyTo().head_css( {'background-color': color} );
										};
										this.controls['FillColor'].update = function ( $element ) {
											this.setValue( $element.css( 'background-color' ) );
										};

										this.controls['LabelColor'].change = function ( color ) {
											this.input( color );
										};
										this.controls['LabelColor'].input = function ( color ) {
											this.applyTo().head_css( {'background-color': color} );
										};
										this.controls['LabelColor'].update = function ( $element ) {
											this.setValue( $element.css( 'background-color' ) );
										};

										this.controls['FillPercent'].input = function ( $element, dom ) {
											$element.attr( 'data-fill', dom.value );
											$element.head_css( {'width': dom.value + this.getUM()} );
										};
										this.controls['FillPercent'].update = function ( $element ) {
											var value = $element.attr( 'data-fill' );
											if ( ! value ) {
												value = 20;
												$element.attr( 'data-fill', value );
												$element.head_css( {'width': (value + '%')} );
											}
											this.setValue( value );

										};

										controls['InnerLabel'].change = function ( $element, dom ) {
											var before = TVE.renderers.base.read_element_props( $element ),
												after;
											if ( dom.checked ) {
												$element.html( '<div class="thrv-inline-text tve_editable">' + TVE.t.ProgressBarLabel + '</div>' );
												controls['LabelColor'].update( $element.find( '.thrv-inline-text' ) );
												controls['LabelColor'].$el.show();
											} else {
												$element.html( '' );
												controls['LabelColor'].$el.hide();
											}
											after = TVE.renderers.base.read_element_props( $element );
											self.undo_action( $element, before, after );
										};
										controls['InnerLabel'].update = function ( $element ) {
											var checked = $element.html().length > 0;

											this.setChecked( checked );
										};
									},
									undo_action: function ( $element, before, after ) {
										TVE.UndoManager.add( {
											undo: function () {
												$element.html( before.html );
											},
											redo: function () {
												$element.html( after.html );
											}
										} );
									}
								} );
							},
							"rating.js": function (exports, module, require) {
								var StylePicker = require( '../controls/rating/style' );
								module.exports = require( '../base' ).component.extend( {
									extra_states: true,
									/**
									 * Change and update functions
									 */
									controls_init: function () {
										this.controls.size.update = function ( $element ) {
											this.setValue( $element.find( 'svg' ).first().width() );
										};
										this.controls.size.input = function ( $element ) {
											$element.head_css( {'font-size': this.value( 'px' )} );
										};
										var opts = this.config.stylePicker;
										opts.config.items = this.renderer.get_styles();
										this.controls.style.set_drop_panel( new StylePicker( {model: opts, renderer: this.renderer} ) );

										this.controls.background.input = function ( color ) {
											this.applyTo().head_css( {'fill': color}, null, ' .sr-background' );
										};
										this.controls.background.update = function ( $element ) {
											this.setValue( $element.find( 'path.sr-background' ).css( 'fill' ) );
										};

										this.controls.fill.input = function ( color ) {
											this.applyTo().head_css( {'fill': color}, null, ' .sr-fill' );
										};
										this.controls.fill.update = function ( $element ) {
											this.setValue( $element.find( 'path.sr-fill' ).css( 'fill' ) );
										};

										this.controls.outline.input = function ( color ) {
											this.applyTo().head_css( {'fill': color}, null, ' .sr-outline' );
										};
										this.controls.outline.update = function ( $element ) {
											this.setValue( $element.find( 'path.sr-outline' ).css( 'fill' ) );
										};
									},
									/**
									 * Initializer for the rating value control
									 */
									rating_value_control: function () {
										return require( '../controls/rating/rating-value' );
									},
									/**
									 * Rating style initializer
									 */
									rating_style_control: function () {
										return require( '../controls/style-change' );
									}
								} );
							},
							"responsive-video": {
								"video-controls.js": function (exports, module, require) {
									/**
									 * Created by Ovidiu on 5/23/2017.
									 */
									var base = require( '../../base' ),
										Input = require( '../../controls/input' ),
										FilePickerCtrl = require( '../../controls/file' );

									module.exports = require( '../animation/video-popup' ).extend( {
										template: TVE.tpl( 'controls/responsive-video-settings' ),
										controls_init: function () {
											this.render();
											this.$source = this.$( '.v-source' );
											this.providers = {};
											this.$( '.v-settings' ).each( _.bind( function ( index, elem ) {
												var v = elem.getAttribute( 'data-view' );
												this.providers[v.toLowerCase()] = new TVE.VideoProviders[v]( {
													el: elem,
													key: v.toLowerCase(),
													control: this
												} );
											}, this ) );

											this.input_time_constructors();

											this.videoThumbnail = new VideoThumbnail( {
												el: this.$( '.tve-video-thumbnail-control' ),
												control: this
											} );
										},
										set_thumbnail: function ( thumb ) {
											this.videoThumbnail.set_selection( thumb );
										},

										/**
										 * Open style picker callback
										 *
										 * @param e
										 * @param dom
										 * @returns {boolean}
										 */
										open_style_picker: function ( e, dom ) {
											this.config.component_controls.style.open( null, dom );

											return false;
										},

										input_time_constructors: function () {
											var $minutes = this.$( '.tve-time-control[data-time="Minute"]' ),
												$seconds = this.$( '.tve-time-control[data-time="Second"]' ),
												self = this;

											if ( ! $minutes.length ) {
												return this;
											}

											if ( ! $seconds.length ) {
												return this;
											}

											this.minutes = new Input( {
												el: $minutes,
												model: {
													config: {
														name: 'Minutes',
														default: 0,
														min: 0,
														max: 59,
														maxlength: 2
													}
												}
											} );

											this.minutes.input = function () {
											};

											this.minutes.change = function ( $element, dom, event ) {
												self.trigger( 'start-time-changed', $element );
											};

											this.seconds = new Input( {
												el: $seconds,
												model: {
													config: {
														name: 'Seconds',
														default: 0,
														min: 0,
														max: 59,
														maxlength: 2
													}
												}
											} );

											this.seconds.input = function () {
											};

											this.seconds.change = function ( $element, dom, event ) {
												self.trigger( 'start-time-changed', $element );
											};

											return this;
										}
									} );

									var VideoThumbnail = base.component.extend( {
										control: null,
										initialize: function ( attr ) {
											this.control = attr.control;

											this.file_picker = new FilePickerCtrl( {
												labels: {
													choose: TVE.t.ChooseFile,
													title: TVE.t.Files
												},
												config: {
													type: 'image'
												}
											} );

											this.$el.prepend( this.file_picker.$el );
											this.file_picker.on( 'select', _.bind( this.on_select, this ) )
											    .on( 'remove', _.bind( this.on_remove, this ) );
										},
										set_selection: function ( file ) {
											this.file_picker.set( file );
										},
										on_select: function ( attachment ) {
											this.control.trigger( 'thumbnail-changed', attachment );
										},
										on_remove: function () {
											this.control.trigger( 'thumbnail-removed' );
										}
									} );
								}
							},
							"responsive-video.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 5/20/2017.
								 */

								var base = require( '../base' );

								module.exports = base.component.extend( {
									controls_init: function ( controls ) {
									},

									/**
									 * Get the View constructor for the Video control
									 *
									 * @returns {*}
									 */
									responsive_video: function () {
										return require( '../controls/responsive-video/video' );
									},

									/**
									 * Responsive Video Style
									 *
									 * @returns {*}
									 */
									responsive_video_style: function () {
										return require( '../controls/responsive-video/style' );
									}
								} );
							},
							"responsive.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 2/20/2017.
								 */
								var base = require( '../base' ),
									iconLabelSwitch = require( '../controls/icon-label-switch' );

								module.exports = base.component.extend( {
									template: TVE.tpl( 'controls/responsive' ),
									desktop_hide_class: 'tcb-desktop-hidden',
									tablet_hide_class: 'tcb-tablet-hidden',
									mobile_hide_class: 'tcb-mobile-hidden',
									show_hidden_elements: 'tcb_show_all_hidden',
									devices: [],
									update: function () {
										this.devices = [];
										base.component.prototype.update.apply( this, arguments );
									},
									initialize: function () {
										this.render();

										this.hide();

										this.controls = {
											Desktop: new iconLabelSwitch( {
												el: this.$el.find( '.tve-control[data-device="desktop"]' ),
												template_model: new Backbone.Model( {icon: TVE.icon( 'desktop2' ), device: TVE.t.Desktop, switch_label: true} )
											} ),

											Tablet: new iconLabelSwitch( {
												el: this.$el.find( '.tve-control[data-device="tablet"]' ),
												template_model: new Backbone.Model( {icon: TVE.icon( 'tablet' ), device: TVE.t.Tablet, switch_label: true} )
											} ),

											Mobile: new iconLabelSwitch( {
												el: this.$el.find( '.tve-control[data-device="mobile"]' ),
												template_model: new Backbone.Model( {icon: TVE.icon( 'mobile2' ), device: TVE.t.Mobile, switch_label: true} )
											} )
										};
										this.controls_init( this.controls );
									},
									controls_init: function ( controls ) {
										var self = this;

										controls.Desktop.change = function ( flag ) {
											self.change_add_element_device_status( flag, this, self.desktop_hide_class, 'Desktop' );
										};

										controls.Desktop.update = function () {
											self.update_add_element_device_status( this, self.desktop_hide_class, 'Desktop' );
										};

										controls.Tablet.change = function ( flag ) {
											self.change_add_element_device_status( flag, this, self.tablet_hide_class, 'Tablet' );
										};

										controls.Tablet.update = function () {
											self.update_add_element_device_status( this, self.tablet_hide_class, 'Tablet' );
										};

										controls.Mobile.change = function ( flag ) {
											self.change_add_element_device_status( flag, this, self.mobile_hide_class, 'Mobile' );
										};

										controls.Mobile.update = function () {
											self.update_add_element_device_status( this, self.mobile_hide_class, 'Mobile' );
										};
									},
									/**
									 * SHow all Hidden Elements handler
									 *
									 * @param event
									 * @param dom
									 */
									show_all_hidden: function ( event, dom ) {
										if ( dom.checked ) {
											TVE.Editor_Page.$body.addClass( this.show_hidden_elements );
										} else {
											TVE.Editor_Page.$body.removeClass( this.show_hidden_elements );
										}
									},
									/**
									 * Shows / Hides an element depending of the device checkbox status
									 *
									 * @param flag
									 * @param $this
									 * @param device_class
									 * @param device
									 */
									change_add_element_device_status: function ( flag, $this, device_class, device ) {
										var $element = $this.applyTo();
										if ( ! flag ) {
											$element.addClass( device_class );
											this.add_device( device );
											if ( $element.css( 'display' ) === 'none' ) {
												TVE.Editor_Page.selection_manager.hide_icons();
											}
										} else {
											$element.removeClass( device_class );
											this.remove_device( device );
											TVE.Editor_Page.selection_manager.show_icons( TVE.ActiveElement );
										}
										this.undo_manager_api( $element, device, device_class, this );
										this.disable_device_checkbox();
									},
									/**
									 * After update callback
									 * Sets the device checkbox status depending on the element status
									 *
									 * @param $this
									 * @param device_class
									 * @param device
									 */
									update_add_element_device_status: function ( $this, device_class, device ) {
										if ( $this.applyTo().hasClass( device_class ) ) {
											$this.setChecked( false );
											this.add_device( device );
										} else {
											$this.setChecked( true );
										}
										this.disable_device_checkbox();
									},
									/**
									 * Remove a device from the checked devices list
									 *
									 * @param element
									 */
									remove_device: function ( element ) {
										delete this.devices[element];
									},
									/**
									 * Adds a device to the checked device list
									 *
									 * @param element
									 */
									add_device: function ( element ) {
										this.devices[element] = true;
									},
									/**
									 * Disable device checkbox based on the device list
									 */
									disable_device_checkbox: function () {
										this.map( 'setDisabled', false );
										if ( Object.keys( this.devices ).length === 2 ) {
											_.each( this.controls, function ( ctrl, key ) {
												if ( ! this.devices[key] ) {
													ctrl.setDisabled( true );
												}
											}, this );
										}
									},
									render: function () {
										this.$el.html( this.template() );
									},
									/**
									 * Undo Manager API
									 *
									 * @param $element
									 * @param device
									 * @param device_class
									 */
									undo_manager_api: function ( $element, device, device_class ) {
										var self = this,
											$el = $element;

										TVE.UndoManager.add( {
											undo: function () {
												this.undo_redo();
											},
											redo: function () {
												this.undo_redo();
											},
											undo_redo: function () {
												if ( $el.hasClass( device_class ) ) {
													$el.removeClass( device_class );
													if ( TVE.ActiveElement ) {
														self.update();
													} else {
														self.controls[device].setChecked( true );
													}
												} else {
													$el.addClass( device_class );
													if ( TVE.ActiveElement ) {
														self.update();
													} else {
														self.controls[device].setChecked( false );
													}
												}
											}
										} );
									}
								} );
							},
							"reveal.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 4/12/2017.
								 */
								var base = require( '../base' );
								module.exports = base.component.extend( {
									controls_init: function () {
										var self = this;

										this.controls['RedirectURL'].update = function ( $element ) {
											this.setValue( $element.attr( 'data-redirect-url' ) );
										};

										this.controls['RedirectURL'].change = function ( value ) {
											value = TVE.addHttp( value );

											var $element = this.applyTo(),
												oldValue = $element.attr( 'data-redirect-url' );

											this.$el.find( 'input' ).val( value );

											if ( TVE.isValidUrl( value ) || value === '' ) {
												$element.attr( 'data-redirect-url', value );

												self.undo_manager_api( $element, 'data-redirect-url', oldValue, value );
											} else {
												TVE.page_message( TVE.t.RedirectionUrlInvalid, true, 5000 );
											}
										};

										this.controls['Time'].update = function ( $element ) {
											this.setValue( $element.attr( 'data-after' ) );
										};

										this.controls['Time'].change = function ( $element, value ) {
											var oldValue = $element.attr( 'data-after' );
											$element.attr( 'data-after', value );

											self.undo_manager_api( $element, 'data-after', oldValue, value );
										};

										this.controls['AutoScroll'].update = function ( $element ) {
											this.setChecked( Number( $element.attr( 'data-scroll' ) ) === 1 );
										};

										this.controls['AutoScroll'].change = function ( $element, dom ) {
											var oldValue = $element.attr( 'data-scroll' ),
												newValue = dom.checked ? '1' : '0';
											$element.attr( 'data-scroll', newValue );

											self.undo_manager_api( $element, 'data-scroll', oldValue, newValue );
										};
									},
									/**
									 * Undo Manager API
									 *
									 * @param $element
									 * @param attr_name
									 * @param old_attr_value
									 * @param new_attr_value
									 */
									undo_manager_api: function ( $element, attr_name, old_attr_value, new_attr_value ) {
										TVE.UndoManager.add( {
											undo: function () {
												$element.attr( attr_name, old_attr_value );
											},
											redo: function () {
												$element.attr( attr_name, new_attr_value );
											}
										} );
									}
								} );
							},
							"section.js": function (exports, module, require) {
								var base = require( '../base' ),
									FULL_WIDTH_CLASS = 'tcb-window-width';

								module.exports = base.component.extend( {
									needs_update: function ( $element ) {
										return ! $element.children( '.tve-page-section-out' ).length;
									},
									migrate_element: function ( $element ) {
										var inToOut, inToWrapper, outToOut, margin_out, margin_in;

										inToOut = $element.find( '.in' ).css( [
											'background-image',
											'background-repeat',
											'background-size',
											'background-attachment',
											'background-position',
											'box-shadow'
										] );
										inToWrapper = $element.find( '.in' ).css( [
											'padding',
											'color',
											'min-height'
										] );
										outToOut = $element.find( '.out' ).css( [
											'background-color',
											'border-width',
											'border-style',
											'border-color',
											'border-image',
											'border-radius'
										] );

										margin_out = $element.css( [
											'margin-left',
											'margin-right',
											'margin-top',
											'margin-right'
										] );
										margin_in = $element.find( '.out' ).css( [
											'margin-left',
											'margin-right'
										] );

										$element.removeClass( 'thrv_page_section' ).addClass( 'thrv-page-section tve_empty_dropzone' );
										$element.prepend( '<div class="tve-page-section-in"></div>' );
										$element.prepend( '<div class="tve-page-section-out"></div>' );

										$element.find( '.tve-page-section-out' ).head_css( outToOut );
										$element.find( '.tve-page-section-out' ).head_css( inToOut );

										$element.head_css( inToWrapper );

										if ( Number( margin_in['margin-left'].replace( 'px', '' ) < - 500 ) ) {
											margin_in['margin-left'] = '0px';
											$element.addClass( FULL_WIDTH_CLASS );
											var page_width = TVE.inner.$window.width(),
												content_width = $element.parent().width();
											$element.css( {
												width: page_width + 'px',
												left: - ((page_width - content_width) / 2) + 'px'
											} );
											$element.find( '.tve-page-section-in' ).head_css( {'max-width': content_width + 'px'} );
										}
										margin_out['margin-left'] = (Number( margin_out['margin-left'].replace( 'px', '' ) ) + Number( margin_in['margin-left'].replace( 'px', '' ) )) + 'px';
										margin_out['margin-right'] = (Number( margin_out['margin-right'].replace( 'px', '' ) ) + Number( margin_in['margin-right'].replace( 'px', '' ) )) + 'px';
										$element.css( 'margin', '' );
										$element.head_css( margin_out );

										$element.find( '.tve-page-section-in' ).html( $element.find( '.in .cck' ).html() );
										$element.find( '.out' ).remove();
									},
									controls_init: function ( controls ) {
										var self = this;
										/**
										 * Section height
										 */
										controls['SectionHeight'].input = function ( $element, dom ) {
											var before = TVE.renderers.base.read_element_props( $element ),
												after;

											$element.head_css( {'min-height': dom.value + this.getUM() + ' !important'} );
											$element.removeClass( 'tve-section-full-height' );

											after = TVE.renderers.base.read_element_props( $element );
											self.undo_action( $element, before, after );

											controls['FullHeight'].update( $element );
										};

										controls['SectionHeight'].update = function ( $element ) {
											var value = $element.head_css( 'min-height', false, '', true );
											if ( ! value ) {
												value = $element.height();
											}
											this.setValue( value );
										};

										/**
										 * Section full height checkbox
										 */
										controls['FullHeight'].change = function ( $element, dom ) {
											var before = TVE.renderers.base.read_element_props( $element ),
												after;

											if ( dom.checked ) {
												$element.addClass( 'tve-section-full-height' );
												$element.head_css( 'min-height', '' );
											} else {
												$element.removeClass( 'tve-section-full-height' );
											}

											after = TVE.renderers.base.read_element_props( $element );
											self.undo_action( $element, before, after );

											controls['SectionHeight'].update( $element );

										};
										controls['FullHeight'].update = function ( $element ) {
											var checked = $element.hasClass( 'tve-section-full-height' );

											this.setChecked( checked );
										};

										/**
										 * Content width
										 */
										controls['ContentWidth'].input = function ( $element, dom ) {
											$element.head_css( {'max-width': dom.value + this.getUM()} );
										};
										controls['ContentWidth'].update = function ( $element ) {
											var value = $element.head_css( 'max-width', null, null, true );
											if ( ! value || isNaN( parseInt( value ) ) ) {
												value = $element.outerWidth();
											}
											this.model.config.max = parseInt( $element.parent().width() );
											this.setValue( value );
										};

										/**
										 * Content full width checkbox
										 */
										controls['ContentFullWidth'].change = function ( $element, dom ) {
											$element.head_css( {
												'max-width': dom.checked ? 'none' : ( $element.parent().parent().width() + 'px' )
											} );

											if ( dom.checked ) {
												controls['ContentWidth'].$el.hide();
											} else {
												controls['ContentWidth'].update( $element );
												controls['ContentWidth'].$el.show();
											}
										};
										controls['ContentFullWidth'].update = function ( $element ) {
											var max_width = $element.css( 'max-width' ),
												checked = $element.parent().hasClass( FULL_WIDTH_CLASS ) && ( max_width === 'none' || ! max_width || isNaN( parseInt( max_width ) ) );
											this.setChecked( checked );
											controls.ContentWidth.$el[checked ? 'hide' : 'show']();
										};

										/**
										 * Section full width
										 */
										controls['SectionFullWidth'].change = function ( $element, dom ) {
											var content_width = $element.parent().width(),
												$inner = $element.find( '>.tve-page-section-in' );

											/**
											 * Tracking undo steps for this can get messy
											 */
											TVE.SKIP_CSS_STATE = true;

											$element.toggleClass( FULL_WIDTH_CLASS, dom.checked );
											controls.ContentFullWidth.$el[dom.checked ? 'show' : 'hide']();
											controls.ContentFullWidth.setChecked( false );
											controls.ContentWidth.$el.show();

											if ( dom.checked ) {
												TVE.inner.window.TCB_Front.resizePageSection( $element );
												// $inner width must be the same as parent's width
												$inner.head_css( {'max-width': content_width + 'px'} );
											} else {
												$element.css( {
													width: '',
													left: ''
												} );
											}
											TVE.SKIP_CSS_STATE = false;
											controls.ContentWidth.update( $inner );
											TVE.Editor_Page.reposition_icons();
										};
										controls['SectionFullWidth'].update = function ( $element ) {
											var checked = $element.hasClass( FULL_WIDTH_CLASS );
											controls['ContentFullWidth'].$el[checked ? 'show' : 'hide']();

											if ( this.isChecked() !== checked ) {
												this.setChecked( checked );
											}
										};
									},
									undo_action: function ( $element, before, after ) {
										TVE.UndoManager.add( {
											undo: function () {
												$element.attr( 'class', before.cls ).attr( 'style', before.style || '' );
											},
											redo: function () {
												$element.attr( 'class', after.cls ).attr( 'style', after.style || '' );
											}
										} );
									}
								} );
							},
							"sel-elem-nav.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 3/13/2017.
								 */
								var base = require( '../base' );

								module.exports = base.component.extend( {
									collection: null,
									item_tpl: TVE.tpl( 'controls/selected-elem-nav-item' ),
									/**
									 * Initialize function (view constructor)
									 *
									 * @param args
									 */
									initialize: function ( args ) {
										TVE.main.on( 'clear_focus', _.bind( this.reset_collection, this ) );

										this.collection = new Backbone.Collection();

										this.listenTo( this.collection, 'reset', this.render );
									},
									/**
									 * Empty breadcrumbs collection
									 */
									reset_collection: function () {
										this.collection.reset( [] );
									},
									/**
									 * Reset/Re-Built the breadcrumbs collection with new elements
									 *
									 */
									reset_breadcrumbs: function () {
										var $active_element = TVE.ActiveElement;

										var is_default_state = TVE.state_manager.is_default(),
											$hover_element = TVE.state_manager.get_parent();

										if ( ! $hover_element ) {
											$hover_element = TVE.state_manager.get_element();
										}

										function get_element_data( $element, type ) {
											var main_element_name = TVE.Elements[type].name;

											/* check for states other than default */
											if ( ! is_default_state && $element[0] === $hover_element[0] ) {
												main_element_name += ': <strong>' + TVE.state_manager.get_state().toUpperCase() + '</strong>';
											}

											return {element: $element, edited_element: $active_element.is( $element ), name: main_element_name};
										}

										var items = [
											get_element_data( $active_element, TVE._type( $active_element ) )
										];

										$active_element.parents( TVE.Editor_Page.selection_manager.selectors.editable ).each( function () {
											var $this = TVE.inner_$( this ),
												_type = TVE._type( $this );

											if ( $this.is( TVE.Editor_Page.selection_manager.selectors.not_editable ) ) {
												return;
											}

											if ( _type !== null ) {
												items.push( get_element_data( $this, _type ) );
											}
										} );
										items.reverse();

										this.collection.reset( items );
									},
									/**
									 * Render function
									 * Renders the template and calls render one function
									 *
									 * @returns {exports}
									 */
									render: function () {
										this.$el.empty();
										this.collection.each( this.renderOne, this );
										return this;
									},
									/**
									 * Renders each breadcrumbs item
									 *
									 * @param item
									 * @returns {exports}
									 */
									renderOne: function ( item, index, list ) {
										var is_last = false;
										if ( index === list.length - 1 ) {
											is_last = true;
										}

										this.$el.append( this.item_tpl( {model: item, index: index, is_last: is_last} ) );
										this.afterRenderOne( item, index );
										return this;
									},
									/**
									 * After render function
									 */
									afterRenderOne: function ( item, index ) {
										if ( item.get( 'edited_element' ) === false ) {
											this.$( "[data-index='" + index + "']" ).addClass( 'tcb-active-element-breadcrumbs-item-after' );
										}
									},
									/**
									 * Callback for breadcrumbs item click
									 *
									 * @param event
									 * @param dom
									 */
									clicked: function ( event, dom ) {
										var m = this.collection.at( dom.getAttribute( 'data-index' ) );
										TVE.Editor_Page.focus_element( m.get( 'element' ) );
									}
								} );
							},
							"shadow.js": function (exports, module, require) {
								var base = require( '../base' );
								var ButtonPanelGroup = require( '../controls/button-panel-group' );
								var Shadow = require( '../controls/shadow' ),
									DropPanel = require( '../controls/drop-panel' );
								module.exports = base.component.extend( {
									extra_states: true,
									/**
									 * Send configuration to controls
									 */
									setConfig: function ( config ) {
										this.config = _.extend( {}, config || {} );
										this.$element = config.to ? TVE.ActiveElement.find( config.to ) : TVE.ActiveElement;
										this.css_suffix = config.css_suffix;
										this.css_prefix = config.css_prefix;
										this.hideControls( config.disabled_controls );

										_.each( this.tabs.panels, function ( control ) {
											control.setConfig( config.Shadow );
										} );

										if ( ! this.css_attribute ) {
											this.setCssAttribute( config );
										}
										this.update();

										if ( ! this.$element || ! this.$element.length ) {
											return;
										}
									},

									hideControls: function ( controls ) {
										var self = this;
										this.$( '#tcb-shadow-buttons .btn-inline' ).show();
										if ( controls ) {
											controls.forEach( function ( control ) {
												self.$( '*[data-panel="' + control + '"]' ).hide();
											} );
										}
									},

									getDefaultValues: function(){
										return {
											angle: 180,
											color: 'rgba(0, 0, 0, 0.4)',
											distance: 8,
											blurr: 12,
											spread: 0
										};
									},

									/**
									 * Initialize collection with listeners and initialize panels
									 */
									controls_init: function () {
										this.collection = new Backbone.Collection();
										this.bindListeners();
										this.init_shadows();
									},

									/**
									 * Bind action listeners
									 */
									bindListeners: function () {
										this.collection.bind( 'change-attributes', this.change, this );
										this.collection.bind( 'cancel-changes', this.cancel, this );
										this.collection.bind( 'apply-changes', this.apply, this );
										this.collection.bind( 'remove-shadow', this.remove, this );
									},

									/**
									 * Refresh component
									 */
									update: function () {
										var $target = this.$element;
										if ( this.css_suffix ) {
											$target = this.$element.find( this.css_suffix );
										}
										this.renderShadowAttributes( this.getShadowAttributes( $target ) );
									},

									/**
									 * Update css on affected element (also handles preview)
									 */
									change: function ( skip_undo ) {
										var rules = {};
										rules[this.css_attribute] = this.buildShadowAttribute( this.collection );
										TVE.SKIP_CSS_STATE = ! ! skip_undo;
										this.$element.head_css( rules, null, this.css_suffix , true, this.css_prefix);
								//		TVE.SKIP_CSS_STATE = ! skip_undo;
									},

									/**
									 * Set undo state
									 */
									setInitialState: function () {
										var rules = {};
										rules[this.css_attribute] = this.buildShadowAttribute( this.collection );
										TVE.UndoManager.temp.set( this.$element, rules );
									},

									/**
									 * Init panels
									 */
									init_shadows: function () {
										this.tabs = new ButtonPanelGroup( {
											el: this.$( '#tcb-shadow-buttons' ),
											buttons: this.buttons(),
											label: TVE.t.AddNew
										} );
										this.tabs.on( 'open', _.bind( this.add_shadow, this ) );
									},

									/**
									 * Set the collection of shadows for each panel ( without splitting them in inner/outer )
									 */
									setControlCollection: function () {
										var self = this;
										_.each( this.tabs.panels, function ( control ) {
											control.setCollection( self.collection );
										} );
									},

									/**
									 * Render list of shadows inside drop panel
									 */
									renderShadowAttributes: function ( collection ) {
										this.$list = this.$( '#tcb-' + this.css_attribute + '-list' );
										this.$list.empty();
										var self = this;
										if ( ! collection.length ) {
											var tpl = TVE.tpl( 'shadow/no-shadow' );
											this.$list.html( tpl( {} ) );
											return;
										}
										collection.each( function ( item, i ) {
											var tpl = TVE.tpl( 'shadow/shadow-entry' );
											this.$list.append( tpl( {
												item: item
											} ) );
										}, this );
										this.$list.sortable( {
											axis: 'y',
											handle: '.preview-list-sort-handle',
											update: function ( event, ui ) {
												self.reOrder( ui.item[0].getAttribute( 'data-index' ), ui.item.index() );
											}
										} );

									},

									/**
									 * Create element shadow attribute
									 */
									buildShadowAttribute: function ( collection ) {
										var shadow = '',
											spacer = 'px ',
											spread,
											color,
											important = this.config.important ? ' !important' : '',
											default_shadow = this.default_shadow ? this.default_shadow : this.config.default_shadow;

										collection.each( function ( item, i ) {
											spread = item.get( 'spread' ) ? item.get( 'spread' ) + spacer : '';
											color = item.get( 'color' ) || 'transparent';

											shadow += item.get( 'horizontal' ) + spacer +
											          item.get( 'vertical' ) + spacer +
											          item.get( 'blur' ) + spacer +
											          spread +
											          color +
											          (item.get( 'inner' ) === 'inset' ? ' inset' : '') +
											          ((i + 1) === collection.length ? '' : ', ');
										} );

										shadow = shadow ? shadow : ( default_shadow ? default_shadow : '' );

										return shadow ? ( shadow + important ) : shadow;
									},

									/**
									 * Render Shadow list
									 */
									reRender: function () {
										this.renderShadowAttributes( this.collection );
									},

									/**
									 * Handle Cancel action
									 */
									cancel: function () {
										this.collection.reset( this.backup );
										this.change();
										this.reRender();
										return false;
									},

									/**
									 * Handle Apply action
									 */
									apply: function () {
										this.change();
										this.update();
										return false;
									},

									/**
									 * Handle Delete action
									 */
									remove: function ( e, btn ) {
										DropPanel.close_all();
										this.collection.remove( this.collection.findWhere( {index: parseInt( btn.getAttribute( 'data-index' ) )} ) );
										this.change();
										this.reRender();
										e.stopPropagation();
										return false;
									},

									/**
									 * set the type of shadow affected
									 */
									setCssAttribute: function ( config ) {
										if ( config && config.css_attribute ) {
											this.css_attribute = config.css_attribute;
										} else {
											this.css_attribute = 'box-shadow';
										}
									},

									/**
									 * Add new shadow action
									 */
									add_shadow: function ( panel, data ) {
										this.setBackup();
										this.setInitialState();
										var values = this.getDefaultValues();
										panel.updateControls( null, data, values );
									},

									setBackup: function () {
										this.backup = this.collection.toJSON();
									},

									/**
									 * Edit existing shadow action
									 */
									edit_shadow: function ( e, dom ) {
										this.setInitialState();
										var index = dom.getAttribute( 'data-index' ),
											model = this.collection.findWhere( {index: Number( index )} ),
											type = model.get( 'inner' ) ? 'inner' : 'drop';
										this.setBackup();
										this.tabs.panels[type].updateControls( model, null );
										var control = this.tabs.panels[type];

										if ( control.isOpen() ) {
											control.onCancel();
											return false;
										}

										control.open( null, dom );
										e.stopPropagation();
										return false;
									},

									/**
									 * Parses the CSS string for shadow and returns the collection
									 *
									 * @param css
									 */
									parseCss: function ( css ) {
										this.collection.reset();
										if ( css ) {
											var reShadow = /((rgba?)\(([^\)]+)\)([^,]*))+/g,
												color = '',
												index = 0,
												args = [],
												style;

											while ( style = reShadow.exec( css ) ) {
												color = style[2] + '(' + style[3] + ')';
												args = style[4].replace( /^\s+|\s+$/g, '' ).split( ' ' );
												this.collection.add( this.createShadowModel( color, args, index ) );
												index ++;
											}
										}
										this.setControlCollection();
										return this.collection;
									},

									/**
									 * Read element shadow attribute and manage it
									 */
									getShadowAttributes: function ( $btn ) {
										return this.parseCss( $btn ? $btn.css( this.css_attribute ) : '' );
									},

									/**
									 * Create model out of read element attributes
									 */
									createShadowModel: function ( color, args, index ) {
										var model = new Backbone.Model();
										model.set( 'horizontal', args[0].replace( 'px', '' ) );
										model.set( 'vertical', args[1].replace( 'px', '' ) );
										model.set( 'blur', args[2] ? args[2].replace( 'px', '' ) : null );
										model.set( 'spread', args[3] ? args[3].replace( 'px', '' ) : null );
										model.set( 'color', color );
										model.set( 'inner', args[4] ? args[4] : null );
										model.set( 'index', index );

										return model;
									},

									/**
									 * Handle Order action
									 */
									reOrder: function ( old_index, new_index ) {
										var old_model = this.collection.at( old_index );
										var model = new Backbone.Model( old_model.toJSON() );
										this.collection.remove( old_model );
										this.collection.add( model, {at: new_index} );
										this.change();
									},

									/**
									 * Buttons configuration for the button group
									 *
									 * @returns {*}
									 */
									buttons: function () {
										return {
											inner: {
												icon: 'tve-inner-shadow-icon',
												title: TVE.t.Inner,
												panel: new Shadow( {
													collection: []
												} )
											},
											drop: {
												icon: 'tve-outer-shadow-icon',
												title: TVE.t.Drop,
												panel: new Shadow( {
													collection: []
												} )
											}
										};
									}

								} );
							},
							"social.js": function (exports, module, require) {
								var StylePicker = require( '../controls/social/style' ),
									BaseCollection = require( '../../collections/base' ),
									Settings = require( '../controls/social/network-options' ),
									collection = new BaseCollection();

								module.exports = require( '../base' ).component.extend( {
									/**
									 * Change and update functions
									 */
									controls_init: function () {
										var self = this;
										var collection = this.get_collection();
										this.controls.style.set_drop_panel( new StylePicker( {model: this.config.stylePicker, renderer: this.renderer} ) );

										this.controls.type.update = function ( $element ) {
											var m = $element.find( '.tve_social_items' ).attr( 'class' ).replace( /(tve_social_items|tve_social_custom)/g, '' ).match( /(\s+)?tve_social_([a-z]{2,3})/ ),
												value = m ? ('tve_social_' + m[2]) : 'tve_social_itb';
											this.setActive( value );
											this.component.renderer.set_config( {button_type: value} );
										};
										this.controls.type.input = _.bind( function ( $element, dom ) {
											this.renderer.set_config( {button_type: dom.getAttribute( 'data-value' )} );
											this.renderer.render_to( $element, true );
											TVE.Components.shadow.update();
										}, this );

										this.controls.size.update = function ( $element ) {
											this.setValue( parseInt( $element.find( '.tve_social_items' ).css( 'font-size' ) ) );
										};
										this.controls.size.input = function ( $element, dom ) {
											$element.head_css( {'font-size': dom.value + 'px !important'}, null, ' .tve_social_items' );
										};

										this.controls.orientation.update = function ( $element ) {
											this.setActive( $element.find( '.tve_s_item' ).css( 'display' ) === 'table' ? 'v' : 'h' );
										};
										this.controls.orientation.input = function ( $element, dom ) {
											var css = {'margin-bottom': '', 'display': ''};
											if ( dom.getAttribute( 'data-value' ) === 'v' ) {
												css['margin-bottom'] = '10px';
												css['display'] = 'table';
											}
											$element.head_css( css, null, ' .tve_social_items .tve_s_item' );
											TVE.Editor_Page.reposition_icons( $element );
										};


										this.controls.preview.attach_collection( collection );
										this.controls.selector.attach_collection( collection );
										this.controls.preview.get_items = _.bind( this.controls.selector.read_element, this.controls.selector );
										this.controls.preview.on( 'item_click', _.bind( this.open_edit_panel, this ) );

										_.each( this.controls.selector.networks, function ( label, key ) {
											if ( ! Settings[key] ) {
												return true;
											}
											this.controls[key] = new Settings[key]( {network: key, component: this} );
											this.listenTo( this.controls[key], 'apply', function ( $element, data ) {
												var cfg = {};
												cfg[key] = data;
												this.renderer.set_config( cfg );
												this.renderer.render_to( $element, true );
											} );
										}, this );

										this.listenTo( collection, 'change', this.render );
										this.listenTo( collection, 'remove', this.render );
										this.listenTo( collection, 'add', this.render );

										this.controls.has_custom_url.update = function ( $element ) {
											var is_default_url = $element.find( '.tve_s_item' ).attr( 'data-href' ) === '{tcb_post_url}';
											this.setChecked( ! is_default_url );
											self.controls.custom_url.$el[is_default_url ? 'hide' : 'show']();
										};
										this.controls.has_custom_url.change = function ( $element, dom ) {
											self.controls.custom_url.$el[dom.checked ? 'show' : 'hide']().find( 'input' ).focus();
											if ( ! dom.checked ) {
												self.renderer.set_config( {share_url: '{tcb_post_url}'} ).render_to( $element, true );
												TVE.inner.window.TCB_Front.getShareCounts( $element, {
													post_id: TVE.CONST.post.ID
												} );
											}
										};
										this.controls.custom_url.hide().update = function ( $element ) {
											var url = $element.find( '.tve_s_item' ).attr( 'data-href' );
											url = ! url || url === '{tcb_post_url}' ? '' : TVE.addHttp( url );
											this.setValue( url );
											self.renderer.set_config( {share_url: url || '{tcb_post_url}'} )
										};
										this.controls.custom_url.change = function ( value ) {
											value = TVE.addHttp( value );
											if ( ! TVE.isValidUrl( value ) ) {
												TVE.page_message( TVE.t.missing_invalid_url, true );
												return false;
											}
											self.renderer.set_config( {share_url: value} ).render_to( this.applyTo(), true );
											TVE.inner.window.TCB_Front.getShareCounts( this.applyTo(), {
												post_id: TVE.CONST.post.ID
											} );
										};
										this.controls.counts.update = function ( $element ) {
											this.setValue( $element.attr( 'data-min_shares' ) || 0 );
										};
										this.controls.counts.input = function () {

										};
										this.controls.counts.change = function ( $element ) {
											self.renderer.set_config( {min_shares: parseInt( this.getValue() )} ).render_to( $element, true );
										};
										this.controls.total_share.update = function ( $element ) {
											var has_count = ! ! $element.find( '.tve_s_share_count' ).length;
											this.setChecked( has_count );
											self.renderer.set_config( {show_count: has_count} );
											TVE.inner.window.TCB_Front.getShareCounts( $element, {
												post_id: TVE.CONST.post.ID
											} );
										};
										this.controls.total_share.change = function ( $element, dom ) {
											self.renderer.set_config( {show_count: dom.checked} ).render_to( $element, true );
											TVE.inner.window.TCB_Front.getShareCounts( $element, {
												post_id: TVE.CONST.post.ID
											} );
										};
									},
									get_collection: function () {
										return collection;
									},
									/**
									 * Change style initializer
									 */
									style_control: function () {
										return require( '../controls/style-change' );
									},
									/**
									 * Network selector control initializer
									 */
									selector_control: function () {
										return require( '../controls/social/selector' );
									},
									/**
									 * Update the edited element
									 */
									render: function () {
										var $element = TVE.ActiveElement;
										this.renderer.set_config( {selected: this.get_collection().pluck( 'key' )}, false );

										this.renderer.render_to( $element, true );
									},
									open_selector_panel: function ( e, dom ) {
										this.controls.selector.read_element();
										this.controls.selector.open( null, dom );

										return false;
									},
									/**
									 * Open the settings panel for a network
									 *
									 * @param model
									 * @param dom
									 */
									open_edit_panel: function ( model, dom ) {
										this.controls[model.get( 'key' )].set_model( model ).open( TVE.ActiveElement, dom );

										return false;
									}
								} );
							},
							"styled-list.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 5/9/2017.
								 */
								var base = require( '../base' );

								module.exports = base.component.extend( {
									listItemsCollection: new Backbone.Collection( {} ),
									/**
									 * Change and update functions
									 */
									controls_init: function () {
										var self = this;

										TVE.main.on( 'ctrl-enter-pressed', function ( event ) {
											if ( TVE.ActiveElement.hasClass( 'tcb-styled-list-icon-text' ) ) {
												TVE.froala.editor.cursor.enter();
											}
										} );

										TVE.main.on( 'enter-pressed', function ( event ) {
											if ( TVE.ActiveElement.hasClass( 'tcb-styled-list-icon-text' ) ) {
												self.add_list_item_after( TVE.ActiveElement );
											}
										} );


										this.controls['item_spacing'].update = function () {
											var css = this.applyTo().head_css( 'margin-bottom', null, this.config.css_suffix, true );
											if ( ! css ) {
												css = 0;
											}

											this.setValue( css );
										};

										this.controls['item_spacing'].input = function ( $element, dom ) {
											$element.head_css( {'margin-bottom': dom.value + this.getUM()}, false, this.config.css_suffix );
										};

										this.controls['icons_color'].input = function ( color ) {
											var $element = this.applyTo();
											$element.find( '.thrv_icon' ).head_css( {'color': color} );
										};

										this.controls['icons_color'].change = function ( color ) {
											var $element = this.applyTo();
											$element.find( '.thrv_icon' ).head_css( {'color': color} );
											$element.attr( 'data-color', color.toRgbString() );
										};

										this.controls['icons_color'].update = function ( $element ) {
											var color = $element.attr( 'data-color' );
											if ( ! color ) {
												color = 'rgb(0,0,0)';
											}
											this.setValue( color );
										};

										/**
										 * Icon Logic
										 */
										this.controls.ModalPicker.setModal( TVE.IconsModal.get_instance( TVE.modal.get_element( 'icons' ) ) );

										this.controls['ModalPicker'].input = function ( $element, data ) {

											var html;
											if ( data.icon.is( '.tve-svg-icon' ) ) {
												var $symbol = jQuery( 'symbol#' + data.icon.data( 'cls' ) );
												html = TVE.svg_icon( {
													path: $symbol.html(),
													viewBox: $symbol[0].getAttribute( 'viewBox' ),
													name: $symbol.find( '> title' ).text()
												} );
											} else {
												html = '<span data-name="' + data.icon.data( 'cls' ).replace( 'icon-', '' ) + '" class="tve_sc_icon ' + data.icon.data( 'cls' ) + '"></span>';
											}

											$element.attr( 'data-icon-code', data.icon.data( 'cls' ) ).find( '.thrv_icon' ).html( html );

											/**
											 * calls the ModalPicker update function to update the icon name inside the text box
											 */
											this.update( $element );
										};

										this.controls['ModalPicker'].update = function ( $element ) {
											var _name = $element.attr( 'data-icon-code' );
											this.updateValue( _name.replace( 'icon-', '' ) );
										};

										this.controls.preview.attach_collection( this.listItemsCollection );
										this.controls.preview.update = function ( $element ) {
											var listItemsArr = [],
												listItems = $element.find( 'li' );

											_.each( listItems, function ( item, index ) {
												var $item = jQuery( item );

												listItemsArr.push( {icon: this.component.renderer.get_icon( $item ), key: $item, label: this.component.renderer.get_text( $item )} );

											}, this );

											this.component.listItemsCollection.reset( listItemsArr );
										};

										/**
										 * List Items Collection remove listener
										 */
										this.listenTo( this.listItemsCollection, 'remove', _.bind( function ( model ) {
											var itemToRemove = model.get( 'key' );

											if ( itemToRemove instanceof jQuery ) {
												itemToRemove.remove();
											}

										}, this ) );

										/**
										 * List Items Collection change listener
										 */
										this.listenTo( this.listItemsCollection, 'change', _.bind( function ( model ) {
											var $element = this.controls.preview.applyTo(),
												$ul = $element.find( 'ul' );

											$ul.empty();
											this.listItemsCollection.each( function ( model ) {
												$ul.append( model.get( 'key' ) );
											}, this );

										}, this ) );
									},

									/**
									 * Callback for Add List Item By Clicking Enter on an List Item
									 */
									add_list_item_after: function ( $element ) {
										var color = $element.closest( '.thrv-styled_list' ).attr( 'data-color' ),
											icon = $element.closest( '.thrv-styled_list' ).attr( 'data-icon-code' ),
											$selectedListItem = $element.closest( '.thrv-styled-list-item' );

										$selectedListItem.after( this.renderer.create_default_list_item( icon ) );

										if ( color !== 'undefined' ) {
											$selectedListItem.next().find( '.thrv_icon' ).head_css( {'color': color} );
										}

										var $_nextLiElem = $selectedListItem.next().find( '.tcb-styled-list-icon-text' );
										$_nextLiElem.mouseenter();
										$_nextLiElem.trigger( 'click.tcb' );
										$_nextLiElem.froalaEditor( 'events.focus' );

										TVE.froala.editor.selection.setAtEnd( TVE.froala.editor.$el.get( 0 ) );
										TVE.froala.editor.selection.restore();
									},

									/**
									 * Adds a new list item
									 */
									add_list_item: function () {
										var $element = this.controls.preview.applyTo(),
											color = $element.attr( 'data-color' );

										$element.find( 'ul' ).append( this.renderer.create_default_list_item( $element.attr( 'data-icon-code' ) ) );

										var $lastListItem = $element.find( 'li' ).last();

										if ( color !== 'undefined' ) {
											$lastListItem.find( '.thrv_icon' ).head_css( {'color': color} );
										}

										this.controls.preview.update( $element );
									},
									list_preview_control: function () {
										return require( '../controls/preview-list' );
									}
								} );
							},
							"styles-templates.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 2/27/2017.
								 */
								var base = require( '../base' ),
									labelInput = require( '../controls/label-input' ),
									content_manager = require( '../../../editor/src/util/content' );

								module.exports = base.component.extend( {
									template: TVE.tpl( 'controls/styles-templates' ),
									stepClass: '.tcb-style-template-step',
									currentStep: 0,
									initialize: function () {
										this.render();

										this.hide();

										this.controls = {
											Class: new labelInput( {
												el: this.$el.find( '.tve-control[data-input="class"]' ),
												model: new Backbone.Model( {label: TVE.t.Class, label_col_x: 2, extra_attrs: ''} )
											} ),
											ID: new labelInput( {
												el: this.$el.find( '.tve-control[data-input="id"]' ),
												model: new Backbone.Model( {label: TVE.t.ID, label_col_x: 2, extra_attrs: 'style="width: 50%"'} )
											} )
										};
										this.controls_init( this.controls );
									},
									render: function () {
										this.$el.html( this.template() );
										this.afterRender();

										return this;
									},
									afterRender: function () {
										this.steps = this.$( this.stepClass ).hide();
										this.gotoStep( 0 );

										this.$m = this.$( '.inline-message' );
										this.$autocomplete = this.$( '#tcb-template-categ-suggest' );
										this.$save_button = this.$( '.tve-button[data-fn="save_template"]' );
										this.bind();

										return this;
									},
									gotoStep: function ( index ) {
										this.steps.hide().eq( index ).show();
										this.currentStep = index;
									},
									next: function () {
										this.gotoStep( this.currentStep + 1 );
										TVE.main.scroll_panel_to( this.$el );
										this.$( '#tcb-template-name' ).focus();
									},
									prev: function () {
										this.gotoStep( this.currentStep - 1 );
									},
									controls_init: function ( controls ) {
										/**
										 * Class Control
										 */
										controls.Class.update = function ( $element ) {
											var clsStr = content_manager.parse_element_classes( $element.attr( 'class' ) );
											this.setValue( clsStr );
										};
										controls.Class.change = function ( $element, dom ) {
											var addClass = dom.value;

											this.applyTo().removeClass( function ( i, clsList ) {
												return content_manager.parse_element_classes( clsList );
											} );
											this.applyTo().addClass( addClass );
										};

										/**
										 * ID Control
										 */
										controls.ID.change = function ( $element, dom ) {
											this.applyTo().attr( 'id', dom.value );
										};
										controls.ID.update = function ( $element ) {
											var ID = $element.attr( 'id' );
											if ( ! ID || ! ID.length || ID.indexOf( 'mce_' ) !== - 1 ) {
												ID = '';
											}
											this.setValue( ID );
										};
									},
									bind: function () {
										var self = this,
											options = {
												tags: true,
												multiple: true,
												placeholder: 'Select a category...', // Place holder text to place in the select
												minimumResultsForSearch: 0,
												maximumSelectionLength: 1,
												data: tcb_main_const.tpl_categ,
												createTag: function ( tag ) {
													return {
														id: tag.term,
														text: '"' + tag.term + '" <b style="color:#1ca6e5; float: right;; text-transform: uppercase">Add as category</b>',
														value: tag.term,
														// add indicator:
														isNew: true
													};
												},
												escapeMarkup: function ( markup ) {
													/**
													 * Allow markup in text messages: ex no results
													 */
													return markup;
												}
											};

										this.$autocomplete.select2( options ).on( 'select2:selecting', function ( e ) {
											if ( e.params.args.data.isNew ) {
												e.params.args.data.text = e.params.args.data.value;
											}
										} ).on( 'select2:select', function ( e ) {
											var $this = jQuery( this );

											if ( e.params.data.isNew ) {



												TVE.ajax( 'save_user_template_category', 'post', {category_name: e.params.data.value} )
												   .done( function ( data ) {
													   tcb_main_const.tpl_categ.push( {id: data.response.id, text: data.response.name, value: data.response.name} );
													   self.$( '#tcb-template-category-id' ).val( data.response.id );

													   $this.find( '[value="' + e.params.data.id + '"]' ).replaceWith( '<option selected value="' + data.response.id + '">' + e.params.data.value + '</option>' );
													   $this.val( data.response.id ).trigger( 'change' );


													   TVE.page_message( data.text );
												   } )
												   .always( function ( data ) {
													   self.$save_button.removeClass( 'tve-disabled' );} );

											} else {
												self.$( '#tcb-template-category-id' ).val( self.$autocomplete.val() );
											}
										} ).on( 'select2:unselect', function ( evt ) {
											self.$( '#tcb-template-category-id' ).val( '' );

											if ( ! evt.params.originalEvent ) {
											return;
											}
											evt.params.originalEvent.stopPropagation();
										} );
									},

									show_hide_tpl_category: function ( event, dom ) {
										if ( dom.checked ) {
											this.$( '#tcb-select-category-row' ).removeClass( 'tcb-hidden' );
										} else {
											this.$( '#tcb-select-category-row' ).addClass( 'tcb-hidden' );
										}
									},
									/**
									 * Clear the styles inputs
									 *
									 * @param event
									 * @param dom
									 */
									clear_styles: function ( event, dom ) {
										_.each( this.controls, function ( control ) {
											control.setValue( '' );
											control.change( '' );
										} );

										var _type = TVE._type( TVE.ActiveElement ),
											element_obj = TVE.Elements[_type],
											childElementsArr = TVE.get_all_props( element_obj.components, 'to' );

										// Remove Element Custom CSS:
										TVE.ActiveElement.removeAttr( 'data-css' );
										// Remove Element Childern Custom CSS:
										TVE.ActiveElement.find( childElementsArr.join( ',' ) ).removeAttr( 'data-css' );

									},
									/**
									 * Validator for the template name
									 *
									 * @returns {boolean}
									 */
									validate: function () {
										if ( _.isEmpty( this.$( '#tcb-template-name' ).val() ) ) {
											this.$m.html( TVE.icon( 'close' ) + '&nbsp;' + TVE.t.tpl_name_required ).addClass( 'm-error' );
											return false;
										}
										this.$m.empty();
										return true;
									},
									/**
									 * Stores the template in the database
									 *
									 * @param event
									 * @param dom
									 */
									save_template: function ( event, dom ) {

										if ( ! this.validate() ) {
											return;
										}

										this.$save_button.addClass( 'tve-disabled' );

										var $clone = TVE.ActiveElement.clone(),
											_template_name = this.$( '#tcb-template-name' ).val(),
											_template_content = content_manager.prepare_content_template( $clone ),
											_template_category = this.$( '#tcb-template-category-id' ).val(),
											_custom_css_prop = TVE.ActiveElement.color_selector() ? [TVE.ActiveElement.color_selector()] : [],
											form = new FormData();

										TVE.ActiveElement.find( '[data-tve-custom-colour]' ).each( function () {
											_custom_css_prop.push( TVE.inner_$( this ).color_selector() );
										} );

										form.append( 'template_name', _template_name );
										form.append( 'template_content', _template_content );
										form.append( 'template_category', _template_category );
										form.append( 'post_id', TVE.CONST.post_id );
										form.append( 'custom_css', _custom_css_prop );
										form.append( 'media_rules', JSON.stringify( TVE.ActiveElement.collect_head_css() ) );

										TVE.generateElementPreview( TVE.ActiveElement, this, this.execute_ajax, form );
									},
									/**
									 *
									 * @param e
									 * @param dom
									 */
									handle_keyup_save: function ( e, dom ) {
										switch ( e.which ) {
											case 13:
												if ( dom.value ) {
													this.save_template();
												}
												break;
											case 27:
												this.prev();
												break;
										}
									},
									/**
									 * Executes save template ajax request
									 *
									 * @param $this
									 * @param form
									 */
									execute_ajax: function ( $this, form ) {
										form.append( 'custom', 'save_user_template' );
										form.append( 'action',TVE.CONST.ajax.action );
											form.append( 'nonce', TVE.CONST.nonce ) ;

												jQuery.ajax( {
											type: 'POST',
											url: TVE.CONST.ajax_url,
											data: form,
											processData: false,
											contentType: false,
											success: function ( data ) {$this.$( '#tcb-template-name' ).val( '' );
												$this.$autocomplete.val( '' ).trigger( 'change' );
												$this.$( '#tcb-template-category-id' ).val( '' );

												TVE.page_message( data.text );
												$this.gotoStep( 0 );
											TVE.CONST.content_templates = data.content_templates;
											},
											complete: function (  ) {
												$this.$save_button.removeClass( 'tve-disabled' );
											} ,
											error: function ( error ) {
												TVE.page_message( error.responseJSON.message, 1 );
											}
										} );
									}
								} );
							},
							"table-borders.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.component.extend( {
									controls_init: function () {
										this.controls.InnerBorders.update = function ( $element ) {
											this.setChecked( ! $element.hasClass( 'tve_no_inner_border' ) );
											this.component.inner_border_update();
										};
										this.controls.InnerBorders.input = function ( $element, dom ) {
											$element.toggleClass( 'tve_no_inner_border', ! dom.checked );
											this.component.inner_border_update();
										};

										this.controls.border_th.remove_sides().$( '.border-boxes' ).append( this.$( '#h-border' ) );
										this.controls.border_td.remove_sides().$( '.border-boxes' ).append( this.$( '#c-border' ) );
									},
									table_borders: function () {
										return require( '../controls/table-borders' );
									},
									inner_border_update: function () {
										this.$( '.inner-border' )[this.controls.InnerBorders.isChecked() ? 'show' : 'hide']();
										this.controls.border_th.update();
										this.controls.border_td.update();
									}
								} );
							},
							"table.js": function (exports, module, require) {
								var base = require( '../base' ),
									TableSize = require( '../inline/table-size' ),
									_cells = '> .tve_table > thead > tr > th, > .tve_table > tbody > tr > td ';

								module.exports = base.component.extend( {
									controls_init: function () {
										this.placeholder_panel = new TableSize( {
											component: this,
											minWidth: 196,
											no_buttons: true
										} );
										this.controls.cellpadding.update = function ( $element ) {
											this.setValue( $element.css( 'padding' ) );
										};
										this.controls.cellpadding.input = function ( $element ) {
											$element.find( _cells ).css( 'padding', '' );
											$element.head_css( {padding: this.value() + this.getUM()}, null, this.config.css_suffix );
										};

										this.controls.sortable.update = function ( $element ) {
											this.setChecked( $element.hasClass( 'tve_make_sortable' ) );
										};
										this.controls.sortable.change = function ( $element, dom ) {
											$element.toggleClass( 'tve_make_sortable', dom.checked );
										};

										this.controls.cell_bg.update = this.controls.header_bg.update = function ( $element ) {
											this.setValue( $element.css( 'background-color' ) );
										};
										this.controls.header_bg.input = function ( color ) {
											this.applyTo().head_css( {'background-color': color}, null, this.config.css_suffix, false, '#tve_editor ' );
										};

										this.controls.valign.update = function ( $element ) {
											var align;

											if ( align = $element.closest( '.tve_table' ).attr( 'data-v' ) ) {
												return this.setActive( align );
											}

											this.setActive( '' );
										};
										this.controls.valign.change = function ( $element, dom ) {
											var value = this.getValue();
											$element.children( '.tve_table' ).attr( 'data-v', value );
											$element.head_css( {'vertical-align': value}, null, this.config.css_suffix );
											$element.find( _cells ).removeClass( 'tve_valign_top tve_valign_middle tve_valign_bottom' ).head_css( {'vertical-align': ''}, null, '', false, '#tve_editor ' );
										};

										var should_clear_ = true;
										this.controls.cell_bg.input = function ( color ) {
											/* clear the alternating colors */
											if ( should_clear_ ) {
												this.component.clear_alternating_colors();
												should_clear_ = false;
											}
											this.applyTo().head_css( {'background-color': color}, null, this.config.css_suffix, false, '#tve_editor ' );
										};

										this.controls.cell_bg.change = function ( color ) {
											this.input( color );
											should_clear_ = true;
										};

										this.controls.cell_bg.cancel = function () {
											should_clear_ = true;
											if ( colors.even_rows ) {
												this.component.controls.even_rows.input( colors.even_rows );
											}
											if ( colors.odd_rows ) {
												this.component.controls.odd_rows.input( colors.odd_rows );
											}
										};

										this.controls.cell_bg.update = function ( $element ) {
											this.setValue( $element.css( 'background-color' ) );
										};

										var colors = {};
										this.controls.odd_rows.update = this.controls.even_rows.update = function ( $element ) {
											var value = colors[this.key()] = $element.css( 'background-color' );
											this.setValue( value );
										};
										this.controls.even_rows.input = this.controls.odd_rows.input = function ( color ) {
											if ( color ) {
												colors[this.key()] = color;
											}
											this.applyTo().head_css( {'background-color': color}, null, this.config.css_suffix, false, '#tve_editor ' );
										};
									},
									update_colors: function () {
										this.controls.even_rows.update( this.controls.even_rows.readFrom() );
										this.controls.odd_rows.update( this.controls.odd_rows.readFrom() );
										this.controls.cell_bg.update( this.controls.cell_bg.readFrom() );
									},
									/**
									 * Triggered when clicking "Insert table" button
									 * Opens up an inline drop panel
									 */
									placeholder_action: function () {
										this.placeholder_panel.open( TVE.ActiveElement, TVE.ActiveElement.find( '.tcb-inline-placeholder-action' ) )
									},
									manage_cells: function () {
										TVE.plugins.table.cell_manager( TVE.ActiveElement );
									},
									clear_alternating_colors: function ( e ) {
										this.controls.odd_rows.applyTo().head_css( {'background-color': ''}, null, this.controls.odd_rows.config.css_suffix, false, '#tve_editor ' );
										this.controls.even_rows.applyTo().head_css( {'background-color': ''}, null, this.controls.even_rows.config.css_suffix, false, '#tve_editor ' );
										if ( e ) {
											this.update_colors();
										}
									},
									reset_widths: function () {
										TVE.ActiveElement.find( _cells ).css( 'width', '' ).head_css( {width: ''}, null, '', false, '#tve_editor ' );
									},
									reset_heights: function () {
										TVE.ActiveElement.find( _cells ).css( 'height', '' ).head_css( {height: ''}, null, '', false, '#tve_editor ' );
									},
									disable_sort: function () {
										TVE.ActiveElement.children( '.tve_table' ).removeClass( 'tve_make_sortable' );
										this.controls.sortable.setChecked( false ).disable().$( 'label' ).attr( 'title', TVE.t.table_sorting_disabled );
									},
									after_update: function () {
										/**
										 * Checks if the table has merged cells => disable the "Make table sortable" control
										 */
										var has_merged = false;
										TVE.ActiveElement.find( _cells ).each( function () {
											if ( parseInt( this.getAttribute( 'colspan' ) || 1 ) > 1 || parseInt( this.getAttribute( 'rowspan' ) || 1 ) > 1 ) {
												has_merged = true;
												return false;
											}
										} );
										if ( has_merged ) {
											this.disable_sort();
										} else {
											this.controls.sortable.enable().$( 'label' ).removeAttr( 'title' );
										}
									}
								} );
							},
							"tabs.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.component.extend( {
									edit: 'active',
									needs_update: function ( $element ) {
										return ! $element.hasClass( 'thrv-tabbed-content' );
									},
									migrate_element: function ( $element ) {
										var style = $element.find( '.tve_scT > ul li.tve_tS' ).css( [
											'background-color'
										] );
										style['background-color'] += ' !important';
										$element.head_css( style, null, ' .tve_scT > ul li.tve_tS' );
										$element.head_css( style, null, ' .tve_scT > ul li:hover' );

										$element.head_css( $element.find( '.tve_scT > ul li:not(.tve_tS)' ).css( [
											'background-color'
										] ), null, ' .tve_scT > ul li:not(.tve_tS)' );

										$element.head_css( $element.find( '.tve_scT .tve_scTC' ).css( [
											'background-color',
											'border-color'
										] ), null, ' .tve_scT .tve_scTC ' );

										$element.find( '.tve_scT .tve_scTC' ).removeAttr( 'data-tve-custom-colour' );
										$element.find( '.tve_scT > ul li' ).removeAttr( 'data-tve-custom-colour' );
										$element.find( '.tve_scT > ul li span' ).addClass( 'thrv-inline-text tve_editable' );
										$element.removeClass( 'thrv_tabs_shortcode' ).addClass( 'thrv-tabbed-content' );
									},
									controls_init: function ( controls ) {
										var self = this;
										controls['TabLayout'].change = function ( $element, dom ) {
											var before = TVE.renderers.base.read_element_props( $element ),
												after;

											if ( dom.value == 'vertical' ) {
												$element.find( '.tve_scT' ).addClass( 'tve_vtabs' );
											} else {
												$element.find( '.tve_scT' ).removeClass( 'tve_vtabs' );
											}

											$element.find( '.tve_scT' ).css( {'padding-left': ''} );
											$element.head_css( {'width': ''}, null, ' .tve_scT > ul' );
											$element.head_css( {'width': ''}, null, ' .tve_scT > ul li' );
											self.resize( $element );
											controls['TabsWidth'].update( $element );

											after = TVE.renderers.base.read_element_props( $element );
											self.undo_action( $element, before, after );
										};
										controls['TabLayout'].update = function ( $element ) {
											if ( $element.find( '.tve_scT' ).hasClass( 'tve_vtabs' ) ) {
												this.setValue( 'vertical' );
											} else {
												this.setValue( 'horizontal' );
											}
										};


										controls['TabsWidth'].input = function ( $element, dom ) {
											var suffix;
											if ( $element.find( '.tve_vtabs' ).length ) {
												suffix = ' .tve_scT > ul';
												$element.find( '.tve_scT' ).css( 'padding-left', (dom.value + this.getUM()) );
											} else {
												suffix = ' .tve_scT > ul li';
											}
											$element.head_css( {'width': (dom.value + this.getUM()) + ' !important'}, null, suffix );
										};
										controls['TabsWidth'].change = function ( $element, dom ) {
											this.input( $element, dom );
										};
										controls['TabsWidth'].update = function ( $element ) {
											var width;
											if ( $element.find( '.tve_vtabs' ).length ) {
												width = $element.find( '.tve_scT > ul' ).outerWidth();
											} else {
												width = $element.find( '.tve_scT > ul li' ).first().outerWidth();
											}
											this.setValue( width );
										};
										controls['TabsWidth'].afterConfig = function () {
											this.model.config.max = parseInt( this.applyTo().parent().width() - 100 );
										};

										controls['DefaultTab'].change = function ( $element, dom ) {
											var before = TVE.renderers.base.read_element_props( $element ),
												after;

											$element.find( '.tve_tS' ).removeClass( 'tve_tS' );
											$element.find( 'ul li:nth-child(' + dom.value + ')' ).addClass( 'tve_tS' );
											$element.find( '.tve_scT' ).attr( 'data-selected', (dom.value - 1) );
											after = TVE.renderers.base.read_element_props( $element );
											self.undo_action( $element, before, after );
										};
										controls['DefaultTab'].update = function ( $element ) {
											var self = this,
												html;
											self.$el.find( 'select' ).html( '' );
											$element.find( '.thrv-inline-text:not(.tve_scTC .thrv-inline-text)' ).each( function ( index, element ) {
												var $elem = jQuery( element ),
													label = $elem.text(),
													select = '';

												if ( $elem.closest( 'li' ).hasClass( 'tve_tS' ) ) {
													select = ' selected="selected" ';
												}

												html = '<option class="tve-option" value="' + (index + 1) + '"' + select + '>' + label + '</option>';

												self.$el.find( 'select' ).append( html );
											} );
										};

										controls['EditTabs'].change = function ( $element, dom ) {
											self.edit = dom.value;
											$element.attr( 'data-edit', self.edit );
											controls['TabBackground'].update( $element );
											controls['TabBorder'].update( $element );
											self.$( '.tve-advanced-controls' ).toggle( dom.value == 'active' );

										};
										controls['EditTabs'].update = function ( $element ) {
											var edit = $element.attr( 'data-edit' );
											if ( edit ) {
												self.edit = edit;
											}
										};

										controls['TabBackground'].input = function ( color ) {
											var extra = self.edit == 'active' ? '.tve_tS' : ':not(.tve_tS)';
											this.applyTo().head_css( {'background-color': color + ' !important'}, null, ' .tve_scT > ul li' + extra );
											if ( self.edit == 'active' ) {
												this.applyTo().head_css( {'background-color': color + ' !important'}, null, ' .tve_scT > ul li:hover' );
											}
										};
										controls['TabBackground'].change = function ( color ) {
											this.input( color );
										};
										controls['TabBackground'].update = function ( $element ) {
											var extra = self.edit == 'active' ? '.tve_tS' : ':not(.tve_tS)';
											this.setValue( $element.find( '.tve_scT > ul li' + extra ).css( 'background-color' ) );
										};

										controls['TabBorder'].input = function ( color ) {
											var extra = self.edit == 'active' ? '.tve_tS' : ':not(.tve_tS)';
											this.applyTo().head_css( {'border-color': color + ' !important'}, null, ' .tve_scT > ul li' + extra );
										};
										controls['TabBorder'].change = function ( color ) {
											this.input( color );
										};
										controls['TabBorder'].update = function ( $element ) {
											var extra = self.edit == 'active' ? '.tve_tS' : ':not(.tve_tS)';
											this.setValue( $element.find( '.tve_scT > ul li' + extra ).css( 'border-color' ) );
										};

										controls['ContentColor'].input = function ( color ) {
											this.applyTo().head_css( {'background-color': color}, null, ' .tve_scT .tve_scTC' );
										};
										controls['ContentColor'].change = function ( color ) {
											this.input( color );
										};
										controls['ContentColor'].update = function ( $element ) {
											this.setValue( $element.find( '.tve_scT .tve_scTC' ).css( 'background-color' ) );
										};

										controls['ContentBorder'].input = function ( color ) {
											this.applyTo().head_css( {'border-color': color}, null, ' .tve_scT .tve_scTC' );
										};
										controls['ContentBorder'].change = function ( color ) {
											this.input( color );
										};
										controls['ContentBorder'].update = function ( $element ) {
											this.setValue( $element.find( '.tve_scT .tve_scTC' ).css( 'border-color' ) );
										};
									},
									addTabs: function () {
										var $element = TVE.ActiveElement,
											before = TVE.renderers.base.read_element_props( $element ),
											after,
											new_tab_index = $element.find( '.tve_scT > ul li' ).length + 1,
											labels = ['First', 'Second', 'Third', 'Fourth', 'Fifth', 'Sixth', 'Seventh', 'Eighth', 'Ninth'],
											label = (labels[new_tab_index - 1] ? labels[new_tab_index - 1] : new_tab_index + 'th') + ' Tab',
											new_tab_header_html = '<li><span class="tve_scTC' + new_tab_index + ' thrv-inline-text tve_editable">' + label + '</span></li>',
											new_tab_content_html = '<div class="tve_scTC tve_scTC' + new_tab_index + '" style="min-height: 241px; display: none;"></div>';

										$element.find( '.tve_scT > ul' ).append( new_tab_header_html );
										$element.find( '.tve_scT' ).append( new_tab_content_html );
										this.resize( $element );

										after = TVE.renderers.base.read_element_props( $element );
										this.undo_action( $element, before, after );

										this.controls['DefaultTab'].update( $element );
									},
									resize: function ( $element ) {
										if ( $element.find( '.tve_vtabs' ).length ) {
											$element.find( '.tve_scTC' ).css( 'min-height', ($element.find( '.tve_scT > ul' ).outerHeight() + 40) + 'px' );
										}
									},
									undo_action: function ( $element, before, after ) {
										TVE.UndoManager.add( {
											undo: function () {
												$element.html( before.html );
											},
											redo: function () {
												$element.html( after.html );
											}
										} );
									}
								} );
							},
							"testimonial.js": function (exports, module, require) {
								TVE.TestimonialStyles = require( '../modals/testimonial' );
								var base = require( '../base' );

								module.exports = base.component.extend( {
									setConfig: function ( config ) {
										this.config = config;
									},
									controls_init: function ( controls ) {
										this.instance = TVE.TestimonialStyles.get_instance( TVE.modal.get_element( 'testimonial-styles' ), this )
									},
									change_template: function ( template ) {
										if ( template != this.template ) {
											var data = this.config.templates[template];
											data.template = template;
											this.renderer.set_config( data );
											this.renderer.render_to( TVE.ActiveElement, false );
											TVE.ActiveElement.removeClass( function ( index, className ) {
												return (className.match( /(^|\s)thrv-testimonial-template-\S+/g ) || []).join( ' ' );
											} ).addClass( this.config.templates[template]['custom-class'] ).attr( 'data-template', template );
											TVE.drag.refresh();
										}
									},

									get_current_template: function () {
										var template = TVE.ActiveElement.attr( 'data-template' );
										return template ? template : Object.keys( this.config.templates )[0];
									},

									change_style: function () {
										this.placeholder_action();
									},

									placeholder_action: function () {
										this.instance.open();
									}
								} );
							},
							"text.js": function (exports, module, require) {
								var base = require( '../base' ),
									shadow_base = require( './shadow' ),
									shadow_panel = require( '../controls/shadow' );

								var shadow = shadow_base.extend( {
									/**
									 * Initialize collection with listeners and initialize panels
									 */
									controls_init: function () {
										var self = this;
										this.collection = new Backbone.Collection();
										this.bindListeners();
										this.tabs = {panels: {}};
										this.tabs.panels.text = new shadow_panel( {
											collection: self.collection,
											simplified: true
										} );
										this.setCssAttribute( {css_attribute: 'text-shadow'} );

										this.default_shadow = 'none';
									},

									/**
									 * Component treated as control requires function be implemented
									 */
									applyTo: function () {
										return this.$element;
									},

									/**
									 * Component treated as control requires function be implemented
									 */
									readFrom: function () {
										return this.$element;
									},

									/**
									 * Update css on affected element (also handles preview)
									 */
									change: function () {
										var text_shadow = this.buildShadowAttribute( this.collection );
										if ( TVE.froala.has_selection() ) {
											TVE.froala.exec( text_shadow ? 'format.applyStyle' : 'format.removeStyle', 'text-shadow', text_shadow );
										} else {
											TVE.froala.get_block_element().head_css( {'text-shadow': text_shadow ? text_shadow : 'none'} );
										}
									},

									/**
									 * Refresh component
									 */
									update: function () {
										this.renderShadowAttributes( this.parseCss( TVE.froala.get_css( 'textShadow' ) ) );
									},

									getDefaultValues: function () {
										return {
											angle: 320,
											color: 'rgba(0, 0, 0, 0.4)',
											distance: 3,
											blurr: 2,
											spread: 0
										};
									},

									/**
									 * Add shadow action
									 */
									add_shadow: function ( e, dom ) {
										TVE.SkipUpdate = true;
										var control = this.tabs.panels.text,
											data = this.getDefaultValues();
										this.setBackup();
										control.updateControls( null, null, data );
										if ( control.isOpen() ) {
											control.onCancel();
											return false;
										}

										control.open( null, dom );
										return false;
									},

									/**
									 * Edit existing shadow action
									 */
									edit_shadow: function ( e, dom ) {
										var index = dom.getAttribute( 'data-index' ),
											model = this.collection.findWhere( {index: Number( index )} );
										this.setBackup();
										var control = this.tabs.panels.text;
										control.updateControls( model, null );

										if ( control.isOpen() ) {
											control.onCancel();
											return false;
										}

										control.open( null, dom );
										e.stopPropagation();
										return false;
									}
								} );
								module.exports = base.component.extend( {
									/**
									 * initialize all the controls and extend the change and update function so they can handle the events
									 */
									controls_init: function ( controls ) {

										var self = this;

										controls.shadow = new shadow( {
											el: this.$( '.text-shadow-component' )[0]
										} );

										controls.shadow.controls_init();

										controls['FontColor'].update = function () {
											this.setValue( TVE.froala.get_css( 'color' ) );
										};
										controls['FontColor'].input = function ( color ) {
											color = color ? color.toString() : '';

											self.doAction( color ? 'format.applyStyle' : 'format.removeStyle', 'color', color ? color : 'inherit', true );
										};

										controls['FontBackground'].update = function () {
											this.setValue( TVE.froala.get_css( 'background-color' ) );
										};
										controls['FontBackground'].input = function ( color ) {
											color = color ? color.toString() : '';
											self.doAction( color ? 'format.applyStyle' : 'format.removeStyle', 'background-color', color ? color : 'inherit', true );
										};

										controls['FontSize'].update = function () {
											this.setValue( TVE.froala.get_css( 'fontSize' ) );
										};
										controls['FontSize'].input = function ( $element, dom ) {
											self.doAction( 'format.applyStyle', 'font-size', dom.value + this.getUM(), true );
										};

										controls['LineHeight'].update = function ( $element ) {
											var _value = TVE.froala.get_css( 'lineHeight' );

											if ( _value && _value.indexOf( 'px' ) !== - 1 ) {
												_value = parseFloat( _value ) / parseFloat( $element.css( 'font-size' ) ) + 'em';
											}

											this.setValue( _value );
										};
										controls['LineHeight'].input = function ( $element, dom ) {
											TVE.froala.get_block_element().head_css( {'line-height': dom.value + this.getUM() + ' !important'} );
										};

										controls['LetterSpacing'].update = function () {
											var spacing = TVE.froala.get_css( 'letterSpacing' );
											if ( ! spacing ) {
												spacing = 1;
											}
											this.setValue( spacing );
										};
										controls['LetterSpacing'].input = function ( $element, dom ) {
											self.doAction( 'format.applyStyle', 'letter-spacing', dom.value + this.getUM(), false );
										};

										controls['FontFace'].update = function ( $element ) {
											this.initial_font = TVE.froala.get_css( 'fontFamily' );
											this.setInputValue( this.initial_font );
											this.readFont( $element );
										};

										controls['FontFace'].setInputValue = function ( value ) {
											if ( typeof value === 'undefined' ) {
												value = TVE.getComputedStyle( TVE.froala.has_selection(), 'fontFamily', true );
											}

											value = value.length && this.section === 'inherit' ? 'Inherit: [' + value + ']' : value;

											self.$( '.font-face-input' ).val( value );
										};

										controls.TextTransform.change = function ( $element, dom ) {
											self.doAction( 'format.applyStyle', 'text-transform', dom.getAttribute( 'data-value' ), true );
										};

										controls.TextTransform.update = function ( $element ) {
											this.setActive( TVE.froala.get_css( 'textTransform' ) || 'none' );
										};

									},
									doAction: function ( action, attribute, value, important ) {
										if ( TVE.froala.has_selection() ) {
											TVE.froala.exec( action, attribute, value );
										} else {
											var settings = {};
											settings[attribute] = important ? value + ' !important' : value;
											TVE.froala.get_block_element().head_css( settings );
										}
									},
									openFonts: function ( $element, dom ) {
										this.controls['FontFace'].open( $element, dom );
										this.controls['FontFace'].readFont( $element );

										return false;
									},
									/**
									 * Typefocus control initializer
									 */
									typefocus_control: function () {
										return require( '../controls/text/typefocus' );
									},
									/**
									 * Clears all formats applied to the selection
									 */
									clear_formatting: function () {
										if ( TVE.froala.has_selection() ) {
											TVE.froala.exec( 'commands.clearFormatting' );
											return false;
										} else {
											var block = TVE.froala.get_block_element();
											block.removeAttr( 'data-css' );
											block.find( "span" ).each( function ( index ) {
												var text = jQuery( this ).text();
												jQuery( this ).replaceWith( text );
											} );
										}
									}
								} );
							},
							"toc.js": function (exports, module, require) {
								/**
								 * Created by dan bilauca on 5/9/2017.
								 */

								var base = require( '../base' );

								module.exports = base.component.extend( {
									extra_states: true,
									controls_init: function () {

										/**
										 * Header Text Color
										 */
										this.controls['HeaderColor'].update = function () {
											this.setValue( this.applyTo().css( 'color' ) );

										};
										this.controls['HeaderColor'].input = function ( color ) {
											this.applyTo().head_css( {color: color + ' !important'} );
										};

										/**
										 * Header Background Color
										 */
										this.controls['HeadBackground'].update = function () {
											this.setValue( this.applyTo().css( 'background-color' ) );
										};
										this.controls['HeadBackground'].input = function ( color ) {
											this.applyTo().head_css( {'background-color': color + ''} );
										};

										/**
										 * Headings Control
										 */
										this.controls['Headings'].update = function ( $element ) {

											this.uncheckAll();

											var headers = $element.attr( 'data-headers' ),
												checked_inputs = headers ? headers.split( ',' ) : [];

											_.each( checked_inputs, function ( item, index, list ) {
												this.setChecked( item );
											}, this );
										};
										this.controls['Headings'].input = function ( $element, dom ) {
											var selected_inputs = this.get_checked_inputs(),
												data = selected_inputs.join( ',' );

											if ( selected_inputs.length > this.max_headings ) {
												TVE.page_message( tcb_main_const.i18n.OnlyThreeHeadingsSelected, - 1 );
												dom.checked = false;
												return false;
											}

											$element.attr( 'data-headers', data );
										};

										/**
										 * Columns
										 */
										this.controls['Columns'].update = function ( $element ) {
											var _cols = $element.attr( 'data-columns' );
											this.setValue( _cols );
										};
										this.controls['Columns'].input = function ( $element, select ) {
											$element.attr( 'data-columns', select.value );
											this.component.controls['Headings'].update_content( $element );
										};
									}
								} );
							},
							"toggle.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.component.extend( {
									controls_init: function ( controls ) {
										this.controls['HoverColor'].change = function ( color ) {
											this.applyTo().head_css( {'background': (color + '! important')}, null, ' .tve_faq:hover' ).attr( 'data-hover-color', color );
										};
										this.controls['HoverColor'].update = function ( $element ) {
											var color = $element.attr( 'data-hover-color' );
											if ( ! color ) {
												var classAttr = $element.attr( 'class' ),
													classArray = classAttr.split( ' ' );
												classArray.forEach( function ( entry ) {
													if ( ( entry.indexOf( 'tve_' ) > - 1) && entry !== 'tve_draggable' ) {
														color = entry.replace( 'tve_', '' );
													}
												} );
											}
											this.setValue( color );
										};
									},
									toggle: function () {
										return require( '../controls/toggle' );
									},
									close_editor: function () {
										this.controls.Toggle.close_editor();
										return false;
									}
								} );
							},
							"typography.js": function (exports, module, require) {
								var base = require( '../base' ),
									shadow_base = require( './shadow' ),
									shadow_panel = require( '../controls/shadow' );

								var shadow = shadow_base.extend( {
									/**
									 * Initialize collection with listeners and initialize panels
									 */
									controls_init: function () {
										var self = this;
										this.collection = new Backbone.Collection();
										this.bindListeners();
										this.tabs = {panels: {}};
										this.tabs.panels.text = new shadow_panel( {
											collection: self.collection,
											simplified: true
										} );
										this.setCssAttribute( {css_attribute: 'text-shadow'} );
									},

									/**
									 * Component treated as control requires function be implemented
									 */
									applyTo: function () {
										return this.$element;
									},

									/**
									 * Component treated as control requires function be implemented
									 */
									readFrom: function () {
										return this.$element;
									},

									/**
									 * Set current element
									 */
									setTarget: function ( $elem ) {
										this.$element = $elem;
									},

									/**
									 * Set current element reset collection and update
									 */
									update: function () {
										this.collection.reset();
										shadow_base.prototype.update.call( this );
									},

									getDefaultValues: function () {
										return {
											angle: 320,
											color: 'rgba(0, 0, 0, 0.4)',
											distance: 3,
											blurr: 2,
											spread: 0
										};
									},

									/**
									 * Add shadow action
									 */
									add_shadow: function ( e, dom ) {
										TVE.SkipUpdate = true;
										var control = this.tabs.panels.text,
											data = this.getDefaultValues();
										this.setBackup();

										control.updateControls( null, null, data );
										if ( control.isOpen() ) {
											control.onCancel();
											return false;
										}

										control.open( null, dom );
										return false;
									},

									/**
									 * Edit existing shadow action
									 */
									edit_shadow: function ( e, dom ) {
										var index = dom.getAttribute( 'data-index' ),
											model = this.collection.findWhere( {index: Number( index )} );
										this.setBackup();
										var control = this.tabs.panels.text;
										control.updateControls( model, null );

										if ( control.isOpen() ) {
											control.onCancel();
											return false;
										}

										control.open( null, dom );
										e.stopPropagation();
										return false;
									}
								} );

								module.exports = base.component.extend( {
									extra_states: true,
									/**
									 * initialize all the controls and extend the change and update function so they can handle the events
									 */
									controls_init: function ( controls ) {

										var self = this;

										controls['TextShadow'] = new shadow( {
											el: this.$( '.text-shadow-component' )[0]
										} );

										controls['TextShadow'].controls_init();

										controls['FontSize'].input = function ( $element, dom ) {
											this.applyTo().head_css( {'font-size': dom.value + this.getUM()}, false, this.config.css_suffix, false, this.config.css_prefix );
										};

										controls['FontSize'].update = function () {
											this.setValue( this.applyTo().head_css( 'font-size', false, this.config.css_suffix, true, this.config.css_prefix ) );
										};

										controls['FontColor'].input = function ( color ) {
											var i = this.config.important ? ' !important' : '';
											this.applyTo().head_css( {'color': color + i}, false, this.config.css_suffix, false, this.config.css_prefix );
										};

										controls['FontColor'].update = function () {
											this.setValue( this.applyTo().head_css( 'color', false, this.config.css_suffix, true ) );
										};

										controls['LineHeight'].input = function ( $element, dom ) {
											this.applyTo().head_css( {'line-height': dom.value + this.getUM()}, false, this.config.css_suffix, false, this.config.css_prefix );
										};

										controls['LineHeight'].update = function ( $element ) {
											var value = this.applyTo().head_css( 'line-height', false, this.config.css_suffix, false, this.config.css_prefix );

											if ( ! value ) { // When input drops value can be undefined so it triggers an error with slider.js -> setValue method
												value = $element.css( 'line-height' );
												//Convert Default Px Values To UM
												if ( value && value.indexOf( 'px' ) !== - 1 ) {
													value = parseFloat( value ) / parseFloat( $element.css( 'font-size' ) ) + 'em';
												}
											}
											if ( 'normal' === value ) {
												value = '1.12em';
											}

											this.setValue( value );
										};

										controls['LetterSpacing'].input = function ( $element, dom ) {
											$element.head_css( {'letter-spacing': dom.value + this.getUM()}, false, this.config.css_suffix, true, this.config.css_prefix );
										};

										controls['LetterSpacing'].update = function () {
											this.setValue( this.applyTo().head_css( 'letter-spacing', false, this.config.css_suffix, true, this.config.css_prefix ) );
										};

										controls['FontFace'].update = function ( $element ) {
											this.initial_font = this.applyTo().head_css( 'font-family', false, this.config.css_suffix, true, this.config.css_prefix );

											this.setInputValue( this.initial_font );

											this.readFont( $element );
										};

										controls['FontFace'].setInputValue = function ( value ) {
											if ( typeof value === 'undefined' ) {
												value = this.applyTo().css( 'font-family');
											}

											value = value.length && this.section === 'inherit' ? 'Inherit: [' + value + ']' : value;

											self.$( '.font-face-input' ).val( value );
										};

										controls['TextAlign'].change = function ( $element, dom ) {
											var css = {};
											if ( this.config.property && this.config.property_val ) {
												css[this.config.property] = this.config.property_val[dom.getAttribute( 'data-value' )];
											} else {
												css['text-align'] = dom.getAttribute( 'data-value' );
											}

											$element.head_css( css, false, this.config.css_suffix, true, this.config.css_prefix );
										};

										controls['TextAlign'].update = function () {
											var _alignment;
											if ( this.config.property && this.config.property_val ) {
												_alignment = this.applyTo().head_css( this.config.property, false, this.config.css_suffix, true );
												_alignment = _.invert( this.config.property_val )[_alignment];
											} else {
												_alignment = this.applyTo().head_css( 'text-align', false, this.config.css_suffix, true );
												_alignment = _alignment === 'start' ? 'left' : _alignment;
											}

											this.setActive( _alignment );
										};

										function build_text_decoration() {
											var css = '';
											this.$( '.tve-btn.active[data-style="text-decoration"]' ).each( function () {
												css += (css ? ' ' : '') + this.dataset.value;
											} );

											return css ? css : 'none';
										}

										controls['TextStyle'].change = function ( $element, dom ) {
											var prop = dom.dataset.style,
												active = dom.classList.contains( 'active' ),
												style = {};

											style[prop] = active ? dom.getAttribute( 'data-value' ) : '';

											/**
											 * text-decoration gets special treatment
											 */
											if ( prop && prop === 'text-decoration' ) {
												style[prop] = build_text_decoration.call( this );
											} else if ( ! active ) {
												/* the "off" value must be applied - to overwrite some potential default settings */
												style[prop] = dom.dataset.off;
											}

											if ( style[prop] ) {
												style[prop] += ' !important';
											}
											$element.head_css( style, false, this.config.css_suffix, true, this.config.css_prefix );
										};

										controls['TextStyle'].update = function ( $element ) {
											var values = [];

											_.each( this.model.config.buttons, function ( button ) {
												var css = $element.css( button.data.style );
												if ( css && css.indexOf( button.value ) !== - 1 ) {
													values.push( button.value );
												}
											} );
											this.setActive( values );
										};

										controls['TextTransform'].change = function ( $element, dom ) {
											$element.head_css( {'text-transform': dom.getAttribute( 'data-value' )}, false, this.config.css_suffix, true, this.config.css_prefix );
										};

										controls['TextTransform'].update = function ( $element ) {
											this.setActive( $element.css( 'text-transform' ) || 'none' );
										};
									},
									openFonts: function ( $element, dom ) {
										this.controls['FontFace'].open( $element, dom );
										this.controls['FontFace'].readFont( $element );

										return false;
									}
								} );
							},
							"wordpress.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 4/10/2017.
								 */
								TVE.WordPressContent = require( '../modals/wordpress-content' );
								var base = require( '../base' );

								module.exports = base.component.extend( {
									controls_init: function ( controls ) {
										this.wordPressContentInstance = TVE.WordPressContent.get_instance( TVE.modal.get_element( 'wordpress-content' ) )
									},
									edit_wordpress_content: function () {
										this.placeholder_action();
									},
									/**
									 * Triggered when clicking "Insert WordPress Content" button
									 * Opens up an inline drop panel
									 */
									placeholder_action: function () {
										this.wordPressContentInstance.open();
									}
								} );
							}
						},
						"controls": {
							"api-connections.js": function (exports, module, require) {
								var base = require( '../base' ),
									api_connections = require( '../modals/api-connections' ),
									api = require( '../../models/api' ),
									ConnectedApi;

								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/lead-generation/api-connections' ),

									before_initialize: function () {
										this.connectionsModal = new api_connections( {
											el: TVE.modal.get_element( 'api-connections' )
										} );
									},

									after_initialize: function () {
										this.$connected_apis = this.$( '.connected-apis' );
										this.$button = this.$( 'button' );
									},

									serviceConnect: function () {
										this.connectionsModal.open( {
											component: this.component
										} );
									},
									/**
									 * Read connections and extra fields from the lead generation element config and reder already connected
									 * @param $element
									 */
									update: function ( $element ) {

										$element = $element.length ? $element : TVE.ActiveElement;

										var type = $element.data( 'lg' ).get( 'type' );

										switch ( type ) {
											case 'custom-html':
												this.renderCustomHTML();
												break;

											case 'api':
											default:
												this.renderConnections();
												break;
										}

										$element.data( 'lg' ).removeCallbacks( 'write', 'type' );
										/* each time we change the api connection type, we render this again */
										$element.data( 'lg' ).registerCallback( 'write', 'type', this.update, this );
									},

									renderCustomHTML: function () {
										this.$button.attr( 'data-fn', 'editCustomCode' ).html( TVE.t.EditHTML );
										this.$connected_apis.hide();
									},

									editCustomCode: function () {
										this.connectionsModal.open( {
											form: true
										} );
									},

									renderConnections: function () {
										var apis = this.applyTo().data( 'lg' ).get( 'apis' );

										this.$button.attr( 'data-fn', 'serviceConnect' );
										this.$connected_apis.show();

										this.$el.removeClass( 'greyish' );

										if ( Object.keys( apis ).length ) {

											this.$button.html( TVE.t.ManageConnections );

											this.$connected_apis.empty();

											_.each( apis, function ( config, conn ) {
												var c = new ConnectedApi( {
													model: new api( {
														key: conn,
														name: conn
													} )
												} );
												this.$connected_apis.append( c.$el )
											}, this );

										} else {
											this.$el.addClass( 'greyish' );

											this.$button.html( TVE.t.ConnectService );

											this.$connected_apis.html( '<p>' + TVE.t.NoConnections + '</p>' );
										}
									},
									input: function () {

									},
									disconnect: function ( $element, dom ) {
										var key = dom.getAttribute( 'data-api' ),
											apis = $element.data( 'lg' ).get( 'apis' );

										delete apis[key];

										$element.data( 'lg' ).set( {'apis': apis, 'write': 'apis'} );
										/* do callback for rendering the connections again */
										$element.data( 'lg' ).doCallbacks( 'write', 'type' );
									},
									edit: function ( $element, dom ) {

										var key = dom.getAttribute( 'data-api' );

										this.connectionsModal.open( {
											api: key
										} );
									}
								} );

								ConnectedApi = base.base_view.extend( {
									template: TVE.tpl( 'controls/lead-generation/connected-api' ),
									className: 'col-xs-12 api-box',
									tagName: 'div'
								} );

							},
							"background": {
								"gradient-pattern.js": function (exports, module, require) {
									var PanelBase = require( './panel-base' ),
										Input = require( '../input' ),
										gradient_build = require( '../../../libs/gradient-builder' ),
										tinycolor = require( '../../../libs/tinycolor' ),
										ColorPicker = require( '../color-picker' );

									module.exports = PanelBase.extend( {
										template: TVE.tpl( 'controls/gradient-pattern' ),
										key: function () {
											return 'gradient-pattern';
										},
										/**
										 * Builds up the CSS for gradient patterns
										 */
										before_initialize: function () {
											this.defaults();

											this.patterns = [
												{angle: '135deg'},
												{angle: '45deg'},
												{angle: '90deg', gutter1: '2px', gutter2: '4px'},
												{angle: '0deg'},
												{size: '3px 3px', type: 'repeating-radial-gradient', angle: 'circle at center center', gutter1: '1px', gutter2: '100%'}
											].map( function ( item ) {
												item.css = gradient_build( this.build_node( item.type, item.angle, null, item.gutter1, item.gutter2, item.size ) );

												return item;
											}, this );
										},
										/**
										 * Reset controls to default values
										 */
										defaults: function () {
											this.values = {
												opacity: 70,
												index: 0,
												color1: 'rgb(240, 243, 243)'
											};

											return this;
										},
										/**
										 * Choose new pattern type
										 *
										 * @param e
										 * @param btn
										 * @returns {boolean}
										 */
										select: function ( e, btn ) {
											TVE.SKIP_CSS_STATE = true;
											this.$( '.pattern-item' ).removeClass( 'selected' );
											btn.classList.add( 'selected' );
											this.values.index = parseInt( btn.getAttribute( 'data-index' ) );
											this.change();

											return false;
										},
										/**
										 * Each change / input in a control will trigger an update in the DOM
										 */
										init_controls: function () {

											var self = this;

											this.controls = {
												opacity: new Input( {
													el: this.$( '.opacity-input' )[0],
													model: this.opacity_options()
												} ),
												color1: new ColorPicker( {
													el: this.$( '.color1' )[0],
													model: this.color_options()
												} )
											};

											this.controls.opacity.input = this.controls.opacity.change = function () {
												TVE.SKIP_CSS_STATE = true;
												self.values.opacity = this.getValue();
												self.change();
											};
											this.controls.color1.input = this.controls.color1.change = function ( obj ) {
												TVE.SKIP_CSS_STATE = true;
												self.values.color1 = obj ? obj.toString() : 'transparent';
												self.change();
											};
										},
										/**
										 * Options for the opacity control
										 *
										 * @returns {{config: {name, um: string, default: string, min: number, max: number}}}
										 */
										opacity_options: function () {
											return {
												config: {
													name: TVE.t.opacity,
													um: '%',
													default: '100',
													min: 0,
													max: 100
												}
											};
										},
										/**
										 * Options for the color controls
										 *
										 * @returns {{config: {options: {output: string, showInput: boolean, showGradient: boolean, showAlpha: boolean}}}}
										 */
										color_options: function () {
											return {
												config: {
													options: {
														output: 'object',
														showInput: false,
														showGradient: false,
														showAlpha: false
													}
												}
											};
										},
										/**
										 * Reset this control to its default state and return a default background-image model for this section
										 */
										get_default_data: function () {
											this.defaults();
											this.dom();

											// prevent another read from the model on the default setup
											this.flag_dom_skip = true;

											return this._get_default_data();
										},
										/**
										 * Get the default data for a background-image model
										 * Called during "ADD"
										 *
										 * @returns {*}
										 */
										_get_default_data: function () {
											return this.build_node( this.patterns[this.values.index] );
										},
										/**
										 *
										 * @param type
										 * @param angle
										 * @param color1
										 * @param gutter1
										 * @param gutter2
										 * @param size
										 * @returns {{type: (*|string), orientation: (*|string), colorStops: [*,*,*,*], size: (*|string)}}
										 */
										build_node: function ( type, angle, color1, gutter1, gutter2, size ) {
											if ( typeof type === 'object' ) {
												angle = type.angle;
												color1 = type.color1;
												gutter1 = type.gutter1;
												gutter2 = type.gutter2;
												size = type.size;
												type = type.type;
											}

											color1 = color1 || this.values.color1;
											var tc1 = tinycolor( color1 );

											if ( color1 && color1 !== 'transparent' ) {
												tc1.setAlpha( this.values.opacity / 100 );
											}

											return {
												type: type || 'repeating-linear-gradient',
												orientation: angle || '135deg',
												colorStops: [
													{
														type: 'literal',
														transparent: color1 === 'transparent' ? 'transparent' : false,
														value: tc1
													},
													{
														type: 'literal',
														transparent: color1 === 'transparent' ? 'transparent' : false,
														value: tc1,
														length: gutter1 || '3px'
													},
													{
														type: 'literal',
														transparent: 'transparent',
														value: 'transparent',
														length: gutter1 || '3px'
													},
													{
														type: 'literal',
														transparent: 'transparent',
														value: 'transparent',
														length: gutter2 || '6px'
													}
												],
												size: size || 'auto auto',
												repeat: 'repeat'
											};
										},
										/**
										 * Triggers a change in the collection in order to update the preview on the canvas
										 * Sets the properties on the model
										 */
										change: function () {
											this.model.set( this.build_node( this.patterns[this.values.index] ) );
											this.collection.trigger( 'change' );
										},
										/**
										 * nothing needed here
										 */
										input: function () {
										},
										/**
										 * read data from the model
										 */
										read: function () {
											var type = this.model.get( 'real_type' ) || this.model.get( 'type' ),
												orientation = gradient_build( this.model.get( 'orientation' ) ),
												self = this;

											/* Read in pattern type */
											_.every( this.patterns, function ( pattern, index ) {
												pattern.type = pattern.type || 'repeating-linear-gradient';
												pattern.angle = pattern.angle || '135deg';
												if ( pattern.type === type && orientation === pattern.angle ) {
													self.values.index = index;
													return false;
												}
												return true;
											} );

											/* Read in colors and opacity */
											var color_stops = this.model.get( 'colorStops' );
											self.values.color1 = color_stops[0].transparent || color_stops[0].value.toHex();
											this.values.opacity = 0.7;
											if ( self.values.color1 !== 'transparent' ) {
												this.values.opacity = color_stops[0].value.getAlpha();
											}
											this.values.opacity = Math.round( this.values.opacity * 100 );
										},
										/**
										 * Update DOM / included controls for the control
										 */
										dom: function () {
											this.$( '.pattern-item' ).removeClass( 'selected' ).get( this.values.index ).classList.add( 'selected' );
											this.controls.opacity.setValue( this.values.opacity );
											this.controls.color1.setValue( this.values.color1 );

											return this;
										}
									} );
								},
								"gradient.js": function (exports, module, require) {
									var PanelBase = require( './panel-base' ),
										gradient_build = require( '../../../libs/gradient-builder' ),
										tinycolor = require( '../../../libs/tinycolor' ),
										GradientPicker = require( '../../../libs/gradient-picker' );

									module.exports = PanelBase.extend( {
										template: _.template( '<div class="gradient-layer"></div>' ),
										key: function () {
											return 'gradient';
										},
										/**
										 * Each change / input in a control will trigger an update in the DOM
										 */
										init_controls: function () {

											this.picker = ( new GradientPicker( {
												el: this.$( '.gradient-layer' )[0]
											} ) ).on( 'change', _.bind( this.on_change, this ) );
										},
										/**
										 * Get the default data for a "solid" background gradient: a gradient with a 2 identical color stops
										 * Called during "ADD"
										 *
										 * @returns {*}
										 */
										_get_default_data: function () {
											return this.picker.defaults();
										},
										on_change: function ( gradient_node ) {
											this.model.set( gradient_node );
										},
										/**
										 * Read data from the model
										 */
										dom: function () {
											this.picker.setValue( this.model.toJSON() );
										},
										/**
										 *
										 */
										onOpen: function () {
											this.picker.reflow();
											this.picker.render_favorites();
										}
									} );
								},
								"image.js": function (exports, module, require) {
									var PanelBase = require( './panel-base' ),
										FilePicker = require( '../file' );

									module.exports = PanelBase.extend( {
										template: TVE.tpl( 'controls/background-image' ),
										key: function () {
											return 'url';
										},
										/**
										 * Each change / input in a control will trigger an update in the DOM
										 */
										init_controls: function () {
											this.picker = new FilePicker( {
												labels: {
													choose: TVE.t.ChooseImage
												},
												el: this.$( '.image-picker' )[0]
											} );
											this.picker.on( 'select', _.bind( this.on_select, this ) );
											this.picker.on( 'remove', _.bind( this.on_remove, this ) );
										},
										on_select: function ( attachment ) {
											this.model.set( 'value', attachment.url );
											this.change();
										},
										on_remove: function () {
											this.model.set( 'value', '' );
											this.change();
										},
										/**
										 * Setup background-image properties
										 *
										 * @param e
										 * @param select
										 */
										prop: function ( e, select ) {
											var props = this.$( select ).val().split( ':' ),
												data = {};
											data[props[0]] = props[1];

											this.model.set( _.extend( {
												size: 'auto auto',
												repeat: 'no-repeat',
												position: '0 0'
											}, data ) );

											this.change();
										},
										/**
										 * fixed background images
										 *
										 * @param e
										 * @param checkbox
										 */
										static: function ( e, checkbox ) {
											this.model.set( {attachment: checkbox.checked ? 'fixed' : 'scroll'} );
											this.change();
										},
										/**
										 * Get the default data for a background-image model
										 * Called during "ADD"
										 *
										 * @returns {Object}
										 */
										get_default_data: function () {
											return {
												type: 'url',
												value: '',
												size: 'auto'
											};
										},
										/**
										 * Update DOM / included controls for the control
										 */
										dom: function () {
											var picker_data = null;
											if ( this.model.get( 'value' ) ) {
												picker_data = {url: this.model.get( 'value' )};
											}
											this.picker.set( picker_data );
											this.$( '#bg-static' ).prop( 'checked', this.model.get( 'attachment' ) === 'fixed' );

											/* update the Image Display control - TODO: this is not OK - each of the options from the Image Display control can co-exist */
											var $prop = this.$( '#bg-image-prop' ),
												value = $prop.find( 'option' ).first().val();
											if ( this.model.get( 'size' ) === 'cover' ) {
												value = 'size:cover';
											} else if ( this.model.get( 'position' ) && this.model.get( 'position' ).indexOf( 'center' ) !== - 1 ) {
												value = 'position:center';
											} else if ( this.model.get( 'repeat' ) === 'repeat' ) {
												value = 'repeat:repeat';
											}
											$prop.val( value );

											return this;
										},
										/**
										 * Validates the data - a background image must be selected
										 *
										 * @returns {boolean}
										 */
										validate: function () {
											if ( ! this.model.get( 'value' ) ) {
												TVE.page_message( TVE.t.anim.img_missing, true );
												return false;
											}
											return true;
										}
									} );
								},
								"panel-base.js": function (exports, module, require) {
									var DropPanel = require( '../drop-panel' );

									/**
									 * Base object for all drop panels used under the Background Component
									 *
									 * @var PanelBase
									 */
									module.exports = DropPanel.extend( {
										/**
										 * Setup the default values
										 */
										before_initialize: function () {
											this.defaults();
										},
										/**
										 * Initialize the controls included in this background drop panel
										 */
										after_initialize: function () {
											this.init_controls();
										},
										/**
										 * Reset controls to default values
										 */
										defaults: function () {
											this.values = {};

											return this;
										},
										/**
										 * Should be used to initialize all the controls
										 */
										init_controls: function () {

										},
										/**
										 * Read from DOM. Defaults to noop
										 */
										update: function () {
										},
										/**
										 * Reset this control to its default state and return a default background-image model for this section
										 */
										get_default_data: function () {
											this.defaults();

											return this._get_default_data();
										},
										/**
										 * Trigger the change event on the collection, in order to re-apply the CSS rules
										 */
										change: function () {
											this.collection.trigger( 'change' );
										},
										/**
										 * Read data from the model
										 *
										 * @param model
										 */
										reset: function ( model ) {
											this.model = model;

											if ( this.flag_dom_skip ) {
												delete this.flag_dom_skip;
												return this;
											}
											this.read();

											this.dom();
										},
										/**
										 * Read data from the model (this.model)
										 */
										read: function () {
										},
										/**
										 * Should update the controls to their corresponding values
										 */
										dom: function () {
										},
										/**
										 * Cancel the changes and close the gradient pattern control
										 */
										cancel: function () {
											TVE.SKIP_CSS_STATE = true;
											/* we don't save any css and we delete the initial state */
											TVE.UndoManager.temp.delete();
											if ( this.model.get( '__new' ) ) {
												this.model.destroy();
											} else {
												this.model.restoreState();
											}
										},
										/**
										 * Applies the background. No action needed here
										 */
										apply: function () {
											TVE.SKIP_CSS_STATE = false;
											/* trigger change on collection so it will write css in head and we'll save this for undo/redo manager */
											this.model.unset( '__new' );
										}
									} );
								},
								"solid.js": function (exports, module, require) {
									var PanelBase = require( './panel-base' ),
										tinycolor = require( '../../../libs/tinycolor' ),
										ColorPicker = require( '../color-picker' );

									module.exports = PanelBase.extend( {
										template: _.template( '<div class="gradient-solid-picker"></div>' ),
										key: function () {
											return 'solid';
										},
										/**
										 * Each change / input in a control will trigger an update in the DOM
										 */
										init_controls: function () {

											var self = this;

											this.color = new ColorPicker( {
												el: this.$( '.gradient-solid-picker' )[0],
												model: this.color_options()
											} );

											this.color.input = function ( obj ) {
												TVE.SKIP_CSS_STATE = true;
												self.model.get( 'colorStops' )[0].value = obj || 'transparent';
												self.model.get( 'colorStops' )[1].value = obj || 'transparent';
												self.change();
											};
										},
										/**
										 * Options for the color control
										 *
										 * @returns {{config: {options: {output: string, showInput: boolean, showGradient: boolean, showAlpha: boolean}}}}
										 */
										color_options: function () {
											return {
												config: {
													options: {
														output: 'object',
														showInput: true,
														showGradient: false,
														showAlpha: true,
														flat: true,
														showButtons: false
													}
												}
											};
										},
										/**
										 * Get the default data for a "solid" background gradient: a gradient with a 2 identical color stops
										 * Called during "ADD"
										 *
										 * @returns {*}
										 */
										_get_default_data: function () {
											return {
												type: 'solid',
												real_type: 'linear-gradient',
												colorStops: [
													{type: 'literal', value: '#000'},
													{type: 'literal', value: '#000'}
												]
											};
										},
										onOpen: function () {
											this.color.colorPicker.spectrum( 'reflow' );
											this.color.setValue( this.model.get( 'colorStops' )[0].value );
											this.color.render_favorites();
										}
									} );
								},
								"video.js": function (exports, module, require) {
									(function ( $ ) {
										var IconLabelSwitch = require( '../icon-label-switch' ),
											VideoControls = require( '../../components/animation/video-popup' ),
											VIDEO_ID = 0;

										/** @var {VideoBackground} */
										module.exports = IconLabelSwitch.extend( {
											cls: 'tcb-video-background-el',
											parent_cls: 'tcb-video-background-parent',
											/**
											 *
											 * @returns {*|exports.Model}
											 */
											default_model: function () {
												return new Backbone.Model( {
													device: TVE.t.video_background
												} );
											},
											/**
											 * Override the render method - we also need to append the video controls to this.$el
											 */
											render: function () {
												IconLabelSwitch.prototype.render.apply( this, arguments );

												this.$el.append( TVE.tpl( 'controls/background-video' )() );

												return this;
											},
											/**
											 * Triggered when an element is selected
											 */
											update: function ( $element ) {
												if ( this.$el.hasClass( 'control-hide' ) ) {
													return;
												}
												var has_video = $element.hasClass( this.cls );

												this.model = new Backbone.Model( has_video ? this.read() : {config: {}} );
												this.video_settings.set_model( this.model );

												if ( this.isChecked() !== has_video ) {
													this.setChecked( has_video );
													this.update_controls( has_video );
												}
											},
											update_controls: function ( has_video ) {
												this.$el.toggleClass( 'expanded', has_video );
											},
											/**
											 * Triggered when there is a change in the control
											 */
											input: function ( checked, skip_undo ) {
												if ( this.$el.hasClass( 'control-hide' ) ) {
													return;
												}
												if ( typeof checked === 'undefined' ) {
													checked = this.isChecked();
												}

												this.$el.toggleClass( 'expanded', checked );
												if ( ! checked ) {
													if ( ! skip_undo ) {
														TVE.Editor_Page.before_action();
													}
													this.clear();
													if ( ! skip_undo ) {
														TVE.Editor_Page.after_action();
													}
												} else {
													this.apply();
												}
											},
											clear: function ( $element ) {
												$element = typeof $element !== 'undefined' ? $element : this.applyTo();
												$element.removeClass( this.cls ).find( '> iframe,> video,> script,> .wistia_embed' ).remove();
												$element.parent().removeClass( this.parent_cls );
											},
											/**
											 * Initializes the video controls, the same options as in the animation component
											 */
											after_initialize: function () {
												this.video_settings = new VideoControls( {
													config: {}
												} );

												this.$el.append( this.video_settings.$el.addClass( 'video-options' ) );
												this.$( '.tcb-dark' ).removeClass( 'tcb-dark' );
												this.$( '.extra-settings' ).remove();
												this.video_settings.remove_provider( 'youtube' );

												this.video_settings.on( 'change', _.bind( this.apply, this ) );
												this.$( 'input[type=checkbox]' ).prop( 'checked', false );
											},
											/**
											 * Applies the video settings
											 */
											apply: function () {
												var code = this.video_settings.get_embed_code( 'background' ),
													$element = this.applyTo();

												TVE.Editor_Page.before_action();
												this.clear( $element );

												if ( ! code ) {
													return this;
												}

												$element.addClass( this.cls ).prepend( code );
												$element.parent().addClass( this.parent_cls );

												TVE.Editor_Page.after_action();

												return this;
											},
											read: function () {
												var $element = this.applyTo(),
													data = {p: {}},
													$wistia = $element.find( '> .wistia_embed' ).first(),
													$custom = $element.find( '> video.tcb-bg-video' ).first(),
													$iframe = $element.find( '> iframe' ).first();

												if ( $wistia.length ) {
													data.s = 'wistia';
													data.p = {
														id: $wistia.attr( 'data-id' ),
														url: 'https://wistia.com/embed/' + $wistia.attr( 'data-id' )
													}
												} else if ( $custom.length ) {
													data.s = 'custom';
													data.p = {
														id: $custom.attr( 'data-id' ),
														title: $custom.attr( 'data-title' )
													}
												} else if ( $iframe.length ) {
													/* vimeo */
													data.s = $iframe.attr( 'data-provider' );
													data.p = {
														url: $iframe.attr( 'src' )
													};
													var r = new RegExp( '/video/(.+?)\\?' );
													if ( data.p.url.match( r ) ) {
														data.p.id = RegExp.$1;
													}
												}

												return {
													config: data
												};
											}
										} );
									})( jQuery );
								}
							},
							"borders.js": function (exports, module, require) {
								var base = require( '../base' ),
									input = require( '../controls/input' ),
									buttonGroup = require( '../controls/button-group' ),
									colorPicker = require( '../controls/color-picker' );

								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/borders' ),
									sides: ['top', 'left', 'right', 'bottom'],
									config: {},
									initialize: function () {
										this.render();

										this.controls = {
											Color: new colorPicker( {
												el: this.$el.find( '.tve-border-color' ),
												model: {
													config: {
														options: {
															showInput: true,
															showGradient: false
														}
													}
												}
											} ),
											Width: new input( {
												el: this.$el.find( '.tve-border-width' ),
												model: {
													config: {
														stepSize: 3,
														name: '',
														min: 0,
														um: 'PX'
													}
												}
											} ),
											Style: new buttonGroup( {
												el: this.$el.find( '.tve-border-style' ),
												model: {
													config: {
														name: '',
														buttons: [
															{icon: '', text: 'NONE', value: 'none', default: true},
															{icon: 'solid', value: 'solid'},
															{icon: 'dashed', value: 'dashed'},
															{icon: 'dotted', value: 'dotted'}
														]
													}
												}
											} )
										};

										this.controls_init( this.controls );
									},
									/**
									 * Initialize controls update and change/input function
									 * @param controls
									 */
									controls_init: function ( controls ) {

										var self = this;

										controls.Width.input = function ( $element ) {
											if ( ! self.controls.Color.getValue() ) {
												self.controls.Color.setValue( '#000' );
											}
											if ( ! self.controls.Style.getValue() || self.controls.Style.getValue() === 'none' ) {
												self.controls.Style.setActive( 'solid' );
											}
											self.change( $element );
										};

										controls.Width.update = function () {
											var width = this.readFrom().css( self.style( 'width' ) );
											this.setValue( parseInt( width ) );
										};

										controls.Style.input = function ( $element ) {
											if ( ! self.controls.Color.getValue() ) {
												self.controls.Color.setValue( '#000' );
											}
											var w = parseInt( self.controls.Width.getValue() );
											if ( isNaN( w ) || ! parseInt( w ) ) {
												self.controls.Width.setValue( '1' );
											}
											self.change( $element );
										};

										controls.Style.update = function () {
											var width = this.readFrom().css( self.style( 'style' ) );
											this.setActive( width );
										};

										controls.Color.input = function () {
											var w = parseInt( self.controls.Width.getValue() );
											if ( isNaN( w ) || ! parseInt( w ) ) {
												self.controls.Width.setValue( '1' );
											}
											if ( ! self.controls.Style.getValue() || self.controls.Style.getValue() === 'none' ) {
												self.controls.Style.setActive( 'solid' );
											}
											self.change( this.applyTo() );
										};

										controls.Color.update = function () {
											var color = this.readFrom().css( self.style( 'color' ) );
											this.setValue( color );
										};
									},
									/**
									 * Apply specific config on the control. We overwrite this so we can call the setConfig on the sub controls.
									 *
									 * @param config
									 * @param to
									 */
									setConfig: function ( config, to ) {

										base.control.prototype.setConfig.apply( this, arguments );

										var args = arguments;

										_.each( this.controls, function ( view ) {
											view.setConfig.apply( view, args );
										} );
									},
									/**
									 * Update element css when one of the control changes.
									 * @param $element
									 * @returns {boolean}
									 */
									change: function ( $element ) {

										var css = {},
											side = this.border_side === '' ? 'border' : 'border-' + this.border_side,
											important = this.config.important ? ' !important' : '',
											color = this.controls.Color.getValue(),
											style = this.controls.Style.getValue();

										if ( ! color ) {
											color = 'transparent';
										}
										if ( style === 'none' ) {
											css[side] = '';
										} else {
											css[side] = this.controls.Width.getValue() + 'px ' +
											            style + ' ' +
											            color + important;
										}

										this.applyTo().head_css( css, null, this.config.css_suffix, false, this.config.css_prefix );
									},
									/**
									 * update component with css from the element
									 */
									update: function () {
										this.border_side = '';

										this.$el.find( '.tve-border-side' ).removeClass( 'active' ).filter( '.default' ).addClass( 'active' );

										/* update the controls for the selected border */
										this.controls.Width.update();
										this.controls.Color.update();
										this.controls.Style.update();
									},
									/**
									 * When a border side is selected
									 * @param $element
									 * @param dom
									 */
									borderSide: function ( $element, dom ) {
										/* save the border that was selected */
										this.border_side = dom.getAttribute( 'data-value' );

										/* mark the current border as active */
										this.$el.find( '.tve-border-side' ).removeClass( 'active' );
										dom.className += ' active';

										/* update the controls for the selected border */
										this.controls.Width.update();
										this.controls.Color.update();
										this.controls.Style.update();
									},
									/**
									 * Return css style for a specific border
									 * @param style
									 * @returns {*}
									 */
									style: function ( style ) {
										var css = style;

										if ( this.border_side && this.border_side != '' ) {
											css = this.border_side + '-' + css;
										}

										css = 'border-' + css;

										return css;
									},
									input: function () {
									}
								} );
							},
							"button-group.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/button-group' ),
									toggle: false,
									initialize: function ( attributes ) {
										if ( this.model ) {
											this.render();
										}
										// allow toggle on / off
										if ( attributes.toggle ) {
											this.toggle = attributes.toggle;
										}
									},
									/**
									 * Handle click event
									 *
									 * @param $element
									 * @param dom
									 */
									_click: function ( $element, dom ) {
										if ( this.toggle && dom.className.indexOf( 'active' ) !== - 1 ) {
											dom.classList.remove( 'active' );
											this.change( $element, dom );
											this.trigger( 'change' );
											return false;
										}

										if ( this.model.config.checkbox ) {
											dom.classList.toggle( 'active' );
										} else {
											this.clearActive();
											dom.classList.add( 'active' );
										}

										this.change( $element, dom );
										this.trigger( 'change' );
									},
									/**
									 * Make one of the buttons active
									 * @param value value of the button to make active
									 */
									setActive: function ( value ) {
										if ( ! this.model.config.checkbox ) {
											/* if the buttons are radio (not checkbox) first we deactivate all of them */
											this.clearActive();
										}

										if ( jQuery.isArray( value ) && this.model.config.checkbox ) {
											this.$( '.tve-btn' ).each( function () {
												this.classList[value.indexOf( this.dataset.value ) !== - 1 ? 'add' : 'remove']( 'active' );
											} );
										} else {
											var $element = this.$el.find( '.tve-btn[data-value="' + value + '"]' );

											if ( $element.length ) {
												$element.addClass( 'active' );
											} else {
												this.$el.find( '.default' ).addClass( 'active' );
											}
										}
									},
									removeActive: function ( value ) {
										this.$el.find( '.tve-btn[data-value="' + value + '"]' ).removeClass( 'active' );
									},
									getValue: function () {
										return this.$( '.tve-btn.active' ).attr( 'data-value' ) || null;
									},
									clearActive: function () {
										this.$el.find( '.tve-btn' ).removeClass( 'active' );
									}
								} );
							},
							"button-panel-group.js": function (exports, module, require) {
								(function ( $ ) {
									var base = require( '../base' );
									module.exports = base.control.extend( {
										template: TVE.tpl( 'controls/button-panel-group' ),
										initialize: function ( attr ) {
											if ( attr.model && attr.model.config ) {
												this.data = attr.model.config;
											} else if ( attr.config ) {
												this.data = attr.config;
											} else {
												this.data = attr;
											}

											if ( ! this.data || ! this.data.buttons ) {
												throw new Error( 'Panel group with no button defined' );
											}
											_.each( this.data.buttons, function ( btn ) {
												if ( ! btn.panel ) {
													throw new Error( 'Missing button panel' );
												}
											} );

											base.control.prototype.initialize.apply( this, arguments );

											this.init_panels();
										},
										/**
										 * Returns the html for the icon of a button
										 *
										 * @param btn
										 * @returns {string}
										 */
										icon: function ( btn ) {
											return TVE.icon( btn.icon, btn.icon_type || 'inline' );
										},
										/**
										 * Initializes the Drop Panel views
										 */
										init_panels: function () {
											this.panels = {};

											_.each( this.data.buttons, function ( btn, key ) {
												btn.panel.on( 'close', _.bind( this.on_close, this ) );
												this.panels[key] = btn.panel;
											}, this );
										},
										on_close: function () {
											this.$( '.tve-btn' ).removeClass( 'active' );
										},
										panel: function ( btn ) {
											if ( typeof btn.getAttribute === 'function' ) {
												return this.panels[btn.getAttribute( 'data-panel' )];
											}

											return this.panels[btn];
										},
										/**
										 * Closes all open panels, triggering the cancel event
										 */
										close_panels: function ( $tabs ) {
											if ( ! $tabs.length ) {
												return;
											}
											var self = this;
											$tabs.each( function () {
												self.panel( this ).onCancel();
											} );
										},
										/**
										 * Opens up and positions a panel tab
										 *
										 * @param e
										 * @param tab
										 */
										tab_click: function ( e, tab ) {
											var control = this.panel( tab );
											tab.classList.toggle( 'active' );
											/* toggle functionality */
											if ( ! tab.classList.contains( 'active' ) ) {
												control.onCancel();
												return false;
											}
											this.close_panels( this.$( tab ).siblings( '.active' ).removeClass( 'active' ) );
											this.trigger( 'open', control, tab.getAttribute('data-panel') );

											control.open( this.applyTo(), tab );

											return false;
										}
									} );
								})( jQuery );
							},
							"checkbox.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/checkbox' ),
									initialize: function () {
										this.render();
									},
									isChecked: function () {
										return this.$el.find( '.tve-checkbox' ).is( ':checked' );
									},
									setChecked: function ( checked ) {
										this.$el.find( '.tve-checkbox' ).prop( 'checked', ! ! checked );

										return this;
									},
									check: function ( $element, dom ) {
										/* Take care of other things before letting the element handle the change */
										this.change( $element, dom );
									},
									disable: function () {
										this.$( '.tve-checkbox' ).prop( 'disabled', true );
										this.$( 'label' ).addClass( 'disabled' );

										return this;
									},
									enable: function () {
										this.$( '.tve-checkbox' ).prop( 'disabled', false );
										this.$( 'label' ).removeClass( 'disabled' );

										return this;
									}
								} );
							},
							"color-picker.js": function (exports, module, require) {
								(function ( $ ) {

									var base = require( '../base' ),
										Input = require( './input' ),
										FavoriteColors = require( '../../libs/favorite-colors' ),
										tinycolor = require( '../../libs/tinycolor' );

									module.exports = base.control.extend( {
										template: TVE.tpl( 'controls/color-picker' ),
										events: {
											'keyup .color-input': 'onColorEnter'
										},
										defaults: {
											output: 'object',
											showGradient: true,
											showInput: true,
											allowEmpty: true,
											showAlpha: true,
											preferredFormat: 'rgb',
											important: false,
											showFavorites: true
										},
										initialize: function ( attr ) {
											this.render();

											if ( ! $.spectrum ) {
												return;
											}

											var options = $.extend( {}, this.defaults, this.$el.data(), this.model.config.options || {} ),
												self = this;

											this.important = this.model.config.important ? '!important' : '';

											this.model.config.label = this.model.config.label || TVE.t.Color;

											this.colorPicker = this.$( '.color-picker' );

											this.$input = this.$( '.color-input' );

											/* extend options with change and input functionality */
											var _change = options.change,
												_move = options.move;

											$.extend( true, options, {
												move: function ( color ) {
													if ( self.favorites ) {
														self.favorites.deselect();
													}
													if ( _move ) {
														_move( color );
													}
													TVE.SKIP_CSS_STATE = true;
													self.onInput( color );
												},
												change: function ( color ) {
													if ( self.favorites ) {
														self.favorites.select( color );
													}
													if ( _change ) {
														return _change( color );
													}

													TVE.SKIP_CSS_STATE = false;
													self.onChange( color );
												},
												appendTo: '#tcb-drop-panels',
												show: _.bind( function () {
													if ( ! options.flat || ! this.$el.parents( '.drop-panel' ).length ) {
														this.$( '.color-picker-input' ).addClass( 'drop-panel-focus' );
														TVE.main.$( '.tve-panel' ).addClass( 'drop-panel-open' );
														TVE.main.scroll_panel_to( this.colorPicker.spectrum( 'container' ) );
													}
													this.favorites.render();
												}, this ),
												hide: options.hide || _.bind( function () {
													if ( ! options.flat && ! this.$el.parents( '.drop-panel' ).length ) {
														this.$( '.color-picker-input' ).removeClass( 'drop-panel-focus' );
														TVE.main.$( '.tve-panel' ).removeClass( 'drop-panel-open' );
													}
												}, this ),
												cancel: function () {
													self.cancel();
												}
											} )
											;
											if ( options.showAlpha ) {
												/* create the alpha control */
												options.alpha_input = new Input( {
													model: {
														config: {
															name: TVE.t.opacity + ':',
															um: '%',
															min: 0,
															max: 100,
															maxlength: 5
														}
													}
												} );
												options.alpha_input.$( '.input-control' ).addClass( 'small' );
												options.alpha_input.input = $.noop;
											}

											/* do not ever show the Palette from spectrum */
											options.showPalette = false;
											if ( options.showFavorites ) {
												options.showSaveButton = true;
												/* Show the favorites colors section */
												this.favorites = new FavoriteColors();
												options.saveFavorite = _.bind( this.favorites.add_color, this.favorites );
												this.favorites.on( 'select', _.bind( function ( color ) {
													/* trigger the change event in spectrum */
													this.colorPicker.spectrum( 'set', color, true );
												}, this ) );
											}

											this.colorPicker.spectrum( options );

											if ( ! options.showInput ) {
												this.$input.hide();
											} else {
												this.$( '.sp-replacer' ).addClass( 'has-input' );
											}

											if ( options.showFavorites ) {
												this.favorites.$el.appendTo( this.colorPicker.spectrum( 'container' ) );
											}

											/* call change when the choose button is clicked */
											this.colorPicker.find( '.sp-choose' ).on( 'click', function ( e ) {
												self.onChange();
											} );


											if ( typeof attr.input === 'function' ) {
												this.input = attr.input;
											}
											if ( typeof attr.change === 'function' ) {
												this.change = attr.change;
											}

											this.options = options;
										},
										/**
										 * This should be overridden
										 */
										input: function ( css ) {
										},
										/**
										 * On color change, when dragging the mouse on the color picker
										 * @param color
										 */
										onInput: function ( color ) {
											TVE.SkipUpdate = true;

											this.$input.val( color );

											this.input( this.getStyle( color ) );
										},
										/**
										 * When exiting the color picker
										 * @param color
										 */
										onChange: function ( color ) {
											TVE.SkipUpdate = false;

											this.$input.val( color );

											this.change( this.getStyle( color ) );
										},
										/**
										 * Set color value on the color picker and the input
										 * @param value
										 * @param {Boolean} [trigger_change]
										 */
										setValue: function ( value, trigger_change ) {
											value = new tinycolor( value );
											if ( value.getAlpha() === 0 ) {
												value = null;
											}
											this.colorPicker.spectrum( 'set', value, trigger_change );

											this.$input.val( value );
										},
										/**
										 * set the current color's alpha
										 *
										 * @param alpha
										 */
										setAlpha: function ( alpha ) {
											var color = this.colorPicker.spectrum( 'get' );
											color.setAlpha( alpha );
											this.setValue( color );
										},
										getStyle: function ( color ) {
											if ( this.options.output === 'object' ) {
												return color;
											}
											return {
												'background-color': color + this.important
											};
										},
										/**
										 * Get color from the color picker
										 * @returns {*}
										 */
										getValue: function () {
											return this.colorPicker.spectrum( 'get' );
										},
										/**
										 * Read background-color from element
										 * @param {*} [$element] Optional, defaults to this.applyTo()
										 */
										read_background: function ( $element ) {
											$element = $element || this.applyTo();
											this.setValue( $element.css( 'background-color' ) || 'transparent' );
										},
										/**
										 * Read css property from the element
										 *
										 * @param {String} css_prop
										 * @param {Object} [$element] Optional, defaults to this.applyTo()
										 */
										read_css: function ( css_prop, $element ) {
											$element = $element || this.applyTo();
											this.setValue( $element.css( css_prop ) || 'transparent' );
										},
										/**
										 * Update the picker when the user submits a color in the input
										 * @param event
										 */
										onColorEnter: function ( event ) {
											if ( event.keyCode === 13 ) {
												TVE.SkipUpdate = true;

												this.colorPicker.spectrum( 'set', event.target.value );

												this.input( this.getValue() );
											}
										},
										change: function ( color ) {
											this.input( color );
										},
										/**
										 * Re-calculate dimensions needed for the spectrum color-picker
										 */
										reflow: function () {
											this.colorPicker.spectrum( 'reflow' );
										},
										/**
										 * Adds new color to the favorites palette
										 */
										save_favorite: function ( color ) {
											this.favorites.add_color( color );

											return false;
										},
										render_favorites: function () {
											this.favorites.render();
										},
										cancel: function () {
										}
									} );
								})( jQuery );
							},
							"corners.js": function (exports, module, require) {
								var base = require( '../base' ),
									input = require( '../controls/input' );

								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/corners' ),
									corners: ['top-left', 'top-right', 'bottom-left', 'bottom-right'],
									initialize: function () {
										var self = this;
										this.render();

										this.BorderRadius = new input( {
											el: this.$el.find( '.tve-corner-value' ),
											model: {
												config: {
													min: 0,
													um: 'PX'
												}
											}
										} );

										this.BorderRadius.update = function () {

											var $element = this.readFrom(),
												radius = $element.css( self.style() );

											this.setValue( parseInt( radius ) );
										};

										this.BorderRadius.input = function ( $element, dom ) {

											var css = {},
												corner = self.current_corner === '' ? 'border-radius' : self.style();

											css[corner] = dom.value + 'px' + ( this.config.important ? ' !important' : '' );
											/**
											 * rounded corners should hide the overflow, so that the inner element receives border radius
											 */
											css.overflow = 'hidden';

											this.applyTo().head_css( css, null, this.config.css_suffix, false, this.config.css_prefix );
										};
									},
									corner: function ( $element, dom ) {
										this.current_corner = dom.getAttribute( 'data-value' );

										/* mark the current corner as active */
										this.$el.find( '.tve-corner' ).removeClass( 'active' );
										dom.className += ' active';

										this.BorderRadius.update();
									},
									/**
									 * Apply specific config on the control. We overwrite this so we can call setConfig on to sub controls.
									 *
									 * @param config
									 * @param to
									 */
									setConfig: function ( config, to, css_suffix ) {

										if ( typeof config !== 'undefined' ) {
											jQuery.extend( true, this.config, config );
										}

										this.BorderRadius.setConfig.apply( this.BorderRadius, arguments );
									},
									/**
									 * update component with css from the element
									 */
									update: function () {
										this.current_corner = '';

										this.$el.find( '.tve-corner' ).removeClass( 'active' ).filter( '.default' ).addClass( 'active' );

										/* update the controls for the selected corner */
										this.BorderRadius.update();
									},
									style: function ( corner ) {
										if ( typeof corner === 'undefined' ) {
											corner = this.current_corner;
										}
										return 'border-' + corner + '-radius';
									},
									input: function () {
									}
								} );
							},
							"countdown": {
								"style.js": function (exports, module, require) {
									/**
									 * Created by Ovidiu on 5/12/2017.
									 */
									module.exports = require( '../style-picker' ).extend( {
										item_template: function () {
											return TVE.tpl( 'controls/countdown/style-picker' );
										},
										update: function ( $element ) {
											var classes = $element.attr( 'class' ).split( ' ' ),
												selected = this.model.config.default;

											for ( var i = 0; i < classes.length; i ++ ) {
												if ( classes[i].substr( 0, 14 ) == 'tve_countdown_' ) {
													selected = classes[i];
													break;
												}
											}

											this.$( '.tve-select-item' ).removeClass( 'active' ).filter( '[data-value=' + selected + ']' ).addClass( 'active' );
											this.model.selected_old = selected;
											this.component.$el.find( '.style-change-input' ).val( this.getLabel( selected ) );
										},
										input: function ( $element ) {
											$element.removeClass( function ( index, className ) {
												return (className.match( /(^|\s)tve_countdown_\S+/g ) || []).join( ' ' );
											} );

											$element.addClass( this.model.selected );

											/**
											 * Trigger Change On EndDate to resize the "Days" container
											 */
											this.component.trigger_change_date();
										},
										cancel: function ( $element ) {
											$element.removeClass( this.model.selected ).addClass( this.model.selected_old );
											this.model.selected = this.model.selected_old;

											/**
											 * Trigger Change On EndDate to resize the "Days" container
											 */
											this.component.trigger_change_date();
										},
										apply: function ( $element ) {
											this.undo_manager_api( $element, this.model )
										},
										/**
										 * Undo Manager API
										 *
										 * @param $element
										 * @param model
										 */
										undo_manager_api: function ( $element, model ) {
											var selected = model.selected,
												selected_old = model.selected_old;

											TVE.UndoManager.add( {
												undo: function () {
													$element.removeClass( selected ).addClass( selected_old );
												},
												redo: function () {
													$element.removeClass( selected_old ).addClass( selected );
												}
											} );
										}
									} );
								}
							},
							"credit": {
								"cards.js": function (exports, module, require) {
									/**
									 * Created by Ovidiu on 4/5/2017.
									 */
									var DropPanel = require( '../drop-panel' );

									module.exports = DropPanel.extend( {
										template: TVE.tpl( 'controls/cards-change' ),
										/**
										 * Renders a drop down item
										 *
										 * @param key
										 * @param value
										 * @returns {*}
										 */
										render_item: function ( key, value ) {
											var tpl = this.item_template();

											return tpl( {key: key, label: value.label ? value.label : value, value: value} );
										},
										/**
										 * Returns the item template
										 */
										item_template: function () {
											return _.template( '<div class="col-xs-6 card-item tcb-truncate"><label class="tcb-checkbox"><input type="checkbox" class="tve-checkbox click" data-fn="clicked" id="<#=value.identifier#>-tcb-card" value="<#=value.identifier#>"/><span><#=value.label#></span></label></div>' );
										},
										/**
										 * Callback function that is triggered when clicking on a card checkbox
										 *
										 * @param $element
										 * @param dom
										 */
										clicked: function ( $element, dom ) {
											var elementCards = $element.attr( 'data-cards' ).split( ',' ),
												elementCardsObj = {};
											if ( dom.checked ) {
												elementCards.push( dom.value );
											} else {
												var indexToRemove = elementCards.indexOf( dom.value );
												if ( indexToRemove > - 1 ) {
													elementCards.splice( indexToRemove, 1 );
												}
											}
											$element.attr( 'data-cards', elementCards );

											_.each( this.renderer.cards, function ( cardName, key ) {
												if ( _.contains( elementCards, key ) ) {
													elementCardsObj[key] = cardName;
												}
											}, this );

											this.model.selected = elementCardsObj;
											this.input( $element, dom );
										},
										input: function ( $element ) {
											this.renderer.set_data( {cards: this.model.selected} ).render_to( $element );
										},
										/**
										 * Reads the cards from the element and sets the drop down checkboxes.
										 *
										 * @returns {{}}
										 */
										read_from_element: function () {
											var cards = this.applyTo().attr( 'data-cards' ),
												cardsArr = cards.split( ',' ),
												elementCards = {};

											_.each( this.renderer.cards, function ( cardName, key ) {
												var checked = false;
												if ( _.contains( cardsArr, key ) ) {
													elementCards[key] = cardName;
													checked = true;
												}
												this.$( '#' + key + '-tcb-card' ).prop( 'checked', checked );
											}, this );
											this.renderer.set_data( {cards: elementCards} );
											return elementCards;
										},
										update: function () {
											var selected = this.read_from_element();
											this.model.selected = selected;

											this.model.selected_old = selected;
										},
										cancel: function ( $element ) {
											this.model.selected = this.model.selected_old;
											this.renderer.set_data( {cards: this.model.selected_old} ).render_to( $element );
											this.renderer.clear_undo_snapshot();

											//Update the dropdown cards checkbox
											this.read_from_element();
										},
										onOpen: function ( $element ) {
											// Updates the card list status on dropdown open.
											this.update();

											this.renderer.take_undo_snapshot( $element );
										},
										apply: function ( $element ) {
											this.renderer.render_to( $element, true );

											this.collection.trigger( 'reset-for-preview' );
										}
									} );
								},
								"style.js": function (exports, module, require) {
									/**
									 * Created by Ovidiu on 4/4/2017.
									 */
									module.exports = require( '../style-picker' ).extend( {
										read_from_element: function () {
											var style = this.applyTo().attr( 'data-style' );
											this.renderer.set_data( {style: style} );
											return style;
										},
										item_template: function () {
											return _.template( '<div class="col-xs-12 credit-item"><div class="tve-select-item click" data-fn="select" data-value="<#=key #>"><#=value.html#></div></div>' );
										},
										input: function ( $element ) {
											this.renderer.set_data( {style: this.model.selected} ).render_to( $element );
										},
										cancel: function ( $element ) {
											this.model.selected = this.model.selected_old;
											this.renderer.set_data( {style: this.model.selected_old} ).render_to( $element );
											this.renderer.clear_undo_snapshot();
										},
										onOpen: function ( $element ) {
											this.renderer.take_undo_snapshot( $element );
										},
										apply: function ( $element ) {
											this.renderer.render_to( $element, true );

											this.collection.trigger( 'reset-for-preview' );
										}
									} );
								}
							},
							"custom-menu": {
								"menu-direction.js": function (exports, module, require) {
									var base = require( '../../base' );

									module.exports = base.control.extend( {
										template: TVE.tpl( 'controls/custom-menu/menu-display' ),
										update: function () {
											this.$( 'select' ).val( this.component.model.get( 'dir' ) );
										},
										changeDirection: function ( $element, dom ) {
											var val = dom.value;
											this.component.changeConfig( 'dir', val, true );
											if ( val == 'tve_vertical' ) {
												this.component.controls['ChildBackground'].$el.hide();
												this.component.controls['HoverChildBackground'].$el.hide();
											} else {
												this.component.controls['ChildBackground'].$el.show();
												this.component.controls['HoverChildBackground'].$el.show();
											}
										}
									} );
								},
								"select-menu.js": function (exports, module, require) {
									var base = require( '../../base' );

									module.exports = base.control.extend( {
										template: TVE.tpl( 'controls/custom-menu/select-menu' ),
										update: function () {
											this.$( 'select' ).val( this.component.model.get( 'menu_id' ) );
										},
										changeMenu: function ( $element, dom ) {
											this.component.changeConfig( 'menu_id', dom.value, true );
										}
									} );
								}
							},
							"date-picker.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 5/15/2017.
								 */
								var base = require( '../base' );
								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/date-picker' ),
									initialize: function () {
										this.render();

										this.$el.find( '.tve-input-control' ).datepicker( {
											dateFormat: 'dd-mm-yy',
											beforeShow: function ( input, inst ) {
												jQuery( '#ui-datepicker-div' ).addClass( 'tve-datepicker' );
											}
										} );

										/* Hide DatePicker on clear focus event */
										TVE.main.on( 'clear_focus', _.bind( function () {
											this.$el.find( '.tve-input-control' ).datepicker( 'hide' );
										}, this ) );
									},
									changed: function () {
										this.input( this.applyTo(), this.$el.find( '.tve-input-control' ).val() );
									},
									/**
									 * Triggers click on datepicker input from datepicker icon
									 */
									date_trigger_click: function () {
										this.$el.find( '.tve-input-control' ).datepicker( 'show' );
									},
									setValue: function ( year, month, day ) {
										this.$el.find( '.tve-input-control' ).datepicker( 'setDate', new Date( year, month, day ) );
									}
								} );
							},
							"decoration": {
								"decoration.js": function (exports, module, require) {
									var Slanted = require( './slanted' ),
										Pointer = require( './pointer' ),
										Divider = require( './divider' ),
										base = require( '../../base' );

									module.exports = base.control.extend( {
										template: TVE.tpl( 'controls/decoration/decoration' ),
										controls: {},
										side: 'bottom',
										after_initialize: function () {
											this.controls = {
												slanted: new Slanted( {
													el: this.$( '.tve-slanted-control' ),
													model: {
														config: {}
													}
												} ),
												pointer: new Pointer( {
													el: this.$( '.tve-pointer-control' ),
													model: {
														config: {}
													}
												} ),
												divider: new Divider( {
													el: this.$( '.tve-divider-control' ),
													model: {
														config: {}
													}
												} )
											};
											var self = this;
											this.controls.none = {};
											this.controls.none.update = function () {
												self.removeClip();
											};
											this.$( '.tve-sub-control' ).hide();
											this.$( '.decoration-type select' ).val( 'none' );
										},

										update: function ( $element ) {
											this.$element = $element;
											this.setSide( this.side, true );
										},

										removeClip: function () {
											var clipPath = this.$element.find( '.clip-path-' + this.side );

											if ( clipPath.length ) {
												clipPath.find( 'polygon' ).attr( 'points', '0 0, 0 1, 1 1, 1 0' );
											}
										},

										/**
										 * Choose decoration type
										 */
										chooseType: function ( $element, dom ) {
											this.checkSVG();
											var before = TVE.renderers.base.read_element_props( $element );

											this.$( '.tve-sub-control' ).hide();
											this.$( '.tve-' + dom.value + '-control' ).show();
											$element.find( '.clip-path-' + this.side ).attr( 'decoration-type', dom.value );
											this.controls[dom.value].update();

											if ( dom.ignore_change !== true ) {
												var after = TVE.renderers.base.read_element_props( $element );
												TVE.UndoManager.add( {
													undo: function () {
														$element.html( before.html );
													},
													redo: function () {
														$element.html( after.html );
													}
												} );
											}
										},

										/**
										 * Check if SVG exists and if it has a clip path
										 */
										checkSVG: function () {
											var type = this.$( '.tve-select' ).val() != 'none';
											if ( ! this.$element.find( '.tve-decoration-svg' ).length && type ) {
												this.addSVG();
											}

											if ( ! this.$element.find( '.clip-path-' + this.side ).length && type ) {
												this.addClipPath();
											}
										},

										/**
										 * Add Clip Path
										 */
										addClipPath: function () {
											var randomId = this.$element.attr( 'data-clip-id' );
											if ( ! randomId ) {
												randomId = this.generateID();
												this.setClipID( randomId );
											}
											var clipPathId = this.buildClipID( randomId ),
												$lastClipPath = this.$element.find( '.tve-decoration-svg defs ' ).find( '.decoration-clip:not([clip-path])' );
											this.$element.find( '.tve-decoration-svg defs' ).append( this.buildClipPath( clipPathId ) );
											$lastClipPath.attr( 'clip-path', ('url(#' + clipPathId + ')') );
										},

										/**
										 * Build Clip Path
										 */
										buildClipPath: function ( clipPathId ) {
											var _svgNS = 'http://www.w3.org/2000/svg',
												clippath = document.createElementNS( _svgNS, 'clipPath' ),
												polygon = document.createElementNS( _svgNS, 'polygon' );

											clippath.setAttributeNS( null, 'id', clipPathId );
											clippath.setAttributeNS( null, 'class', ('decoration-clip clip-path-' + this.side) );
											clippath.setAttributeNS( null, 'clipPathUnits', 'objectBoundingBox' );

											polygon.setAttributeNS( null, 'points', '0 0, 0 1, 1 1, 1 0' );
											clippath.appendChild( polygon );
											return clippath;
										},

										/**
										 * Build Clip Path ID
										 */
										buildClipID: function ( random ) {
											return 'clip-' + this.side + '-' + random;
										},

										/**
										 * Set clip path IDs and css on the background
										 */
										setClipID: function ( randomId ) {
											this.applyTo().head_css( {'clip-path': 'url(#' + this.buildClipID( randomId ) + ')'} );
											this.$element.attr( 'data-clip-id', randomId );
										},

										/**
										 * Generate random ID for clip path elements
										 */
										generateID: function () {
											return Math.random().toString( 16 ).slice( 2 );
										},

										/**
										 * Add a section SVG thaat contains the clip paths for decorations
										 */
										addSVG: function () {
											this.$element.append( '<svg width="0" height="0" class="tve-decoration-svg"><defs></defs></svg>' );
										},

										/**
										 * When a decoration side is selected
										 * @param $element
										 * @param dom
										 */
										decorationSide: function ( $element, dom ) {
											/* save the side that was selected */
											this.setSide( dom.getAttribute( 'data-value' ) );
											this.$el.find( '.tve-decoration-side' ).removeClass( 'active' );
											dom.className += ' active';
											this.setSelector( $element, true );

										},

										setSelector: function ( $element, ignore ) {
											/* mark the current side as active */
											var type = $element.find( '.clip-path-' + this.side ).attr( 'decoration-type' );
											if ( ! type ) {
												type = 'none';
											}
											this.$( '.tve-select' ).val( type );
											this.chooseType( $element, {value: type, ignore_change: ignore} );
										},

										/**
										 * Set side on all sub-controls at once
										 */
										setSide: function ( side, ignore_svg ) {
											this.side = side;

											if ( ! ignore_svg ) {
												this.checkSVG();
											}

											this.controls.slanted.setSide( side );
											this.controls.pointer.setSide( side );
											this.controls.divider.setSide( side );
											this.setSelector( this.applyTo(), true );

										}
									} );
								},
								"divider.js": function (exports, module, require) {
									var base = require( '../../base' ),
										Slider = require( '../slider' );

									module.exports = base.control.extend( {
										order: ['top', 'left', 'bottom', 'right'],
										controls: {},
										defaultPoints: '0 0, 0 1, 1 1, 1 0',
										style: 'zigzag',
										side: 'bottom',
										sizes: {
											top: {
												width: null,
												height: null
											},
											left: {
												width: null,
												height: null
											},
											bottom: {
												width: null,
												height: null
											},
											right: {
												width: null,
												height: null
											}
										},
										template: TVE.tpl( 'controls/decoration/divider' ),

										after_initialize: function () {
											var self = this;
											this.controls['WidthSlider'] = new Slider( {
												el: this.$el.find( '.tve-divider-width' ),
												model: {
													config: {
														default: '10',
														min: '0',
														max: '100',
														label: 'Width',
														um: ['%']
													}
												}
											} );

											this.controls['HeightSlider'] = new Slider( {
												el: this.$el.find( '.tve-divider-height' ),
												model: {
													config: {
														default: '10',
														min: '0',
														max: '100',
														label: 'Height',
														um: ['%']
													}
												}
											} );

											this.controls['WidthSlider'].input = this.controls['HeightSlider'].input = function ( $element, dom ) {
												var previousSide, nextSide, oppositeSide, rightOffset, leftOffset, oppositeOffset,
													sideIndex = self.order.indexOf( self.side );


												previousSide = sideIndex - 1 < 0 ? 'right' : self.order[sideIndex - 1];
												nextSide = sideIndex + 1 > 3 ? 'top' : self.order[sideIndex + 1];
												oppositeSide = sideIndex + 2 > 3 ? self.order[sideIndex - 2] : self.order[sideIndex + 2];

												leftOffset = $element.find( '.clip-path-' + previousSide ).attr( 'pointer-height' ) / 100;
												rightOffset = $element.find( '.clip-path-' + nextSide ).attr( 'pointer-height' ) / 100;
												oppositeOffset = $element.find( '.clip-path-' + oppositeSide ).attr( 'pointer-height' ) / 100;


												leftOffset = leftOffset ? Number( leftOffset ) : 0;
												rightOffset = rightOffset ? Number( rightOffset ) : 0;
												oppositeOffset = oppositeOffset ? Number( oppositeOffset ) : 0;

												self.sizes[self.side].width = Number( self.controls['WidthSlider'].value( false ) );
												self.sizes[self.side].height = Number( self.controls['HeightSlider'].value( false ) );

												$element.find( '.clip-path-' + self.side ).attr( 'pointer-width', self.sizes[self.side].width ).attr( 'pointer-height', self.sizes[self.side].height ).attr( 'style', self.style );
												$element.find( '.clip-path-' + self.side + ' ellipse' ).remove();
												if ( ! self.sizes[self.side].width || ! self.sizes[self.side].height ) {
													$element.find( '.clip-path-'+self.side+ ' polygon' ).attr( 'points', self.defaultPoints );
													return;
												}
												self[self.style][self.side]( $element, self, leftOffset, rightOffset );

												if ( $element.find( '.clip-path-' + previousSide ).attr( 'style' ) == self.style && leftOffset ) {
													$element.find( '.clip-path-' + previousSide + ' ellipse' ).remove();
													self[self.style][previousSide]( $element, self, oppositeOffset, self.controls['HeightSlider'].value( false ) / 100 );
												}
												if ( $element.find( '.clip-path-' + nextSide ).attr( 'style' ) == self.style && rightOffset ) {
													$element.find( '.clip-path-' + nextSide + ' ellipse' ).remove();
													self[self.style][nextSide]( $element, self, self.controls['HeightSlider'].value( false ) / 100, oppositeOffset );
												}
											}
										},

										/**
										 * Curves decoration functions for each side
										 */
										curves: {
											bottom: function ( $element, self, leftOffset, rightOffset ) {
												var delta = self.sizes.bottom.height,
													width = self.sizes.bottom.width,
													rx, ry, x, y, ellipse,
													freq = width ? Math.round( 100 / width ) : 100;

												rx = ( ( 1 - (leftOffset + rightOffset) ) / (2 * freq)).toFixed( 6 );

												y = 1 - (delta / 100);
												ry = delta / 100;
												for ( var i = 0; i < freq; i ++ ) {
													x = (2 * i + 1) * rx + leftOffset;
													$element.find( '.clip-path-bottom' ).append( self.curves.buildEllipse( x, y, rx, ry ) );
												}

												$element.find( '.clip-path-bottom polygon' ).attr( 'points', self.curves.buildBindingBox( 0, 0, 1, (1 - ry) ) );

											},
											top: function ( $element, self, leftOffset, rightOffset ) {
												var delta = self.sizes.top.height,
													width = self.sizes.top.width,
													rx, ry, x, y, ellipse,
													freq = width ? Math.round( 100 / width ) : 100;

												rx = ( ( 1 - (leftOffset + rightOffset) ) / (2 * freq)).toFixed( 6 );

												y = delta / 100;
												ry = delta / 100;
												for ( var i = 0; i < freq; i ++ ) {
													x = (2 * i + 1) * rx + rightOffset;
													$element.find( '.clip-path-top' ).append( self.curves.buildEllipse( x, y, rx, ry ) );
												}

												$element.find( '.clip-path-top polygon' ).attr( 'points', self.curves.buildBindingBox( 0, ry, 1, 1 ) );

											},
											left: function ( $element, self, leftOffset, rightOffset ) {
												var delta = self.sizes.left.height,
													width = self.sizes.left.width,
													rx, ry, x, y, ellipse,
													freq = width ? Math.round( 100 / width ) : 100;

												ry = ( ( 1 - (leftOffset + rightOffset) ) / (2 * freq)).toFixed( 6 );

												x = delta / 100;
												rx = delta / 100;
												for ( var i = 0; i < freq; i ++ ) {
													y = (2 * i + 1) * ry + leftOffset;
													$element.find( '.clip-path-left' ).append( self.curves.buildEllipse( x, y, rx, ry ) );
												}

												$element.find( '.clip-path-left polygon' ).attr( 'points', self.curves.buildBindingBox( rx, 0, 1, 1 ) );

											},
											right: function ( $element, self, leftOffset, rightOffset ) {
												var delta = self.sizes.right.height,
													width = self.sizes.right.width,
													rx, ry, x, y, ellipse,
													freq = width ? Math.round( 100 / width ) : 100;

												ry = ( ( 1 - (leftOffset + rightOffset) ) / (2 * freq)).toFixed( 6 );

												x = 1 - delta / 100;
												rx = delta / 100;
												for ( var i = 0; i < freq; i ++ ) {
													y = (2 * i + 1) * ry + rightOffset;
													$element.find( '.clip-path-right' ).append( self.curves.buildEllipse( x, y, rx, ry ) );
												}

												$element.find( '.clip-path-right polygon' ).attr( 'points', self.curves.buildBindingBox( 0, 0, (1 - rx), 1 ) );

											},

											/**
											 * Build each individual curve
											 */
											buildEllipse: function ( x, y, rx, ry ) {
												var _svgNS = 'http://www.w3.org/2000/svg',
													ellipse = document.createElementNS( _svgNS, 'ellipse' );

												ellipse.setAttributeNS( null, 'cx', x );
												ellipse.setAttributeNS( null, 'cy', y );
												ellipse.setAttributeNS( null, 'rx', rx );
												ellipse.setAttributeNS( null, 'ry', ry );

												return ellipse;
											},

											/**
											 * Build binding box
											 */
											buildBindingBox: function ( x1, y1, x2, y2 ) {
												return x1 + ' ' + y1 + ', ' + x1 + ' ' + y2 + ', ' + x2 + ' ' + y2 + ', ' + x2 + ' ' + y1;
											}
										},

										/**
										 * Zigzag decoration functions for each side
										 */
										zigzag: {
											bottom: function ( $element, self, leftOffset, rightOffset ) {
												var delta = self.sizes.bottom.height,
													width = self.sizes.bottom.width,
													x, y,
													right_extra = '',
													left_extra = '',
													coords = '',
													freq = width ? Math.round( 100 / width ) : 100,
													ramp = ( ( 1 - (leftOffset + rightOffset) ) / freq).toFixed( 6 );

												for ( var i = 0; i < (freq * 2) + 1; i ++ ) {
													if ( i % 2 ) {
														y = 1;
													} else {
														y = 1 - (delta / 100);
													}
													x = Number( (ramp / 2).toFixed( 6 ) ) * i + leftOffset;

													coords += x + ' ' + y + ', ';
												}
												if ( rightOffset ) {
													right_extra = ' ' + (1 - rightOffset ) + '  ' + (1 - (delta / 100)) + ', 1 ' + (1 - (delta / 100)) + ', 1 0';
												} else {
													right_extra = ' 1 0';
												}

												if ( leftOffset ) {
													left_extra = '0 0, 0 ' + (1 - (delta / 100)) + ', ' + leftOffset + ' ' + (1 - (delta / 100) + ', ');
												} else {
													left_extra = '0 0, ';
												}
												if ( Number( width ) === 0 ) {
													$element.find( '.clip-path-bottom polygon' ).attr( 'points', self.defaultPoints );
												} else {
													$element.find( '.clip-path-bottom polygon' ).attr( 'points', left_extra + coords + right_extra );
												}
											},
											top: function ( $element, self, leftOffset, rightOffset ) {
												var delta = self.sizes.top.height,
													width = self.sizes.top.width,
													x, y,
													right_extra = '',
													left_extra = '',
													coords = '',
													freq = width ? Math.round( 100 / width ) : 100,
													ramp = ( ( 1 - (leftOffset + rightOffset) ) / freq).toFixed( 6 );
												for ( var i = 0; i < (freq * 2) + 1; i ++ ) {
													if ( i % 2 ) {
														y = 0;
													} else {
														y = 0 + (delta / 100);
													}

													x = 1 - (Number( (ramp / 2).toFixed( 6 ) ) * i + leftOffset);
													var separator = (i + 2) > ((freq * 2) + 1) ? '' : ', ';
													coords += x + ' ' + y + separator;
												}

												if ( rightOffset ) {
													right_extra = ', ' + rightOffset + '  ' + (delta / 100) + ', 0 ' + (delta / 100);
												} else {
													right_extra = ', 0 0';
												}

												if ( leftOffset ) {
													left_extra = '0 1, 1 1, 1 ' + (delta / 100) + ', ' + (1 - leftOffset) + ' ' + (delta / 100) + ', ';
												} else {
													left_extra = '0 1, 1 1,';
												}

												if ( Number( width ) === 0 ) {
													$element.find( '.clip-path-top polygon' ).attr( 'points', self.defaultPoints );
												} else {
													$element.find( '.clip-path-top polygon' ).attr( 'points', left_extra + coords + right_extra );
												}
											},
											left: function ( $element, self, leftOffset, rightOffset ) {
												var delta = self.sizes.left.height,
													width = self.sizes.left.width,
													x, y,
													coords = '',
													freq = width ? Math.round( 100 / width ) : 100,
													ramp = ( ( 1 - (leftOffset + rightOffset) ) / freq).toFixed( 6 );

												for ( var i = 0; i < (freq * 2) + 1; i ++ ) {
													if ( i % 2 ) {
														x = 0;
													} else {
														x = delta / 100;
													}
													y = Number( (ramp / 2).toFixed( 6 ) ) * i + leftOffset;
													var separator = (i + 2) > ((freq * 2) + 1) ? '' : ', ';
													coords += x + ' ' + y + separator;
												}
												if ( Number( width ) === 0 ) {
													$element.find( '.clip-path-left polygon' ).attr( 'points', self.defaultPoints );
												} else {
													$element.find( '.clip-path-left polygon' ).attr( 'points', (delta / 100) + ' 0, ' + (delta / 100) + ' ' + leftOffset + ', ' + coords + ', 0 1, 1 1, 1 0' );
												}
											},
											right: function ( $element, self, leftOffset, rightOffset ) {
												var delta = self.sizes.right.height,
													width = self.sizes.right.width,
													x, y,
													coords = '',
													freq = width ? Math.round( 100 / width ) : 100,
													ramp = ( ( 1 - (leftOffset + rightOffset) ) / freq).toFixed( 6 );

												for ( var i = 0; i < (freq * 2) + 1; i ++ ) {
													if ( i % 2 ) {
														x = 1;
													} else {
														x = 1 - delta / 100;
													}
													y = 1 - (Number( (ramp / 2).toFixed( 6 ) ) * i + leftOffset);
													var separator = (i + 2) > ((freq * 2) + 1) ? '' : ', ';
													coords += x + ' ' + y + separator;
												}
												if ( Number( width ) === 0 ) {
													$element.find( '.clip-path-right polygon' ).attr( 'points', self.defaultPoints );
												} else {
													$element.find( '.clip-path-right polygon' ).attr( 'points', '0 0, 0 1,' + (1 - delta / 100) + ' 1,' + (1 - delta / 100) + ' ' + (1 - leftOffset) + ', ' + coords + ', ' + (1 - delta / 100) + ' ' + rightOffset + ', ' + (1 - delta / 100) + ' 0' );
												}
											}

										},

										update: function () {
											var $element = this.applyTo(),
												style = $element.find( '.clip-path-' + this.side ).attr( 'style' ),
												height = $element.find( '.clip-path-' + this.side ).attr( 'pointer-height' ),
												width = $element.find( '.clip-path-' + this.side ).attr( 'pointer-width' );

											if ( style ) {
												this.style = style;
											}
											if ( $element.find( '.clip-path-' + this.side ).attr( 'decoration-type' ) == 'divider' ) {
												this.controls['WidthSlider'].setValue( width ? width : 5 );
												this.controls['HeightSlider'].setValue( height ? height : 5, true );
											}
											this.$( '.btn-inline.active' ).removeClass( 'active' );
											this.$( '.tve-divider-' + this.style ).addClass( 'active' );
										},

										/**
										 * Set side
										 */
										setSide: function ( side ) {
											this.side = side;

											this.update();
										},

										/**
										 * Set divider style
										 */
										setStyle: function ( e, btn ) {
											if ( btn.className.indexOf( 'active' ) === - 1 ) {
												this.$( '.btn-inline.active' ).removeClass( 'active' );
												btn.classList.add( 'active' );
												this.style = btn.getAttribute( 'data-style' );
												var $element = this.applyTo(),
													style = $element.find( '.clip-path-' + this.side ).attr( 'style', this.style );
											}
											this.update();
										}
									} );
								},
								"pointer.js": function (exports, module, require) {
									var base = require( '../../base' ),
										Slider = require( '../slider' );

									module.exports = base.control.extend( {
										order: ['top', 'left', 'bottom', 'right'],
										pointerOrder: ['first', 'peak', 'last'],
										controls: {},
										defaultPoints: '0 0, 0 1, 1 1, 1 0',
										template: TVE.tpl( 'controls/decoration/pointer' ),

										after_initialize: function () {
											var self = this;
											this.controls['WidthSlider'] = new Slider( {
												el: this.$el.find( '.tve-pointer-width' ),
												model: {
													config: {
														default: '5',
														min: '0',
														max: '90',
														label: 'Width',
														um: ['%']
													}
												}
											} );

											this.controls['HeightSlider'] = new Slider( {
												el: this.$el.find( '.tve-pointer-height' ),
												model: {
													config: {
														default: '5',
														min: '0',
														max: '90',
														label: 'Height',
														um: ['%']
													}
												}
											} );

											this.controls['WidthSlider'].input = this.controls['HeightSlider'].input = function ( $element, dom ) {
												$element.find( '.clip-path-' + self.side + ' ellipse' ).remove();
												switch ( self.side ) {
													case 'bottom':
														self.changeBottom( $element );
														break;
													case 'right':
														self.changeRight( $element );
														break;
													case 'top':
														self.changeTop( $element );
														break;
													case 'left':
														self.changeLeft( $element );
														break;
													default:
												}

											}
										},

										setSide: function ( side ) {
											this.side = side;
											this.update();
										},

										/**
										 * Change function for each side
										 */
										changeBottom: function ( $element ) {
											var width = this.controls['WidthSlider'].value( false ) / 100,
												height = this.controls['HeightSlider'].value( false ) / 100,
												defaultCoords = this.processPath( this.defaultPoints ),
												pointerCoords = {
													first: {},
													peak: {},
													last: {}
												};

											var generalYCoord = defaultCoords['left'].y - height;

											defaultCoords['left'].y = defaultCoords['bottom'].y = generalYCoord;

											pointerCoords['first'].y = pointerCoords['last'].y = generalYCoord;
											pointerCoords['first'].x = (1 - width ) / 2;
											pointerCoords['last'].x = (1 - width ) / 2 + width;

											pointerCoords['peak'].y = 1;
											pointerCoords['peak'].x = 1 / 2;

											$element.find( '.clip-path-' + this.side ).attr( 'pointer-width', width * 100 ).attr( 'pointer-height', height * 100 ).attr( 'style', '' );
											$element.find( '.clip-path-' + this.side + ' polygon' ).attr( 'points', this.rebuildPath( defaultCoords, pointerCoords ) );
										},

										changeRight: function ( $element ) {
											var width = this.controls['WidthSlider'].value( false ) / 100,
												height = this.controls['HeightSlider'].value( false ) / 100,
												defaultCoords = this.processPath( this.defaultPoints ),
												pointerCoords = {
													first: {},
													peak: {},
													last: {}
												};

											var generalXCoord = defaultCoords['bottom'].x - height;

											defaultCoords['bottom'].x = defaultCoords['right'].x = generalXCoord;

											pointerCoords['first'].x = pointerCoords['last'].x = generalXCoord;
											pointerCoords['last'].y = (1 - width ) / 2;
											pointerCoords['first'].y = (1 - width ) / 2 + width;

											pointerCoords['peak'].x = 1;
											pointerCoords['peak'].y = 1 / 2;

											$element.find( '.clip-path-' + this.side ).attr( 'pointer-width', width * 100 ).attr( 'pointer-height', height * 100 );
											$element.find( '.clip-path-' + this.side + ' polygon' ).attr( 'points', this.rebuildPath( defaultCoords, pointerCoords ) );
										},

										changeTop: function ( $element ) {
											var width = this.controls['WidthSlider'].value( false ) / 100,
												height = this.controls['HeightSlider'].value( false ) / 100,
												defaultCoords = this.processPath( this.defaultPoints ),
												pointerCoords = {
													first: {},
													peak: {},
													last: {}
												};

											var generalYCoord = defaultCoords['right'].y + height;

											defaultCoords['top'].y = defaultCoords['right'].y = generalYCoord;

											pointerCoords['first'].y = pointerCoords['last'].y = generalYCoord;
											pointerCoords['last'].x = (1 - width ) / 2;
											pointerCoords['first'].x = (1 - width ) / 2 + width;

											pointerCoords['peak'].y = 0;
											pointerCoords['peak'].x = 1 / 2;

											$element.find( '.clip-path-' + this.side ).attr( 'pointer-width', width * 100 ).attr( 'pointer-height', height * 100 );
											$element.find( '.clip-path-' + this.side + ' polygon' ).attr( 'points', this.rebuildPath( defaultCoords, pointerCoords ) );
										},

										changeLeft: function ( $element ) {
											var width = this.controls['WidthSlider'].value( false ) / 100,
												height = this.controls['HeightSlider'].value( false ) / 100,
												defaultCoords = this.processPath( this.defaultPoints ),
												pointerCoords = {
													first: {},
													peak: {},
													last: {}
												};

											var generalXCoord = defaultCoords['top'].x + height;

											defaultCoords['top'].x = defaultCoords['left'].x = generalXCoord;

											pointerCoords['first'].x = pointerCoords['last'].x = generalXCoord;
											pointerCoords['first'].y = (1 - width ) / 2;
											pointerCoords['last'].y = (1 - width ) / 2 + width;

											pointerCoords['peak'].x = 0;
											pointerCoords['peak'].y = 1 / 2;

											$element.find( '.clip-path-' + this.side ).attr( 'pointer-width', width * 100 ).attr( 'pointer-height', height * 100 );
											$element.find( '.clip-path-' + this.side + ' polygon' ).attr( 'points', this.rebuildPath( defaultCoords, pointerCoords ) );
										},

										/**
										 * Process clip path points out of coords
										 */
										processPath: function ( path ) {
											var array = path.split( ', ' ),
												coords = [],
												coord = [],
												index = 0,
												self = this;
											array.forEach( function ( entry ) {
												coord = entry.split( ' ' );
												coords[self.order[index]] = {x: Number( coord[0] ), y: Number( coord[1] )};
												index ++;
											} );
											return coords;
										},

										update: function () {
											var $element = this.applyTo(),
												height = $element.find( '.clip-path-' + this.side ).attr( 'pointer-height' ),
												width = $element.find( '.clip-path-' + this.side ).attr( 'pointer-width' );
											if ( $element.find( '.clip-path-' + this.side ).attr( 'decoration-type' ) == 'pointer' ) {
												this.controls['WidthSlider'].setValue( width ? width : 5 );
												this.controls['HeightSlider'].setValue( height ? height : 5, true );
											}

										},

										/**
										 * Rebuild clip path points out of coords
										 */
										rebuildPath: function ( coords, pointerCoords ) {
											var path = [],
												self = this;
											this.order.forEach( function ( entry, index ) {

												if ( index == (self.order.indexOf( self.side ) ) ) {
													self.pointerOrder.forEach( function ( entry, index ) {
														if ( typeof pointerCoords[entry].x !== 'undefined' ) {
															path.push( pointerCoords[entry].x + ' ' + pointerCoords[entry].y );
														}
													} )
												}
												if ( typeof coords[entry].x !== 'undefined' ) {
													path.push( coords[entry].x + ' ' + coords[entry].y );
												}
											} );

											return path.join( ', ' );
										}
									} );
								},
								"slanted.js": function (exports, module, require) {
									var base = require( '../../base' ),
										Checkbox = require( '../checkbox' ),
										Slider = require( '../slider' );

									module.exports = base.control.extend( {
										order: ['top', 'left', 'bottom', 'right'],
										controls: {},
										defaultPoints: '0 0, 0 1, 1 1, 1 0',
										template: TVE.tpl( 'controls/decoration/slanted' ),
										inverted: false,

										after_initialize: function () {
											var self = this;

											this.controls['InvertedDecoration'] = new Checkbox( {
												el: this.$el.find( '.tve-inverted-angle' ),
												model: {
													config: {
														label: TVE.t.ChangeDirection
													}
												}
											} );

											this.controls['InvertedDecoration'].change = function ( $element, dom ) {
												self.inverted = dom.checked;
												$element.find( '.clip-path-' + self.side ).attr( 'data-inverted', dom.checked );
												dom.value = $element.find( '.clip-path-' + self.side ).attr( 'slanted-angle' )
												self.controls['AngleSlider'].input( $element, dom );
											};

											this.controls['AngleSlider'] = new Slider( {
												el: this.$el.find( '.tve-slanted-angle' ),
												model: {
													config: {
														default: '5',
														min: '0',
														max: '90',
														label: 'Angle',
														um: ['deg']
													}
												}
											} );
											this.controls['AngleSlider'].input = function ( $element, dom ) {
												var pathString = self.defaultPoints,
													coords = self.processPath( pathString ),
													angle = Number( dom.value );
												$element.find( '.clip-path-' + self.side + ' ellipse' ).remove();
												switch ( self.side ) {
													case 'bottom':
									//
														if ( angle <= 0 ) {
															coords[self.next_side].x = 1;
															coords[self.next_side].y = 0;
															coords[self.side].x = 1;
															coords[self.side].y = 1;
														} else {
															if ( self.inverted ) {
																coords[self.prev_side].x = 0;
																coords[self.prev_side].y = (1 - Math.tan( angle * Math.PI / 180 )).toFixed( 4 );
																coords[self.side].x = 1;
																coords[self.side].y = 1;
															} else {
																coords[self.side].x = Math.tan( (90 - angle) * Math.PI / 180 ).toFixed( 4 );
																coords[self.side].y = 0;
																coords[self.next_side].x = 1;
																coords[self.next_side].y = 0;
															}
														}

														break;
													case 'right':
														if ( angle >= 90 ) {
															coords[self.next_side].x = 0;
															coords[self.next_side].y = 1;
															coords[self.side].x = 0;
															coords[self.side].y = 1;
														} else {
															if ( self.inverted ) {
																coords[self.prev_side].x = (1 - Math.tan( angle * Math.PI / 180 )).toFixed( 4 );
																coords[self.prev_side].y = 1;
																coords[self.side].x = 1;
																coords[self.side].y = 0;
															} else {
																coords[self.side].x = (1 - Math.tan( angle * Math.PI / 180 )).toFixed( 4 );
																coords[self.side].y = 0;
																coords[self.next_side].x = 0;
																coords[self.next_side].y = 0;
															}
														}

														break;
													case 'top':
														if ( angle >= 90 ) {
															coords[self.next_side].x = 1;
															coords[self.next_side].y = 1;
															coords[self.side].x = 1;
															coords[self.side].y = 1;
														} else {
															if ( self.inverted ) {
																coords[self.prev_side].x = 1;
																coords[self.prev_side].y = Math.tan( angle * Math.PI / 180 ).toFixed( 4 );
																coords[self.side].x = 0;
																coords[self.side].y = 0;
															} else {
																coords[self.side].x = 0;
																coords[self.side].y = Math.tan( angle * Math.PI / 180 ).toFixed( 4 );
																coords[self.next_side].x = 0;
																coords[self.next_side].y = 1;
															}
														}
														break;
													case 'left':
														if ( angle >= 90 ) {
															coords[self.next_side].x = 0;
															coords[self.next_side].y = 0;
															coords[self.side].x = 0;
															coords[self.side].y = 0;
														} else {
															if ( self.inverted ) {
																coords[self.prev_side].x =  Math.tan( angle * Math.PI / 180 ).toFixed( 4 );
																coords[self.prev_side].y = 0;
																coords[self.side].x = 0;
																coords[self.side].y = 1;
															} else {
																coords[self.side].x = Math.tan( angle * Math.PI / 180 ).toFixed( 4 );
																coords[self.side].y = 1;
																coords[self.next_side].x = 1;
																coords[self.next_side].y = 1;
															}
														}

														break;
												}

												$element.find( '.clip-path-' + self.side ).attr( 'slanted-angle', angle ).attr( 'style', '' );
												$element.find( '.clip-path-' + self.side + ' polygon' ).attr( 'points', self.rebuildPath( coords ) );
											};
										},

										/**
										 * Set side
										 */
										setSide: function ( side ) {
											this.side = side;
											var order_index = this.order.indexOf( this.side );

											this.next_side = this.order[order_index + 1];
											if ( order_index == this.order.length - 1 ) {
												this.next_side = this.order[0];
											}

											this.prev_side = this.order[order_index - 1];
											if ( order_index == 0 ) {
												this.prev_side = this.order[this.order.length - 1];
											}
										},

										update: function () {
											this.$element = this.applyTo();
											var angle = this.$element.find( '.clip-path-' + this.side ).attr( 'slanted-angle' );
											this.controls['AngleSlider'].setValue( angle ? angle : 5, true );
											this.inverted = this.$element.find( '.clip-path-' + this.side ).attr( 'data-inverted' );
											this.controls['InvertedDecoration'].setChecked( this.inverted );
										},

										/**
										 * Rebuild clip path points out of coords
										 */
										rebuildPath: function ( coords ) {
											var path = [];
											this.order.forEach( function ( entry ) {
												if ( typeof coords[entry].x !== 'undefined' ) {
													path.push( coords[entry].x + ' ' + coords[entry].y );
												}
											} );
											return path.join( ', ' );
										},

										/**
										 * Process clip path points to coords
										 */
										processPath: function ( path ) {
											var array = path.split( ', ' ),
												coords = [],
												coord = [],
												index = 0,
												self = this;
											array.forEach( function ( entry ) {
												coord = entry.split( ' ' );
												coords[self.order[index]] = {x: Number( coord[0] ), y: Number( coord[1] )};
												index ++;
											} );
											return coords;
										}
									} );
								}
							},
							"divider": {
								"style.js": function (exports, module, require) {
									/**
									 * Created by Ovidiu on 4/21/2017.
									 */
									module.exports = require( '../style-picker' ).extend( {
										item_template: function () {
											return TVE.tpl( 'controls/divider/style-picker' );
										},
										update: function () {
											var $element = this.applyTo().find( 'hr' ),
												classes = $element.attr( 'class' ).split( ' ' ),
												selected = this.model.config.default;

											// remove 'tve_sep' class (a mandatory class for divider element) to determine the selected class
											var index = classes.indexOf( 'tve_sep' );
											if ( index > - 1 ) {
												classes.splice( index, 1 );
											}

											if ( classes.length === 1 ) {
												selected = classes[0];
											}

											this.$( '.tve-select-item' ).removeClass( 'active' ).filter( '[data-value=' + selected + ']' ).addClass( 'active' );
											this.model.selected_old = selected;
											this.component.$el.find( '.style-change-input' ).val( this.getLabel( selected ) );
										},
										input: function ( $element ) {
											var $hr = $element.find( 'hr' );

											$hr.removeClass( function ( index, className ) {
												return (className.match( /(^|\s)tve_sep-\S+/g ) || []).join( ' ' );
											} );

											$hr.addClass( this.model.selected );
											$element.attr( 'data-style', this.model.selected );
											this.component.addDividerHeadCss( $element );
										},
										cancel: function ( $element ) {
											var $hr = $element.find( 'hr' );

											$hr.removeClass( this.model.selected ).addClass( this.model.selected_old );
											this.model.selected = this.model.selected_old;

											// Add to the element the old class
											$element.attr( 'data-style', this.model.selected );

											this.component.addDividerHeadCss( $element );
										},
										apply: function ( $element ) {
											this.component.addDividerHeadCss( $element );
											this.undo_manager_api( $element, this.model )
										},
										/**
										 * Undo Manager API
										 *
										 * @param $element
										 * @param model
										 */
										undo_manager_api: function ( $element, model ) {
											var self = this,
												selected = model.selected,
												selected_old = model.selected_old;

											TVE.UndoManager.add( {
												undo: function () {
													$element.attr( 'data-style', selected_old );
													$element.find( 'hr' ).removeClass( selected ).addClass( selected_old );
													self.component.addDividerHeadCss( $element );
												},
												redo: function () {
													$element.attr( 'data-style', selected );
													$element.find( 'hr' ).removeClass( selected_old ).addClass( selected );
													self.component.addDividerHeadCss( $element );
												}
											} );
										}
									} );
								}
							},
							"drop-panel.js": function (exports, module, require) {
								(function ( $ ) {
									var base = require( '../base' ),
										DROP_PANEL_UNIQ = 1;

									var DropPanel = base.control.extend( {
										_template: TVE.tpl( 'controls/drop-panel' ),
										/**
										 * By default, if not overridden, make sure the drop-panel always has a unique id
										 *
										 * @returns {Number}
										 */
										key: function () {
											return this.$el.data( 'view' ) || (DROP_PANEL_UNIQ ++);
										},
										initialize: function ( options ) {

											$.extend( true, this, options );

											if ( typeof this.template === 'undefined' && this.model.config.template ) {
												this.template = TVE.tpl( this.model.config.template )
											}
											if ( ! this.template ) {
												this.template = $.noop;
											}
											this.append_element( options );

											this.$el.data( 'dp-instance', this ).on( 'click', function ( e ) {
												e.stopPropagation();
											} );

											base.control.prototype.initialize.apply( this, arguments );

											if ( options && options.no_buttons ) {
												this.$el.addClass( 'panel-bare' );
											}

											this.__drop_panel_height = this.$( '.drop-panel' ).outerHeight();
											this.hide();
										},
										/**
										 * Appends itself to DOM
										 */
										append_element: function () {
											this.setElement( $( '<div>', {
												id: 'tcb-drop-' + ( this.$el.data( 'view' ) || this.key() ),
												class: 'tcb-drop-panel',
												html: this._template(),
												'data-view': this.key()
											} ).appendTo( TVE.main.$dropPanels )[0] );
										},
										/**
										 * Render the control template inside the drop panel
										 * @returns {exports}
										 */
										render: function () {
											this.$( '.popup-content' ).html( this.template() );

											return this;
										},
										/**
										 * Hide all drop panels, display the current one and position it correctly
										 * @param $element
										 * @param target
										 */
										open: function ( $element, target ) {

											this.prevent_blur = TVE.prevent_blur;

											/* skip the global blur event */
											TVE.prevent_blur = true;
											/**
											 * Close all other instances of opened drop panels
											 */
											DropPanel.close_all();
											this.visible = true;
											/* add menu overlay */
											TVE.main.$cpanel.find( '.tve-panel' ).addClass( 'drop-panel-open' );
											TVE.$document.on( 'keydown.drop_panel', _.bind( function ( e ) {
												if ( e.which === 27 ) {
													this.onCancel();
													TVE.$document.off( 'keydown.drop_panel' );
												}
											}, this ) );
											this.show();
											this.position( target );
											this.onOpen( $element, target, this.$el );

											TVE.main.scroll_panel_to( this.$( '.drop-panel' ) );

											return false;
										},
										isOpen: function () {
											return this.$el.is( ':visible' );
										},
										/**
										 * hide the current drop panel
										 */
										hide: function ( $element, dom ) {
											this.visible = false;
											/* re-enable "click-out" for blur */
											TVE.prevent_blur = this.prevent_blur;

											TVE.main.$cpanel.find( '.tve-panel' ).removeClass( 'drop-panel-open' );
											this.last_target && this.last_target.removeClass( 'drop-panel-focus' );
											this.$el.hide();
											/* hide all colorpickers */
											this.$( '.color-picker' ).spectrum( 'hide' );
											this.trigger( 'close' );
											this.onClose( $element, dom );
										},
										isVisible: function () {
											return this.visible;
										},
										/**
										 * show the current drop panel
										 */
										show: function () {
											this.$el.show();

											return this;
										},
										/**
										 * position the drop panel under the target
										 * @param target
										 */
										position: function ( target ) {

											if ( ! target ) {
												return;
											}

											var $target = $( target ),
												position = $target.offset();

											this.$el.css( {
												top: ( position.top - TVE.main.$scrollbar.offset().top + TVE.main.$scrollbar.scrollTop() ) + 'px'
											} );

											this.$( '.tcb-panel-arrow' ).css( {
												left: ( position.left - TVE.panel_offset.left + $target.outerWidth() / 2 ) + 'px'
											} );

											this.last_target = $target.addClass( 'drop-panel-focus' );
										},
										/**
										 * On cancel action we'll hide the drop panel and call the cancel function which will have the be implemented by each control
										 * @param $element
										 * @param dom
										 */
										onCancel: function ( $element, dom ) {
											/* cancel only if this is visible */
											if ( this.isVisible() ) {
												this.hide( $element, dom );
												this.cancel( $element, dom );
											}
										},
										/**
										 * On apply function first we validate the drop panel and after that call the apply function
										 * @param $element
										 * @param dom
										 */
										onApply: function ( $element, dom ) {
											if ( this.validate( $element, dom ) === true ) {
												this.apply( $element, dom );
												this.hide( $element, dom );
											}
										},
										/**
										 * Validate that all the data from the drop panel is correct.
										 * Will have to be overwritten by the control.
										 * @returns {boolean}
										 */
										validate: function () {
											return true;
										},
										/**
										 * Cancel method that will have to be overwritten by the control that inherits this
										 */
										cancel: function () {
											throw new Error( this.key() + ': Cancel function not implemented for this drop panel!!!' );
										},
										/**
										 * Apply method that will have to be overwritten by the control that inherits this
										 */
										apply: function () {
											throw new Error( this.key() + ': Apply function not implemented for this drop panel!!!' );
										},
										/**
										 * Function that is called just after opening the drop panel. It should be overwritten by the control.
										 */
										onOpen: function ( $element, dom ) {
										},
										/**
										 * Triggered each time the Drop Panel is closed (hidden)
										 * @param $element
										 * @param dom
										 */
										onClose: function ( $element, dom ) {
										}
									}, {
										/* static functions */
										/**
										 * Closes all open panels
										 */
										close_all: function () {
											TVE.main.$dropPanels.add( '#inline-drop-panels' ).find( '.tcb-drop-panel' ).filter( ':visible' ).each( function () {
												var _instance = $( this ).data( 'dp-instance' );
												if ( _instance ) {
													_instance.onCancel( _instance.applyTo() );
												}
											} );
										}
									} );

									module.exports = DropPanel;

								})( jQuery );
							},
							"element-states.js": function (exports, module, require) {
								var BaseView = require( '../base' ).base_view,
									CLS_RELATIVE = 'tcb-relative',
									CLS_HIDE = 'tcb-hidden';

								module.exports = BaseView.extend( {
									template: TVE.tpl( 'element-states' ),
									initialize: function () {
										BaseView.prototype.initialize.apply( this, arguments );
										this.dom = {
											dropdown: this.$( '.drop-content' ).addClass( CLS_HIDE ),
											states: this.$( '.state-section' ).filter( '.state-default' ).removeClass( CLS_HIDE ).end()
										};
										if ( ! this.$el.hasClass( CLS_RELATIVE ) ) {
											this.$el.addClass( CLS_RELATIVE );
										}
										this.s = 'default';
									},
									disable: function () {
										this.$el.addClass( 'tcb-hidden' );
										this.disabled = true;
									},
									enable: function () {
										this.$el.removeClass( 'tcb-hidden' );
										delete this.disabled;
									},
									toggle_dropdown: function () {
										if ( this.disabled ) {
											return false;
										}
										this.dom.dropdown.toggleClass( CLS_HIDE );
									},
									state_select: function ( e ) {
										if ( this.disabled ) {
											return false;
										}
										var s = e.currentTarget.dataset.state;
										this.dom.dropdown.addClass( CLS_HIDE );

										if ( s === this.s ) {
											return false;
										}

										this.s = s;
										this.trigger( 'state_change', s );

										/**
										 * a keyup Esc event cancels the current state
										 */
										TVE.inner.$body.on( 'keyup.state_cancel', jQuery.proxy( function ( e ) {
											if ( e.which === 27 ) {
												return this.done();
											}
										}, this ) );

										this.update_dom( s );

										return false;
									},
									/**
									 * DOM update
									 *
									 * @param {String} [state]
									 * @returns {boolean}
									 */
									update_dom: function ( state ) {
										state = typeof state === 'undefined' ? 'default' : state;
										this.dom.states.addClass( CLS_HIDE )
											.filter( '.state-' + (state === 'default' ? state : 'edit') ).removeClass( CLS_HIDE );

										TVE.main.set_element_name( null, state !== 'default' ? ': ' + state.toUpperCase() : null );
										this.$( 'li' ).removeClass( 'selected' ).filter( '[data-state="' + state + '"]' ).addClass( 'selected' );

										return false;
									}
									,
									/**
									 * Change back to default state
									 *
									 * @returns {boolean}
									 */
									done: function () {
										TVE.inner.$body.off( 'keyup.state_cancel' );
										this.trigger( 'done' );
										this.s = 'default';

										this.update_dom();

										return false;
									}
								} );
							},
							"file.js": function (exports, module, require) {
								var base = require( '../base' ),
									FilePicker = require( '../../libs/file-picker' );
								/**
								 * Inline file picker control
								 */
								module.exports = base.control.extend( {
									ICONS: {
										image: 'image2',
										video: 'video'
									},
									template: TVE.tpl( 'util/file-picker' ),
									config: {
										type: 'image'
									},
									labels: {
										choose: TVE.t.ChooseFile,
										title: TVE.t.Files
									},
									initialize: function ( attr ) {
										this.labels = _.defaults( attr.labels || {}, this.labels );
										this.config = _.defaults( attr.config || {}, this.config );
										this.selection = null;
										this.picker = (new FilePicker( {
											title: this.labels.title,
											library: {
												type: this.config.type
											}
										} )).on_select( this._select, this );

										this.render();
									},
									open_media: function () {
										this.picker.open();
									},
									set: function ( selection ) {
										this.selection = _.extend( {}, selection );
										if ( this.selection && ! this.selection.title ) {
											this.default_title();
										}
										this.render();
									},
									get: function () {
										return this.selection || {};
									},
									_select: function ( specific, general ) {
										this.selection = specific;
										this.render();
										this.trigger( 'select', specific, general );
									},
									remove: function () {
										this.trigger( 'remove' );
										this.selection = null;
										this.render();
										return false;
									},
									preview_icon: function () {
										return TVE.icon( this.ICONS[this.config.type] || this.ICONS.image );
									},
									/**
									 * Setup the title to the name of the file
									 *
									 * @returns {exports}
									 */
									default_title: function () {
										if ( ! this.selection || ! this.selection.url ) {
											return this;
										}

										this.selection.title = this.selection.url.replace( /\/$/, '' ).split( '/' ).pop();

										if ( ! this.selection.title ) {
											this.selection.title = '[no title]';
										}

										return this;
									}
								} );
							},
							"font-manager.js": function (exports, module, require) {
								(function ( $ ) {

									var drop_panel = require( './drop-panel' );

									module.exports = drop_panel.extend( {

										before_initialize: function () {
											this.fonts = TVE.CONST.fonts;

											this.fonts.google.fonts = TVE.FontManager.get_google_fonts();

											this.section = false;
										},

										after_initialize: function () {
											var g_fonts = [],
												self = this,
												$google_fonts = this.$( '.tve-google-font-select' ).css( 'width', '204px' );

											_.each( this.fonts.google.fonts, function ( v, k ) {
												g_fonts.push( {
													key: k,
													value: v.family,
													label: v.family
												} )
											} );

											$google_fonts.autocomplete( {
												source: g_fonts,
												delay: 100,
												minLength: 0,
												appendTo: $google_fonts.parent(),
												open: function () {
													$google_fonts.autocomplete( 'widget' ).css( {display: 'block'} );
													return false;
												},
												select: function ( event, ui ) {
													self.google.update( self, ui.item.key, true );
													event.stopPropagation();
												}
											} ).autocomplete( 'widget' ).addClass( 'tcb-suggest tcb-dark tcb-fonts tcb-absolute' ).css( 'max-width', '204px' );

											$google_fonts.bind( 'click', function () {
												$google_fonts.autocomplete( 'search' );
											} )
										},
										sourceChange: function ( $element, dom ) {
											this.showSection( dom.value, true );

											/* for inherit section we don't have other fonts to select so we call update here  */
											if ( dom.value === 'inherit' ) {
												this.inherit.update( this );
											}

											TVE.main.scroll_panel_to( this.$( '.drop-panel' ) );
										},
										/**
										 * Hide all sections and display the desired one
										 * @param _section {String}
										 * @param reset {Boolean} reset the content of the section
										 */
										showSection: function ( _section, reset ) {
											this.$( '.font-section' ).hide();

											this.section = _section;

											this.$( '.font-section[data-section="' + _section + '"]' ).show();

											if ( reset ) {
												this[this.section].reset();
											}
										},

										readFont: function () {
											var font = this.initial_font,
												key, section = 'inherit';

											if ( font ) {
												font = font.replace( /"/g, '' );

												_.each( this.fonts.google.fonts, function ( v, k ) {
													if ( v.family == font ) {
														section = 'google';
														key = k;
														return;
													}
												} );

												_.each( this.fonts.safe.fonts, function ( v, k ) {
													if ( v.family == font ) {
														section = 'safe';
														key = k;
														return;
													}
												} );
											}

											this.$( '.tve-font-select' ).val( section );
											if ( section !== 'inherit' && key !== '' ) {
												this[section].setValue( key );
												this[section].update( this, key, false );
											}

											this.showSection( section );
										},

										googleRecommended: function () {
											//TODO: wait for list from Lupascu
										},

										google: {
											/**
											 * Called when a new font is selected
											 * @param _this reference to the controller
											 * @param key key of the font that was selected
											 * @param write {Boolean} write head css or not
											 */
											update: function ( _this, key, write ) {
												var font = _this.fonts.google.fonts[key], self = this;

												this.fonts = _this.fonts.google.fonts;
												this.$font = this.$font ? this.$font : _this.$( '.tve-google-font-select' );
												this.$weight = _this.$( '.tve-google-weigh-select' ).empty();
												this.$bold = _this.$( '.tve-google-bold-select' ).empty();
												this.$subsets = _this.$( '.tve-google-subsets-select' ).empty();

												this.$font.data( 'key', key );

												if ( ! font ) {
													return;
												}

												_.each( font.variants, function ( v, k ) {
													if ( ! isNaN( v ) && v < 400 ) {
														self.$weight.append( $( '<option>', {
															value: v,
															text: v
														} ) )
													}
												} );

												this.$weight.append( $( '<option>', {
													value: 400,
													text: '400'
												} ).prop( 'selected', true ) );

												_.each( font.variants, function ( v, k ) {
													if ( ! isNaN( v ) && v > 400 ) {
														self.$bold.append( $( '<option>', {
															value: v,
															text: v
														} ) )
													}
												} );

												if ( this.$bold.find( 'option' ).length === 0 ) {
													this.$bold.append( $( '<option>', {
														value: '',
														text: 'Bold'
													} ).prop( 'selected', true ) );
												}

												_.each( font.subsets, function ( v ) {
													self.$subsets.append( $( '<option>', {
														value: v,
														text: v
													} ) )
												} );

												_this.setInputValue( this.fonts[key].family );

												if ( write ) {
													this.css( _this );
												}
											},
											/**
											 * Validate google fonts drop panel
											 * @returns {boolean}
											 */
											validate: function () {
												var data = this.data();

												if ( ! data.family || ! data.subsets ) {
													return false;
												}

												return data.variants.length > 0;

											},
											/**
											 * Font object
											 * @returns {{family: *, variants: Array.<*>, subsets: *}}
											 */
											data: function () {
												return {
													family: this.fonts[this.$font.data( 'key' )].family,
													variants: [this.$weight.val(), this.$bold.val()].filter( function ( v ) {
														return v.trim().length > 0;
													} ),
													subsets: this.$subsets.val()
												};
											},
											/**
											 * Write css modifications for the current font
											 */
											css: function ( _this ) {
												var key = this.$font.data( 'key' );
												TVE.FontManager.import_font( this.data() );

												_this.set( this.fonts[key].family );

												return this.fonts[key].family;
											},
											reset: function () {
												this.$font && this.$font.val( '' );
												this.$weight && this.$weight.val( '' );
												this.$subsets && this.$subsets.val( '' );
											},
											setValue: function ( key ) {
												if ( this.$font ) {
													this.$font.val( this.fonts[key].family );
												}
											}
										},

										safe: {
											update: function ( _this, key, write ) {

												this.$select = _this.$( '.tve-safe-font-select' );

												this.font = _this.fonts.safe.fonts[key].family;

												if ( this.validate() ) {
													_this.setInputValue( this.font );

													if ( write ) {
														this.css( _this );
													}
												}
											},
											validate: function () {
												return this.font && this.font.trim().length > 0;
											},
											css: function ( _this ) {

												_this.set( this.font );

												return this.font;
											},
											reset: function () {
												this.$select && this.$select.val( '' );
											},
											setValue: function ( key ) {
												if ( this.$select ) {
													this.$select.val( key );
												}
											}
										},
										inherit: {
											update: function ( _this ) {
												this.css( _this );
											},
											validate: function () {
												return true;
											},
											css: function ( _this ) {
												_this.set( 'inherit' );
											},
											reset: function () {
											}
										},
										/**
										 * Apply font to the current selection
										 * @param value
										 */
										set: function ( value ) {
											TVE.SkipUpdate = true;
											var $element = this.applyTo();

											if ( this.model.config.tinymce ) {
												if ( TVE.froala.has_selection() ) {
													TVE.froala.exec( 'format.applyStyle', 'font-family', value );
												} else {
													TVE.froala.get_block_element().head_css( {'font-family': value} );
												}

												return;
											}

											this.writeCSS( $element, value );
										},
										writeCSS: function ( $element, value ) {
											/* apply the font in head css */
											$element.head_css( {'font-family': value}, false, this.config.css_suffix, true, this.config.css_prefix );
										},
										/**
										 * When cancel button is pressed, write the initial font and update the input.
										 * @param $element
										 */
										cancel: function ( $element ) {
											this.set( this.initial_font );
											this.setInputValue( this.initial_font );
										},
										/**
										 * Apply the current style in head css again so it will add an undo/redo action
										 * @param $element
										 */
										apply: function ( $element ) {
											if ( this.validate() ) {

												TVE.SKIP_CSS_STATE = false;
												var font = this[this.section].css( this );
												this.initial_font = font;
												this.setInputValue( font );

												this.hide();
											}
										},

										input: function ( $element, dom ) {
											this.change( $element, dom );
										},
										/**
										 * Validate current section of font
										 */
										validate: function () {
											return this[this.section].validate();
										},
										/**
										 * Change of the current font settings
										 * @param $element
										 * @param dom
										 */
										change: function ( $element, dom ) {
											var font = dom.getAttribute( 'data-font' );

											if ( this.validate() ) {
												TVE.SKIP_CSS_STATE = true;
												this.setInputValue( this[font].css( this ) );
											}
										},
										/**
										 * Font section change
										 * @param $element
										 * @param dom
										 */
										fontChange: function ( $element, dom ) {
											var font = dom.getAttribute( 'data-font' );

											if ( typeof this[font].update === 'function' ) {
												this[font].update( this, dom.value, true );
											}
										}

									} );

								})( jQuery );
							},
							"icon-label-switch.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 2/21/2017.
								 */
								var base = require( '../base' );

								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/icon-label-switch' ),
									initialize: function ( args ) {
										this.template_model = args.template_model || this.default_model();

										this.render();
										this.after_initialize && this.after_initialize();
									},
									trigger_click: function ( event, dom ) {
										this.$el.find( 'input[type="checkbox"]' ).trigger( 'click' );
									},
									clicked: function ( event, dom ) {
										this.setLabel( dom.checked );
										this.change( dom.checked );
									},
									/**
									 * Checks if a checkbox is checked/unchecked
									 *
									 * @returns {Boolean}
									 */
									isChecked: function () {
										return this.$( 'input[type="checkbox"]' ).is( ':checked' );
									},
									/**
									 * Sets the checkbox state checked or unchecked depending on the checked flag
									 *
									 * @param checked
									 */
									setChecked: function ( checked ) {
										this.setLabel( checked );
										this.$el.find( 'input[type="checkbox"]' ).prop( 'checked', checked );
									},
									/**
									 * Sets the disable state true or false depending on the disable flag
									 *
									 * @param disabled
									 */
									setDisabled: function ( disabled ) {
										if ( disabled ) {
											this.$el.find( '.tcb-device-switch-label' ).html( TVE.t.Disabled.toUpperCase() );
										} else {
											this.setLabel( this.$( 'input[type="checkbox"]:checked' ).length );
										}
										this.$el.find( 'input[type="checkbox"]' ).prop( 'disabled', disabled );
									},
									/**
									 * Sets lable to the checkbox depending on the checkbox status
									 *
									 * @param checked
									 */
									setLabel: function ( checked ) {
										var device_statsu = '<span style="color:#4bb35e" >' + TVE.t.Visible.toUpperCase() + '</span>';
										if ( ! checked ) {
											device_statsu = TVE.t.Hidden.toUpperCase();
										}
										this.$el.find( '.tcb-device-switch-label' ).html( device_statsu );
									},
									render: function () {
										this.$el.html( this.template( {model: this.template_model} ) );
									},
									/**
									 * For cases where this is extended, should populate a default backbone model with data needed in the view template
									 */
									default_model: function () {
										return new Backbone.Model( {} );
									}
								} );
							},
							"image": {
								"style.js": function (exports, module, require) {
									/**
									 * Created on 3/28/2017.
									 */
									module.exports = require( '../style-picker' ).extend( {
										item_template: function () {
											return TVE.tpl( 'controls/image/style-picker' );
										},
										update: function () {
											var $element = this.applyTo(),
												classes = $element.attr( 'class' ).split( ' ' ),
												selected = this.model.config.default || 'no_style';

											for ( var i = 0; i < classes.length; i ++ ) {
												if ( classes[i].substr( 0, 10 ) == 'img_style_' ) {
													selected = classes[i];
													break;
												}
											}

											this.$( '.tve-select-item' ).removeClass( 'active' ).filter( '[data-value=' + selected + ']' ).addClass( 'active' );
											this.model.selected_old = selected;
											this.component.$( '#tcb-image-style-name' ).val( this.getLabel( selected ) );
										},
										input: function ( $element, dom ) {
											$element.removeClass( function ( index, className ) {
												return (className.match( /(^|\s)img_style_\S+/g ) || []).join( ' ' );
											} );

											if ( this.model.selected !== 'no_style' ) {
												$element.addClass( this.model.selected );
											}

										},
										/**
										 * Callback for drop panel apply action
										 */
										apply: function ( $element, dom ) {
											if ( this.model.selected ) {
												this.component.$( '#tcb-image-style-name' ).val( this.getLabel( this.model.selected ) );
											}

											this.undo_manager_api( $element, this.model );
										},
										/**
										 * Callback for drop panel cancel action
										 */
										cancel: function ( $element, dom ) {
											if ( this.model.selected && this.model.selected !== 'no_style' ) {
												$element.removeClass( this.model.selected );
											}

											if ( this.model.selected_old && this.model.selected_old !== 'no_style' ) {
												$element.addClass( this.model.selected_old );
											}
											
											this.undo_manager_api( $element, this.model );
										},
										/**
										 * Undo Manager API
										 *
										 * @param $element
										 * @param model
										 */
										undo_manager_api: function ( $element, model ) {
											var self = this,
												selected = (model.selected && model.selected !== 'no_style') ? model.selected : '',
												selected_old = (model.selected_old && model.selected_old !== 'no_style') ? model.selected_old : '';

											TVE.UndoManager.add( {
												undo: function () {
													this.undo_redo();
												},
												redo: function () {
													this.undo_redo();
												},
												undo_redo: function () {
													if ( $element.is( '[class*="img_style_"]' ) ) {
														$element.removeClass( selected ).addClass( selected_old );
														if ( TVE.ActiveElement ) {
															self.update();
														}
													} else {
														$element.addClass( selected ).removeClass( selected_old );
														if ( TVE.ActiveElement ) {
															self.update();
														}
													}
												}
											} );
										}

									} )
									;
								}
							},
							"image-picker.js": function (exports, module, require) {
								var base = require( '../base' ),
									ImagePicker = require( '../../libs/file-picker' );

								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/image' ),
									initialize: function () {
										this.render();
										this.picker = (new ImagePicker()).on_select( this.change_image, this );
										this.picker.on_cancel( this.on_cancel, this );
									},
									open: function () {
										this.image_selected = false;
										this.picker.open();

										return false;
									},
									change_placeholder: function () {
										this.placeholder = true;
										this.open();
									},
									on_cancel: function () {
										if ( this.placeholder ) {
											delete this.placeholder;
											TVE.main.clear_focus();
										}
									},
									/**
									 * This also applies the srcset and sizes attributes
									 *
									 * @param thumb
									 * @param attachment
									 */
									change_image: function ( thumb, attachment ) {
										this.image_selected = true;
										var $img = this.applyTo().find( 'img' ),
											attr = {};

										/**
										 * First is the TCB 2.0 placeholder.
										 * We need to create the image element. If image is not found. we create it.
										 */
										if ( $img.length === 0 ) {
											this.applyTo().html( '<span class="tve_image_frame"><img class="tve_image" alt=""/></span>' );
											$img = this.applyTo().find( 'img' );
										}

										if ( thumb.width && attachment && _.isObject( attachment.sizes ) ) {
											var srcset = '';
											_.each( attachment.sizes, function ( size, key ) {
												if ( size.width && size.url && size.width <= thumb.width ) {
													srcset += (srcset ? ', ' : '' ) + this.picker.clean_url( size.url ) + ' ' + size.width + 'w';
												}
											}, this );

											attr.srcset = srcset ? srcset : '';
											attr.sizes = '(max-width:' + thumb.width + 'px) 100vw, ' + thumb.width + 'px';
										} else {
											$img.removeAttr( 'sizes' )
												.removeAttr( 'srcset' );
										}

										attr.width = thumb.width;
										attr.height = thumb.height;
										attr.alt = thumb.alt;
										attr.title = thumb.title;
										attr['data-id'] = attachment.id;

										if ( thumb.caption ) {
											var $imgElement = $img.closest( '.tve_image_caption' );
											$imgElement.find( '.wp-caption-text' ).remove();
											$imgElement.append( '<p class="wp-caption-text thrv-inline-text">' + thumb.caption + '</p>' );
										}

										attr.src = this.picker.clean_url( thumb.url );
										$img.attr( attr );
										if ( this.placeholder ) {
											TVE.main.element_selected( TVE.ActiveElement.removeClass( 'tcb-elem-placeholder' ) );
											delete this.placeholder;
										}

										this.trigger( 'change', thumb );
									}
								} );
							},
							"image-size.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 7/10/2017.
								 */
								var maxWidth = require( './max-width' );

								module.exports = maxWidth.extend( {
									convertUM: function ( um ) {
										var element = this.applyTo( true ),
											context = element.parentNode,
											$input = this.$el.find( '.tve-input, .tve-slider' ),
											newVal = TVE.convertUM( element, um, context, this.model.config.css );

										$input.val( newVal );
									},
									afterConfig: function () {
										/* max width should be the width of the parent */
										var $parent = this.applyTo().parent();

										this.model.config.max = parseInt( ($parent.is( 'a' ) ? $parent.parent() : $parent).width() );
									}
								} );
							},
							"input-multiple.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 5/4/2017.
								 */
								var base = require( '../base' );
								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/input-multiple' ),
									after_initialize: function ( args ) {
										this.listenTo( this.model.get( 'list_items' ), 'remove', this.changeCollection );
										this.listenTo( this.model.get( 'list_items' ), 'change', this.changeCollection );
									},
									/**
									 * Collection change callback
									 */
									changeCollection: function () {
										this.change( this.applyTo(), this.model.get( 'list_items' ).toJSON() );
									},
									render: function () {
										if ( this.model instanceof Backbone.Model === false ) {
											var obj = this.model.config;
											this.model = new Backbone.Model( {
												top_text: obj.top_text,
												add_button_text: obj.add_button_text,
												remove_title: obj.remove_title,
												list_label: obj.list_label,
												list_items: new Backbone.Collection( obj.list_items )
											} )
										}
										this.$el.html( this.template( {model: this.model} ) );

										if ( this.model.get( 'list_items' ).length === 0 ) {
											this.add_input_row();
										} else {
											this.model.get( 'list_items' ).each( this.renderOne, this );
										}
									},
									/**
									 * Render One Item
									 *
									 * @param item
									 */
									renderOne: function ( item ) {
										var view = new InputItem( {
											model: item,
											config: this.model
										} );
										this.$el.find( '.tcb-input-multiple-holder' ).append( view.render().el );
									},
									/**
									 * Adds an input row
									 */
									add_input_row: function () {
										var _model = new Backbone.Model( {value: ''} );
										this.model.get( 'list_items' ).add( _model );
										this.renderOne( _model );
									},
									/**
									 * Resets the list items collection
									 *
									 * @param arr - array
									 */
									resetCollection: function ( arr ) {
										this.model.get( 'list_items' ).reset( arr );
										this.render();
									}
								} );


								/**
								 * Input Item VIEW
								 */
								var InputItem = base.base_view.extend( {
									template: TVE.tpl( 'controls/input-multiple-item' ),
									initialize: function ( args ) {
										this.config = args.config;
										this.model = args.model;
									},
									render: function () {
										this.$el.html( this.template( {
											value: this.model.get( 'value' ),
											label: this.config.get( 'list_label' ),
											remove_title: this.config.get( 'remove_title' )
										} ) );

										return this;
									},
									/**
									 * Removes a model from the list
									 * Callback for clicking delete input
									 *
									 * @param $element
									 * @param dom
									 * @param event
									 * @private
									 */
									_remove: function ( $element, dom, event ) {
										this.model.destroy();
										this.remove();
									},
									/**
									 * Changes model properties
									 * Callback for modifying input value
									 *
									 * @param $element
									 * @param dom
									 * @param event
									 * @private
									 */
									_changed: function ( $element, dom, event ) {
										this.model.set( {'value': dom.value} );
										this.config.get( 'list_items' ).trigger( 'change' );
									}
								} );
							},
							"input-search.js": function (exports, module, require) {
								(function ( $ ) {
									var input = require( './input' );

									module.exports = input.extend( {
										initialize: function () {
											var self = this,
												last,
												cache;

											this.render();

											this.$el.find( '.tve-input' ).autocomplete( {
												source: function ( request, response ) {
													if ( last === request.term ) {
														response( cache );
														return;
													}

													if ( /^https?:/.test( request.term ) || request.term.indexOf( '.' ) !== - 1 ) {
														self.$text.val( request.term );
														return response();
													}

													$.post( tcb_main_const.ajax_url, {
														action: 'tve_find_quick_link_contents',
														json: '1',
														q: request.term
													}, function ( data ) {
														cache = data;
														response( data );
													}, 'json' );

													last = request.term;
												},
												focus: function ( event, ui ) {
													event.preventDefault();
												},
												select: function ( event, ui ) {
													self.$el.find( '.tve-input' ).val( ui.item.url );
												}
											} ).autocomplete( 'instance' )._renderItem = function ( ul, item ) {
												return $( '<li role="option" id="mce-tcb-autocomplete-' + item.id + '">' ).append( '<span>' + item.label + '</span>&nbsp;<span class="tcb-link-type">' + item.type + '</span>' ).appendTo( ul );
											};
										}
									} );
								})( jQuery );
							},
							"input.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/input' ),
									initialize: function () {
										var self = this,
											stepSize = this.model.config.stepSize || 1;

										this.render();

										if ( this.model.config.um ) {
											this.$el.find( '.input-um' ).show();
										}

										this.$input = this.$el.find( 'input' );

										this.$el.find( '.handle' ).tve_draggable( {
											stepSize: stepSize,
											start: function () {
												self.currentValue = isNaN( self.getValue() ) ? 0 : parseInt( self.getValue() );
											},
											move: function ( delta ) {
												var value = self.currentValue + parseInt( delta );

												if ( typeof self.model.config.min !== 'undefined' ) {
													value = value < self.model.config.min ? self.model.config.min : value;
												}

												if ( typeof self.model.config.max !== 'undefined' ) {
													value = value > self.model.config.max ? self.model.config.max : value;
												}

												self.setValue( value, false, true );
											},
											stop: function () {
												self.$input.trigger( 'change' );
											}
										} );
									},
									getValue: function () {
										return this.$input.val();
									},
									/**
									 * Set value for the input
									 * @param value {String|int} value to be set
									 * @param triggerChange {Boolean} either to trigger change or not
									 * @param triggerInput {Boolean} either to trigger change or not
									 */
									setValue: function ( value, triggerChange, triggerInput ) {

										if ( ! this.validate( value ) ) {
											return;
										}

										this.$input.val( value );

										if ( triggerChange ) {
											this.$input.trigger( 'change' );
										}
										if ( triggerInput ) {
											this.$input.trigger( 'input' );
										}
									},
									up: function () {
										this.setValue( this.getValue() - (- 1), true, true );
									},
									down: function () {
										this.setValue( this.getValue() - 1, true, true );
									},
									/**
									 * Run the validation and apply the change callback only if the validation passes
									 */
									validate_and_change: function () {
										this.$input.removeClass( 'has-error' );

										if ( ! this.validate( this.$input.val() ) ) {
											this.$input.addClass( 'has-error' ).focus();

											return false;
										}

										return this.change.apply( this, arguments );
									},
									/**
									 * Direct setter for the value
									 *
									 * @param value
									 */
									setValueDirectly: function ( value ) {
										this.$input.removeClass( 'has-error' ).val( value );
									},
									validate: function ( value ) {
										value = parseFloat( value );

										if ( isNaN( value ) ) {
											return false;
										}

										if ( typeof this.model.config.min !== 'undefined' && this.model.config.min > value ) {
											return false;
										} else if ( typeof this.model.config.max !== 'undefined' && this.model.config.max < value ) {
											return false;
										}

										return true;
									},
									/**
									 * Allows adding extra classes to the input node
									 */
									input_class: function () {
										return this.model.config && this.model.config.input_class ? this.model.config.input_class : '';
									}
								} );
							},
							"knob.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/knob' ),
									initialize: function ( attr ) {
										if ( attr.template ) {
											this.template = attr.template;
										}
										this.render();

										var self = this;
										if ( this.model.config.um.length === 1 ) {
											this.$el.find( '.input-um' ).show();
										}
										if ( this.model.config.default ) {
											self.setValue( this.model.config.default, false );
										}
										var skip_css_state;
										this.$( '.tve-knob' ).tve_draggable( {
											start: function ( style, dir, event ) {
												var offset = self.$( '.tve-knob' ).offset();
												width = self.$( '.tve-knob' ).outerWidth();

												self.knobX = isNaN( offset.left ) ? 0 : offset.left + width / 2;
												self.knobY = isNaN( offset.top ) ? 0 : offset.top + width / 2;

												skip_css_state = TVE.SKIP_CSS_STATE;
											},
											move: function ( delta, style, dir, step, ctrlKey, event ) {
												var value = self.getKnobValue( event.pageX, event.pageY );

												TVE.SKIP_CSS_STATE = true;
												self.setValue( value, true );
											},
											stop: function () {
												TVE.SKIP_CSS_STATE = skip_css_state;
											}
										} );
										this.$( '.handle' ).tve_draggable( {
											start: function () {
												self.currentValue = parseInt( self.value() );
												if ( isNaN( self.currentValue ) ) {
													self.currentValue = 0;
												}
											},
											move: function ( delta ) {
												var value = self.currentValue + parseInt( delta );

												if ( typeof self.model.config.min !== 'undefined' ) {
													if ( value < self.model.config.min ) {
														value += self.model.config.max - 1;
													}
													value = value < self.model.config.min ? self.model.config.min : value;
												}

												if ( typeof self.model.config.max !== 'undefined' ) {
													if ( value > self.model.config.max ) {
														value -= self.model.config.max;
													}
													value = value > self.model.config.max ? self.model.config.max : value;

												}

												self.setValue( value, true );
											}
										} );
									},
									getKnobValue: function ( x, y ) {

										var value = Math.floor( this.angle( this.knobX, this.knobY, x, y ) );

										if ( typeof this.model.config.min !== 'undefined' ) {
											value = value < this.model.config.min ? this.model.config.min : value;
										}

										if ( typeof this.model.config.max !== 'undefined' ) {
											value = value > this.model.config.max ? this.model.config.max : value;
										}
										return value;

									},
									value: function () {
										return this.$( '.tve-input' ).val();
									},
									onChange: function ( $element, dom ) {
										var value = parseInt( dom.value );
										if ( typeof this.model.config.min !== 'undefined' ) {
											value = value < this.model.config.min ? this.model.config.min : value;
										}
										if ( typeof this.model.config.max !== 'undefined' ) {
											value = value > this.model.config.max ? this.model.config.max : value;
										}
										this.setValue( value );

										TVE.SkipUpdate = false;
										TVE.SKIP_CSS_STATE = true;
										this.change( $element, dom );
									},
									onInput: function ( $element, dom ) {
										this.$el.find( 'input' ).val( dom.value );
										TVE.SkipUpdate = true;

										this.input( $element, dom );
									},
									/**
									 * Set value for the slider and input
									 * @param value
									 * @param trigger {Boolean} trigger change on inputs
									 */
									setValue: function ( value, trigger ) {
										value = parseFloat( value );

										if ( value == parseInt( value ) ) {
											value = parseInt( value );
										}

										if ( isNaN( value ) ) {
											value = 0;
										}

										this.$el.find( '.tve-input' ).val( value );
										this.$( '.tve-knob' ).css( 'transform', 'rotate(' + (- value) + 'deg)' );

										if ( trigger ) {
											this.$el.find( '.tve-input' ).trigger( 'change' );
										}
									},
									up: function () {
										this.setValue( this.value( false ) - (- 1), true );
									},
									down: function () {
										this.setValue( this.value( false ) - 1, true );
									},
									angle: function ( cx, cy, ex, ey ) {

										var dy = ey - cy;
										var dx = ex - cx;

										var theta = Math.atan2( dy, dx ); // range (-PI, PI]

										theta *= 180 / Math.PI; // rads to degs, range (-180, 180]
										if ( theta < 0 ) {
											theta = 360 + theta;
										} // range [0, 360)
										return (360 - theta);
									}
								} );
							},
							"label-input.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 3/2/2017.
								 */
								var base = require( '../base' );

								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/label-input' ),
									render: function () {

										if ( this.model instanceof Backbone.Model === false ) {
											var obj = this.model.config;
											this.model = new Backbone.Model( {
												label: obj.label,
												extra_attrs: obj.extra_attrs,
												label_col_x: obj.label_col_x,
												placeholder: obj.placeholder
											} )
										}

										this.$el.html( this.template( {model: this.model} ) );
									},

									getValue: function () {
										return this.$( '.tve-input-control' ).val();
									},

									changed: function ( event, dom ) {
										// TODO: this.change should be called with the first parameter: this.applyTo(), and the second one dom to be consistent with the rest of the controls
										this.change( this.applyTo(), dom );
									},

									/**
									 * Sets Value to a text input
									 *
									 * @param value
									 */
									setValue: function ( value ) {
										this.$( '.tve-input-control' ).val( value );
									}
								} );
							},
							"link.js": function (exports, module, require) {
								/**
								 * General link search component - handles autocomplete
								 */
								var base = require( '../base' ),
									emailRegex = /^(mailto:)?[a-z0-9._%+-]+@[a-z0-9][a-z0-9.-]*\.[a-z]{2,63}$/i,
									urlRegex1 = /^https?:\/\/([^\s/?.#-][^\s\/?.#]*\.?)+(\/[^\s"]*)?$/i,
									urlRegex2 = /^https?:\/\/[^\/]+\.[^\/]+($|\/)/i;

								module.exports = base.control.extend( {
									template: TVE.tpl( 'util/link' ),
									className: 'tcb-link-search',
									after_initialize: function ( attr ) {
										this.href = '';
										this.$autocomplete = this.$( '.tcb-link-suggest' );
										this.$el.addClass( this.className );

										this.hide_preview = attr.hide_preview || false;
										this.search_lightbox = ! ! attr.search_lightbox;
										if ( this.hide_preview ) {
											this.$( '.url-preview' ).remove();
										}

										this.bind();
									},
									get_full_url: function ( href ) {
										href = typeof href !== 'undefined' ? href : this.href;
										if ( href && ! /^(?:[a-z]+:|#|\?|\.|\/)/.test( href ) && ! emailRegex.test( href ) ) {
											href = 'http://' + href;
										}
										return href;
									},
									bind: function () {
										var self = this,
											last,
											cache;
										this.$autocomplete.autocomplete( {
											appendTo: this.$el,
											source: function ( request, response ) {
												if ( last === request.term ) {
													response( cache );
													return;
												}

												if ( /^https?:/.test( request.term ) || request.term.indexOf( '.' ) !== - 1 ) {
													self.trigger( 'directurl', request );
													return response();
												}

												TVE.ajax( 'post_search', 'post', {q: request.term, search_lightbox: self.search_lightbox} )
													.done( function ( data ) {
														cache = data;
														response( data );
													} );

												last = request.term;
											},
											focus: function ( event, ui ) {
												/*
												 * Don't empty the URL input field, when using the arrow keys to
												 * highlight items. See api.jqueryui.com/autocomplete/#event-focus
												 */
												event.preventDefault();
											},
											select: function ( event, ui ) {
												self.href = self.get_full_url( ui.item.url );
												self.$autocomplete.val( self.href );
												self._dom();
												self.trigger( 'select', ui.item );

												return false;
											},
											minLength: 2,
											delay: 300,
											position: {
												my: 'left top+2'
											},
											messages: {
												noResults: ( typeof window.uiAutocompleteL10n !== 'undefined' ) ? window.uiAutocompleteL10n.noResults : '',
												results: function ( number ) {
													if ( typeof window.uiAutocompleteL10n !== 'undefined' ) {
														if ( number > 1 ) {
															return window.uiAutocompleteL10n.manyResults.replace( '%d', number );
														}

														return window.uiAutocompleteL10n.oneResult;
													}
												}
											}
										} ).autocomplete( 'instance' )._renderItem = function ( ul, item ) {
											return jQuery( '<li role="option" id="mce-tcb-autocomplete-' + item.id + '">' )
												.append( '<div class="post-name">' + item.label + '</div><span class="tcb-post-type">' + ( item.post_type_name ? item.post_type_name : item.type ) + '</span>' )
												.appendTo( ul );
										};
										this.$autocomplete.autocomplete( 'widget' ).addClass( 'tcb-suggest tcb-fixed-200 tcb-full-width' );
										self.$autocomplete
											.on( 'focus', function () {
												var inputValue = self.$autocomplete.val();
												/*
												 * Don't trigger a search if the URL field already has a link or is empty.
												 * Also, avoids screen readers announce `No search results`.
												 */
												if ( inputValue && ! /^https?:/.test( inputValue ) ) {
													self.$autocomplete.autocomplete( 'search' );
												}
											} )
											.on( 'keyup', function () {
												self.href = self.get_full_url( this.value );
												self.$( '.url-preview' ).text( self.href )[self.href ? 'show' : 'hide']();
											} )
											.on( 'change', function () {
												self.href = self.get_full_url( this.value );
												self._dom();
												self.trigger( 'linkchange', self.href );
											} );
									},
									/* update dom */
									_dom: function () {
										this.$( '.url-preview' ).text( this.href )[this.href ? 'show' : 'hide']();
									},
									set_link: function ( url ) {
										this.href = this.get_full_url( url );
										this.$autocomplete.val( url );
										this._dom();
									},
									get_link: function () {
										return this.href;
									},
									focus: function () {
										this.$autocomplete.focus();

										return this;
									}
								} );
							},
							"list.js": function (exports, module, require) {
								/**
								 * Created on 12/15/2016.
								 */

								/**
								 * Control for lists of items from which the user can choose
								 */
								module.exports = require( '../base' ).base_view.extend( {
									template: TVE.tpl( 'util/list' ),
									className: 'tcb-list',
									initialize: function ( attr ) {
										if ( ! attr.items ) {
											console.error( 'items are required when instantiating a list' );
											return;
										}
										this.collection = new Backbone.Collection();

										this.listenTo( this.collection, 'reset', this.render );
										this.listenTo( this.collection, 'add', this.render );
										this.$el.addClass( this.className );

										this.set_items( attr.items );

										if ( attr.value || attr.selected ) {
											this.select( attr.value || attr.selected );
										}
									},
									select: function ( e ) {
										var value = e,
											$list = this.$( 'li.item' ).removeClass( 'selected' );
										if ( _.isObject( e ) ) {
											value = e.currentTarget.getAttribute( 'data-value' );
											e.currentTarget.classList.add( 'selected' );
											this.trigger( 'change', value );
										} else {
											$list.filter( '[data-value="' + e + '"]' ).addClass( 'selected' );
										}
										if ( value ) {
											var item = this.collection.findWhere( {id: parseInt( value )} );
											if ( ! item ) {
												return this.select( 0 );
											}
											this.$( '.selected-item' ).html( TVE.t.Selected + ': <strong>' + item.get( 'title' ) + '</strong>' );
										} else {
											this.$( '.selected-item' ).html( '' );
										}
										this.value = value;
									},
									set_items: function ( items ) {
										_.each( items, function ( item, i ) {
											items[i].id = parseInt( items[i].id );
										} );
										this.collection.reset( items );
									},
									get_value: function () {
										return this.value;
									},
									set_value: function ( value ) {
										this.select( value );
										return this;
									},
									filter: function ( e, input ) {
										if ( e.which === 27 ) { // Escape pressed
											input.value = '';
											this.filter_string = input.value;
											this.$( 'li.item' ).show().length ? this.$( 'li.no-entry' ).hide() : this.$( 'li.no-entry' ).show();
											return false;
										}
										var self = this;
										this.filter_string = input.value;
										clearTimeout( this.filter_timeout );
										this.filter_timeout = setTimeout( function () {
											var $list = self.$( 'li.item' );
											if ( jQuery.trim( input.value ).length ) {
												$list = self.$( 'li.item' ).hide().filter( function () {
													return self.$( this ).text().toLowerCase().indexOf( input.value.toLowerCase() ) >= 0;
												} );
											}
											$list.show();
											if ( ! $list.length ) {
												self.$( 'li.no-entry' ).show();
											} else {
												self.$( 'li.no-entry' ).hide();
											}
										}, 100 );
									},
									render: function () {
										this.$el.html( this.template( {
											collection: this.collection,
											filter_string: this.filter_string || ''
										} ) );
										if ( ! this.collection.length ) {
											this.$( 'li.no-entry' ).show();
										} else {
											this.$( 'li.no-entry' ).hide();
										}
										return this;
									}
								} );
							},
							"margin-padding.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/margin-padding' ),
									sides: ['top', 'left', 'right', 'bottom'],
									link: false,
									initialize: function () {
										var self = this;

										this.render();

										var skip_state;
										this.$el.find( '.handle' ).tve_draggable( {
											stepSize: 2,
											start: function ( style, side ) {
												self.currentValue = isNaN( self.getValue( style, side ) ) ? 0 : self.parse( self.getValue( style, side ) );

												skip_state = TVE.SKIP_CSS_STATE;
											},
											move: function ( delta, style, side, step, all ) {

												TVE.SKIP_CSS_STATE = true;
												if ( all || self.link ) {
													_.each( self.sides, function ( side ) {
														self.setValue( style, self.parse( self.value( style, side ) ) + step, side, true );
													} );
												} else {
													self.setValue( style, self.currentValue + self.parse( delta ), side, true );
												}

												if ( style === 'margin' ) {
													/* when changing the margin, we reposition the icons */
													TVE.Editor_Page.reposition_icons();
												}
											},
											stop: function ( delta, style, side, step, all ) {
												self.currentValue += self.parse( delta );

												TVE.SKIP_CSS_STATE = false;
												self.setValue( style, self.currentValue, side, true );
												TVE.SKIP_CSS_STATE = skip_state;
												TVE.Editor_Page.reposition_icons();
											}
										} );
									},
									/**
									 * Function called when the margin/padding input is changed => set new value on object
									 * @param $element
									 * @param dom
									 */
									change: function ( $element, dom ) {
										var style = dom.getAttribute( 'data-style' ),
											side = dom.getAttribute( 'data-side' ),
											um = this.getUM(),
											css = {},
											self = this;

										this.error( this.validate( style, side ) );

										if ( this.link ) {
											_.each( this.sides, function ( side ) {
												css[style + '-' + side] = dom.value + um;
												self.setValue( style, dom.value, side );
											} );
										} else {
											css[style + '-' + side] = dom.value + um + '!important';
										}
										this.find_element( style, $element ).head_css( css, null, this.config.css_suffix, false, this.config.css_prefix );
									},
									umChange: function ( $element, dom ) {
										this.convertUM( dom.value )
									},
									convertUM: function ( um ) {
										var $element = this.applyTo(),
											context = TVE.ActiveElement.parent()[0],
											self = this;

										this.$el.find( '.tve-input' ).each( function () {
											var side = this.getAttribute( 'data-side' ),
												style = this.getAttribute( 'data-style' ) + TVE.ucFirst( side ),
												newUM = TVE.getComputedStyle( $element[0], style );

											switch ( um ) {
												case 'rem':
													newUM = parseFloat( newUM / TVE.rem_size() ).toFixed( 1 );
													break;
												case '%':
													var dimension;
													if ( ['left', 'right'].indexOf( side ) === - 1 ) {
														dimension = 'height';
													} else {
														dimension = 'width';
													}
													newUM = parseInt( newUM * 100 / TVE.getComputedStyle( context, dimension ) );
													break;
												case 'px':
												default:
													newUM = parseInt( newUM );
													break;
											}

											this.value = newUM;

											self.change( $element, this );
										} );
									},
									/**
									 * Set values on the inputs when reading the element
									 */
									update: function ( $element ) {
										var self = this,
											padding_needed_values = [],
											margin_needed_values = [],
											margin_css,
											padding_css,
											$margin_element = this.find_element( 'margin', this.applyTo() ),
											$padding_element = this.find_element( 'padding', this.applyTo() );

										_.each( this.sides, function ( side ) {
											margin_needed_values.push( 'margin-' + side );
											padding_needed_values.push( 'padding-' + side );
										} );
										margin_css = $margin_element.head_css( margin_needed_values, null, this.config.css_suffix, true, this.config.css_prefix );
										padding_css = $padding_element.head_css( padding_needed_values, null, this.config.css_suffix, true, this.config.css_prefix );

										_.each( this.sides, function ( side ) {
											var m = margin_css['margin-' + side].replace( '!important', '' );
											self.setValue( 'margin', m === 'auto' ? m : self.parse( m ), side );
											self.setValue( 'padding', self.parse( padding_css['padding-' + side] ), side );
										} );
									},
									linkInput: function ( $element, dom ) {

										this.link = dom.className.indexOf( 'active' ) === - 1;

										if ( this.link ) {
											dom.className += ' active';
										} else {
											dom.className = dom.className.replace( 'active', '' );
										}
									},
									keyup: function ( $element, dom, event ) {
										var val = event.keyCode === 38 ? 1 : (event.keyCode === 40 ? - 1 : 0);

										if ( val ) {
											dom.value = this.parse( isNaN( dom.value ) ? 0 : dom.value ) + val;
											this.change( $element, dom );
										}
									},
									/**
									 * Return input value
									 * @param style
									 * @param side
									 * return {string}
									 */
									value: function ( style, side ) {
										if ( this.sides.indexOf( side ) !== - 1 ) {
											return this.$el.find( '.tve-input.' + side + '[data-style="' + style + '"]' ).val();
										}
									},
									/**
									 * Get margin/padding value that is set on the element
									 * @param style margin or padding
									 * @param side left, right, top, bottom
									 * @param {boolean} um - when true, it will return full string, else it will return only numeric value
									 * @returns {*}
									 */
									getValue: function ( style, side, um ) {
										if ( this.sides.indexOf( side ) === - 1 || ! style ) {
											return;
										}

										var css,
											$element = this.find_element( style, this.applyTo() );

										css = $element.head_css( style + '-' + side, null, this.config.css_suffix, true );
										css = css.replace( '!important', '' );
										/* if the margin/padding is set to auto, just return it like that */
										if ( css === 'auto' ) {
											return css;
										}

										/* if there's nothing, then it's zero */
										if ( css == '' ) {
											css = 0;
										}

										if ( typeof um === 'undefined' ) {
											css = this.parse( css );

											if ( isNaN( css ) ) {
												css = 0;
											}
										}

										return css;
									},
									/**
									 * Set margin value on the control input
									 * @param style - margin or padding
									 * @param value
									 * @param side @see this.sides
									 * @param force - force update on the element also
									 */
									setValue: function ( style, value, side, force ) {
										if ( style === 'padding' && value < 0 ) {
											value = 0;
										}

										if ( this.sides.indexOf( side ) !== - 1 ) {
											this.$el.find( '.tve-input.' + side + '[data-style="' + style + '"]' ).val( value );
										} else {
											return;
										}

										this.error( this.validate( style, side ) );

										if ( force ) {
											var css = {},
												$element = this.find_element( style, this.applyTo() ).css( style + '-' + side, '' ); // make sure there is no inline style that overwrites the declaration
											css[style + '-' + side] = value + (isNaN( value ) ? '' : this.getUM()) + '!important';
											$element.head_css( css, null, this.config.css_suffix, false, this.config.css_prefix );
										}
									},
									/**
									 * Validate input
									 * @param style
									 * @param side
									 * @returns {boolean}
									 */
									validate: function ( style, side ) {
										var value = this.$el.find( '.tve-input.' + side + '[data-style="' + style + '"]' ).val();

										if ( style === 'margin' && value === 'auto' ) {
											return false;
										}

										value = value.replace( this.getUM(), '' );

										return isNaN( value );
									},
									/**
									 * Parse input depending on the unit of measure
									 * @param value
									 * @returns {*}
									 */
									parse: function ( value ) {
										if ( this.getUM() === 'rem' ) {
											value = parseFloat( value );
										} else {
											value = parseInt( value );
										}

										return value;
									},
									error: function ( show ) {
										var error = this.$el.find( '.error' );

										error[show ? 'show' : 'hide']();
									},
									/**
									 * Return the current unit of measure
									 * @returns {string}
									 */
									getUM: function () {
										return this.$el.find( '.um' ).val();
									},
									disable_control: function ( ctrl ) {
										this.$( '[data-style="' + ctrl + '"]' ).addClass( 'control-hide' );
									},
									find_element: function ( style, $element ) {
										if ( typeof this.config[style + '_to'] === 'undefined' ) {
											return $element;
										}

										if ( this.config[style + '_to'] ) {
											return TVE.ActiveElement.find( this.config[style + '_to'] );
										}

										return TVE.ActiveElement;
									}
								} );
							},
							"max-width.js": function (exports, module, require) {
								var slider = require( './slider' );

								module.exports = slider.extend( {
									convertUM: function ( um ) {
										var element = this.applyTo( true ),
											context = element.parentNode,
											$input = this.$el.find( '.tve-input, .tve-slider' ),
											newVal = TVE.getComputedStyle( element, 'maxWidth' ),
											contextVal = TVE.getComputedStyle( context, 'width' );

										if ( typeof newVal === 'string' && newVal.indexOf( '%' ) !== - 1 ) {
											newVal = parseFloat( newVal ) * this.model.config.max / 100
										} else {
											newVal = newVal || contextVal;
										}

										switch ( um ) {
											case 'vw':
												newVal = parseFloat( newVal * 100 / document.documentElement.clientWidth ).toFixed( 1 );
												break;
											case '%':
												newVal = parseFloat( newVal * 100 / TVE.getComputedStyle( context, 'width' ) );
												break;
											case 'px':
											default:
												newVal = parseInt( newVal );
												break;
										}

										$input.val( newVal );
									},
									isDefault: function () {
										var value = this.$el.find( '.tve-input' ).val();

										return value === 'auto' || value === 'none';
									},
									umChange: function ( $element, dom ) {
										var um = dom.getAttribute( 'data-value' );

										this.setUM( um );
										if ( this.isDefault() ) {
											return;
										}
										this.convertUM( um );
										this.change( this.applyTo(), this.$el.find( '.tve-input' )[0] );
									},
									setUM: function ( um ) {
										if ( this.model.config.um.indexOf( um ) === - 1 ) {
											return;
										}

										this.$el.find( '.tve-input-um.active' ).removeClass( 'active' );

										this.$el.find( '.tve-input-um[data-value="' + um + '"]' ).addClass( 'active' );

										this.umInit();
									},
									onInput: function ( $element, dom ) {
										/* make sure we have the same value on both the input and the slider */
										this.$el.find( 'input' ).val( dom.value );
										/* Don't allow the component to update on user input */
										TVE.SkipUpdate = true;

										this.input( $element, dom );
									},
									setValue: function ( value, trigger ) {
										var $input = this.$el.find( '.tve-input' ),
											$slider = this.$el.find( '.tve-slider' );

										if ( isNaN( value ) && value.indexOf( 'auto' ) === 0 ) {
											this.setUM( 'px' );
											$input.val( 'auto' );
											$slider.val( this.model.config.max );
										} else {
											this.setUM( this.readUM( value ) );

											value = parseFloat( value );
											if ( isNaN( value ) ) {
												value = 0;
											}

											$input.val( value );
											$slider.val( value );

											if ( trigger ) {
												$input.trigger( 'input' );
											}
										}
									},
									update: function () {
										var $element = this.applyTo(),
											css = $element.head_css( 'max-width' ) || $element.css( 'max-width' );

										if ( css === 'none' ) {
											css = 'auto';
										}

										this.setValue( css );
									},
									input: function ( $element, dom ) {
										$element.head_css( {'max-width': dom.value + this.getUM() + ( this.config.important ? ' !important' : '')}, false, this.config.css_suffix, true, this.config.css_prefix );

										TVE.Editor_Page.reposition_icons( $element );
									},
									change: function ( $element, dom ) {
										var um = this.getUM(),
											value = dom.value;
										if ( value === 'auto' ) {
											um = '';
											value = 'none';
										}
										$element.head_css( {'max-width': value + um + ( this.config.important ? ' !important' : '')}, false, this.config.css_suffix, true, this.config.css_prefix );

										TVE.Editor_Page.reposition_icons( $element );
									},
									afterConfig: function () {
										/* max width should be the width of the parent */
										this.model.config.max = parseInt( this.applyTo().parent().css( 'width' ) );
									}
								} );
							},
							"modal-picker.js": function (exports, module, require) {
								/**
								 * Created by dan bilauca on 5/3/2017.
								 */
								var base = require( '../base' );

								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/modal-picker' ),

									update: function ( $element ) {

									},

									setModal: function ( modal ) {

										this.modal = modal;
									},

									onModalSave: function ( data ) {

										this.change( this.applyTo(), data );
									},

									_getModal: function () {

										return this.modal;
									},

									/**
									 * Set value to input that shows out what was selected from modal
									 *
									 * @param value
									 */
									updateValue: function ( value ) {

										if ( ! value || value.length === 0 ) {
											value = tcb_main_const.i18n.none;
										}

										this.$( 'input' ).val( value );
									},

									openModal: function () {

										var _defaults = {
											top: '20%'
										};

										this.listenTo( this._getModal(), 'save', this.onModalSave );

										this._getModal().open( _defaults );
									}
								} );
							},
							"multiple-checkbox.js": function (exports, module, require) {
								/**
								 * Created by dan bilauca on 5/10/2017.
								 */

								var checkbox = require( './checkbox' );

								module.exports = checkbox.extend( {

									template: TVE.tpl( 'controls/multiple-checkbox' ),

									render: function () {

										this.$el.html( this.template( {item: this.model.config} ) );
										this._render_inputs();
									},

									_render_inputs: function () {

										var $wrapper = this.$( '.tve-inputs-wrapper' ),
											tpl = TVE.tpl( 'controls/checkbox/input' );

										_.each( this.model.config.inputs, function ( item, index, list ) {
											var $input = tpl( {item: new Backbone.Model( item )} );
											$wrapper.append( $input );
										}, this );
									},

									/**
									 * Set check prop of input on true or false
									 *
									 * @param name of input
									 * @param checked bool
									 */
									setChecked: function ( name, checked ) {

										if ( checked === undefined ) {
											checked = true;
										}

										this.$( 'input[name="' + name + '"]' ).prop( 'checked', ! ! checked );
									},

									uncheckAll: function () {

										this.$( 'input:checked' ).prop( 'checked', false );
									},

									get_checked_inputs: function () {

										var input_names = [];

										this.$( 'input:checked' ).each( function ( index, item ) {
											input_names.push( item.getAttribute( 'name' ) );
										} );

										return input_names;
									}

								} );
							},
							"position-from.js": function (exports, module, require) {
								var base = require( '../base' ),
									input = require( '../controls/input' );

								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/position-from' ),
									css: {},
									sides: ['top', 'right', 'bottom', 'left'],
									styles: {},
									initialize: function () {
										this.render();

										this.$vertical = this.$( '.vertical' );
										this.$horizontal = this.$( '.horizontal' );

										var vertical_input = new input( {
											el: this.$vertical.find( '.tve-control' ),
											model: {
												config: {
													type: 'number',
													um: 'PX'
												}
											}
										} ), horizontal_input = new input( {
											el: this.$horizontal.find( '.tve-control' ),
											model: {
												config: {
													type: 'number',
													um: 'PX'
												}
											}
										} );

										vertical_input.input = vertical_input.change = horizontal_input.input = horizontal_input.change = this.change.bind( this );

										this.state( 'default' );
									},
									state: function ( state ) {
										this.$( '.state' ).slideUp();
										this.$( '.state[data-state="' + state + '"]' ).slideDown();
									},
									edit: function ( $element ) {
										this.update( $element );

										this.current = Object.assign( {}, this.css );

										this.state( 'edit' );
									},
									save: function () {
										this.setValue( this.css );
										this.state( 'default' );
									},
									cancel: function () {
										this.styles = Object.keys( this.current );
										this.setValue( this.current );
										this.state( 'default' );
									},
									setValue: function ( css ) {
										var $element = this.applyTo(),
											self = this,
											style = {},
											remove_style = {};

										_.each( this.sides, function ( side ) {
											if ( self.styles.indexOf( side ) === - 1 ) {
												remove_style[side] = '';
											} else {
												style[side] = css[side];
											}
										} );

										$element.head_css( remove_style );
										$element.head_css( style );
									},
									positionChange: function ( $element, dom ) {
										this.$( '.position' ).removeClass( 'active' );
										dom.className += ' active';

										var css = dom.dataset.value,
											pos = css.split( '|' );

										this.styles = pos;

										this.css[pos[0]] = this.parse( $element.head_css( pos[0] ) || $element.css( pos[0] ) ) + this.um();
										this.css[pos[1]] = this.parse( $element.head_css( pos[1] ) || $element.css( pos[1] ) ) + this.um();

										this.setPosition( css );
									},
									parse: function ( value ) {
										value = parseInt( value );

										value = isNaN( value ) ? 0 : value;

										return value;
									},
									setPosition: function ( position ) {
										var pos = position.split( '|' );

										this.$vertical.find( '.input-label' ).html( TVE.ucFirst( pos[0] ) );
										this.$vertical.find( 'input' ).val( this.parse( this.css[pos[0]] ) ).attr( 'data-style', pos[0] );

										this.$horizontal.find( '.input-label' ).html( TVE.ucFirst( pos[1] ) );
										this.$horizontal.find( 'input' ).val( this.parse( this.css[pos[1]] ) ).attr( 'data-style', pos[1] );
									},
									update: function ( $element ) {
										$element = $element || this.applyTo();

										var top = this.parse( $element.head_css( 'top' ) || $element.css( 'top' ) ),
											bottom = this.parse( $element.head_css( 'bottom' ) || $element.css( 'bottom' ) ),
											left = this.parse( $element.head_css( 'left' ) || $element.css( 'left' ) ),
											right = this.parse( $element.head_css( 'right' ) || $element.css( 'right' ) ),
											css;

										if ( bottom && bottom > 0 ) {
											css = 'bottom';
											this.css['bottom'] = bottom + this.um();
										} else {
											css = 'top';
											this.css['top'] = top + this.um();
										}

										if ( right && right > 0 ) {
											css += '|right';
											this.css['right'] = right + this.um();
										} else {
											css += '|left';
											this.css['left'] = left + this.um();
										}

										this.styles = Object.keys( this.css );

										this.$( '.position' ).removeClass( 'active' );
										this.$( '.position[data-value="' + css + '"]' ).addClass( 'active' );

										this.setPosition( css );
									},
									change: function ( $element, dom ) {
										this.css[dom.dataset.style] = dom.value + this.um();

										this.setValue( this.css );

										TVE.Editor_Page.reposition_icons();
									},
									input: function ( $element, dom ) {
										this.change( $element, dom );
									},
									um: function () {
										return 'px';
									}
								} );
							},
							"preview-list.js": function (exports, module, require) {
								var DropPanel = require( './drop-panel' );
								module.exports = require( '../base' ).control.extend( {
									/**
									 * whether or not this is a sortable list
									 */
									_sortable: false,
									/**
									 * Allows extending the template used for rendering items
									 *
									 * @param {Object} attr
									 */
									initialize: function ( attr ) {
										this.$el.addClass( 'tcb-preview-list' );
										this.tpl = attr.tpl || 'controls/preview-list-item';

										if ( attr.model && attr.model.config && attr.model.config.sortable ) {
											this.sortable( true );
										}
									},
									has_settings_icon: function () {
										return this.model && this.model.config && this.model.config.settingsIcon;
									},
									/**
									 * Setup the collection - bind events so that the preview list re-renders on each change
									 *
									 * @param {Backbone.Collection} collection
									 */
									attach_collection: function ( collection ) {
										if ( this.collection ) {
											throw new Error( 'Collection already attached (preview list instance)' );
										}
										this.collection = collection;

										this.listenTo( this.collection, 'add', this.render );
										this.listenTo( this.collection, 'reset', this.render );
										this.listenTo( this.collection, 'remove', this.render );
										this.listenTo( this.collection, 'change', this.render );
									},
									/**
									 * When reading from the node, build the collection that will contain the items
									 */
									update: function () {
										this.collection.reset( this.get_items( this.readFrom() ) );
									},
									/**
									 * This function should be implemented in the extending class
									 *
									 * @param {jQuery} $element current element being edited
									 * @returns {Array}
									 */
									get_items: function ( $element ) {
										throw new Error( 'Preview list: get_items not implemented' );
									},
									/**
									 * Called on each modification on the collection, it updates the preview list
									 */
									render: function () {
										if ( this._sortable && this.$el.data( 'ui-sortable' ) ) {
											this.$el.sortable( 'destroy' );
										}
										this.$el.empty();
										var found = false,
											has_icon = true;
										this.collection.each( function ( item, index ) {
											if ( this.collection.prepare_item ) {
												item.attributes = this.collection.prepare_item( item.attributes );
											}
											item.index = index;
											if ( item.get( '__new' ) ) {
												return true;
											}
											found = true;
											this.$el.append( TVE.tpl( this.tpl, {view: this, item: item} ) );
											if ( ! item.get( 'icon' ) ) {
												has_icon = false;
											}
										}, this );
										if ( ! found ) {
											this.$el.html( TVE.tpl( this.tpl, {no_item: true} ) );
										} else if ( this._sortable ) {
											this.$el.sortable( {
												axis: 'y',
												handle: '.preview-list-sort-handle',
												update: _.bind( this.order_changed, this )
											} );
										}
										if ( ! has_icon ) {
											this.$( '.item-icon' ).remove();
											this.$( '.col-xs-2' ).removeClass( 'col-xs-2' ).addClass( 'col-xs-3' );
										}
									},
									/**
									 * Called when the collection has been ordered
									 *
									 * @param event
									 * @param ui
									 */
									order_changed: function ( event, ui ) {
										var inserted_at = ui.item.index(),
											moved_from = parseInt( ui.item.data( 'index' ) );
										if ( inserted_at === moved_from ) {
											return;
										}

										var moved = this.collection.at( parseInt( ui.item.data( 'index' ) ) );
										this.collection.remove( moved, {silent: true} );
										this.collection.add( moved, {at: inserted_at, silent: true} );

										/* trigger the change event so that all listeners react to the change */
										this.collection.trigger( 'change' );
									},
									/**
									 * Removes an element from the list
									 *
									 * @param {Object} e
									 * @param {DOMNode} btn
									 * @returns {boolean}
									 */
									item_remove: function ( e, btn ) {
										this.collection.remove( this.collection.at( parseInt( btn.getAttribute( 'data-index' ) ) ) );
										DropPanel.close_all();

										return false;
									},
									/**
									 * Triggered when clicking a row
									 *
									 * @param {Object} e
									 * @param {DOMNode} row
									 *
									 * @returns {boolean}
									 */
									item_click: function ( e, row ) {
										this.trigger( 'item_click', this.collection.at( parseInt( row.getAttribute( 'data-index' ) ) ), row );

										return false;
									},
									/**
									 * Sets the sortable option on this control
									 *
									 * @param flag
									 */
									sortable: function ( flag ) {
										this._sortable = ( typeof flag === 'undefined' ? true : flag );

										return this;
									}
								} );
							},
							"rating": {
								"rating-value.js": function (exports, module, require) {
									module.exports = require( '../../base' ).control.extend( {
										template: TVE.tpl( 'controls/rating-value' ),
										/**
										 * setup dropdown intervals
										 */
										after_initialize: function ( attr ) {
											this.$max = this.$( '.rating-max' );
											this.$value = this.$( '.rating-value' );

											this.renderer = attr.component.renderer;

											var max_html = '',
												value_html = '';
											for ( var i = 0.5; i <= this.model.config.max_size; i += 0.5 ) {
												value_html += '<option value="' + i + '">' + i + '</option>';
												if ( parseInt( i ) == i ) {
													max_html += '<option value="' + i + '">' + i + '</option>';
												}
											}

											this.$value.html( value_html ).val( this.model.config.default_value );
											this.$max.html( max_html ).val( this.model.config.default_max );
										},
										/**
										 * Enable / disabled min / max options from <select>s
										 */
										enable_disable: function () {
											var self = this;
											this.$max.find( 'option' ).each( function () {
												this.disabled = parseFloat( this.value ) < self.renderer.data.value;
											} );
											this.$value.find( 'option' ).each( function () {
												this.disabled = parseFloat( this.value ) > self.renderer.data.max;
											} );
										},
										/**
										 * Value / Max changed
										 */
										option_changed: function () {

											this.update_renderer();

											this.enable_disable();
											this.change();
										},
										/**
										 * Triggered any time there is a change in the control
										 */
										change: function () {
											this.renderer.render_to( this.applyTo(), true );
										},
										/**
										 * update the values in the renderer
										 */
										update_renderer: function () {
											this.renderer.set_data( {
												value: parseFloat( this.$value.val() ),
												max: parseFloat( this.$max.val() )
											} );
										},
										/**
										 * Updates the control by reading data from the DOM
										 */
										update: function ( $element ) {
											this.$max.val( $element.attr( 'data-max' ) );
											this.$value.val( $element.attr( 'data-value' ) );
											this.enable_disable();

											this.update_renderer();
										}
									} );
								},
								"style.js": function (exports, module, require) {
									var StylePicker = require( '../style-picker' );
									module.exports = StylePicker.extend( {
										read_from_element: function () {
											var style = this.applyTo().data( 'style' );
											this.renderer.set_data( {style: style} );
											return style;
										},
										item_template: function () {
											return _.template( '<div class="col-xs-6 rating-item"><div class="tve-select-item click" data-fn="select" data-value="<#=key #>"><#=value.html#></div></div>' );
										},
										input: function ( $element ) {
											this.renderer.set_data( {style: this.model.selected} ).render_to( $element );
										},
										cancel: function ( $element ) {
											this.model.selected = this.model.selected_old;
											this.renderer.set_data( {style: this.model.selected_old} ).render_to( $element );
											this.renderer.clear_undo_snapshot();
										},
										onOpen: function ( $element ) {
											this.renderer.take_undo_snapshot( $element );
										},
										apply: function ( $element ) {
											this.renderer.render_to( $element, true );
										}
									} );
								}
							},
							"responsive-video": {
								"style.js": function (exports, module, require) {
									/**
									 * Created by Ovidiu on 5/26/2017.
									 */
									module.exports = require( '../style-picker' ).extend( {
										no_style_class: 'rv_style_none',
										item_template: function () {
											return TVE.tpl( 'controls/responsive-video/style-picker' );
										},
										update: function () {
											var $element = this.applyTo(),
												classes = $element.attr( 'class' ).split( ' ' ),
												selected = this.model.config.default || this.no_style_class;

											for ( var i = 0; i < classes.length; i ++ ) {
												if ( classes[i].substr( 0, 9 ) == 'rv_style_' ) {
													selected = classes[i];
													break;
												}
											}

											this.$( '.tve-select-item' ).removeClass( 'active' ).filter( '[data-value=' + selected + ']' ).addClass( 'active' );
											this.model.selected_old = selected;
											this.component.$( '#responsive-video-style-name' ).val( this.getLabel( selected ) );
										},
										input: function ( $element, dom ) {

											$element.removeClass( function ( index, className ) {
												return (className.match( /(^|\s)rv_style_\S+/g ) || []).join( ' ' );
											} );

											if ( this.model.selected !== this.no_style_class ) {
												$element.addClass( this.model.selected );
											}

										},
										/**
										 * Callback for drop panel apply action
										 */
										apply: function ( $element, dom ) {
											if ( this.model.selected ) {
												this.component.$( '#responsive-video-style-name' ).val( this.getLabel( this.model.selected ) );
											}

											this.undo_manager_api( $element, this.model );
										},
										/**
										 * Callback for drop panel cancel action
										 */
										cancel: function ( $element, dom ) {
											if ( this.model.selected && this.model.selected !== this.no_style_class ) {
												$element.removeClass( this.model.selected );
											}

											if ( this.model.selected_old && this.model.selected_old !== this.no_style_class ) {
												$element.addClass( this.model.selected_old );
											}

											this.undo_manager_api( $element, this.model );
										},
										/**
										 * Undo Manager API
										 *
										 * @param $element
										 * @param model
										 */
										undo_manager_api: function ( $element, model ) {
											var self = this,
												selected = (model.selected && model.selected !== this.no_style_class) ? model.selected : '',
												selected_old = (model.selected_old && model.selected_old !== this.no_style_class) ? model.selected_old : '';

											TVE.UndoManager.add( {
												undo: function () {
													this.undo_redo();
												},
												redo: function () {
													this.undo_redo();
												},
												undo_redo: function () {
													if ( $element.is( '[class*="rv_style_"]' ) ) {
														$element.removeClass( selected ).addClass( selected_old );
														if ( TVE.ActiveElement ) {
															self.update();
														}
													} else {
														$element.addClass( selected ).removeClass( selected_old );
														if ( TVE.ActiveElement ) {
															self.update();
														}
													}
												}
											} );
										}

									} );
								},
								"video.js": function (exports, module, require) {
									/**
									 * Created by Ovidiu on 5/22/2017.
									 */
									var VideoControls = require( '../../components/responsive-video/video-controls' ),
										base = require( '../../base' ),
										tinycolor = require( '../../../libs/tinycolor' );

									/** @var {VideoBackground} */
									module.exports = base.control.extend( {
										activeElement: null,
										videoOverlaySVG: '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><title>play</title><path fill="#fff" d="M18.659 4.98c-0.889-1.519-2.12-2.75-3.593-3.614l-0.047-0.025q-2.298-1.341-5.020-1.341t-5.019 1.341c-1.52 0.889-2.751 2.12-3.614 3.593l-0.025 0.047q-1.341 2.298-1.341 5.020t1.341 5.020c0.889 1.519 2.12 2.75 3.593 3.614l0.047 0.025q2.298 1.341 5.020 1.341t5.020-1.341c1.519-0.889 2.75-2.12 3.614-3.593l0.025-0.047q1.341-2.298 1.341-5.020t-1.341-5.020zM15 10.716l-7.083 4.167c-0.118 0.074-0.262 0.117-0.416 0.117-0 0-0 0-0.001 0h0c-0.153-0.002-0.296-0.040-0.422-0.107l0.005 0.002q-0.417-0.247-0.417-0.729v-8.333q0-0.482 0.417-0.729 0.43-0.234 0.833 0.013l7.084 4.167q0.416 0.234 0.416 0.716t-0.416 0.716z"></path></svg>',
										/**
										 * Triggered when an element is selected
										 */
										update: function ( $element ) {
											this.activeElement = $element;
											var self = this,
												provider = this.get_attribute( 'type' ),
												startTime = this.get_attribute( 'start-time' );

											this.model = new Backbone.Model( this.read() );
											this.video_settings.set_model( this.model );

											if ( $element.hasClass( 'tcb-elem-placeholder' ) ) {
												this.$( '.v-source' ).val( 'youtube' ).trigger( 'change' );
												this.set_attribute( 'type', 'youtube', $element );
											}

											if ( typeof startTime === 'undefined' || startTime === '0' ) {
												this.$( '.tve-time-control input' ).val( 0 );
											} else {
												this.$( '.tve-time-control[data-time="Minute"] input' ).val( parseInt( startTime / 60 ) );
												this.$( '.tve-time-control[data-time="Second"] input' ).val( parseInt( startTime % 60 ) );
											}

											/**
											 * Set checkboxes to checked
											 */
											this.$( '#r-v-checkbox-settings-' + provider ).find( 'input[type="checkbox"]' ).each( function ( checkbox ) {
												var attr = this.getAttribute( 'data-elem-attr' ),
													attrChecked = this.getAttribute( 'data-elem-attr-val' );

												this.checked = false;
												if ( self.get_attribute( attr ) === attrChecked ) {
													this.checked = true;
												}
												if ( attr === 'autoplay' ) {
													self.show_hide_video_thumbnail_options( this.checked );
												}
											} );

											if ( this.activeElement.find( '.video_overlay ' ).hasClass( 'video_overlay_image' ) ) {

												var bg = this.activeElement.find( '.video_overlay ' ).css( 'background-image' ),
													name = '1234567';
												bg = bg.replace( 'url(', '' ).replace( ')', '' ).replace( /\"/gi, '' );
												if ( bg.length > 0 ) {
													name = bg.split( '/' ).slice( - 1 )[0];
												}

												this.video_settings.set_thumbnail( {id: _.random( 1, 1000 ), title: name} );
											} else {
												this.video_settings.set_thumbnail( null );
											}

											this.show_hide_provider_options( provider );
										},

										/**
										 * Reads element configuration and returns an object with a specific configuration
										 *
										 * @returns {{config: {p: {}}}}
										 */
										read: function () {
											var $element = this.applyTo(),
												data = {p: {}},
												$custom = $element.find( 'video.tcb-responsive-video' ).first(),
												$iframe = $element.find( 'iframe' ).first();

											if ( $custom.length ) {
												var $source = $custom.find( 'source' );

												data.s = 'custom';
												data.p = {
													id: $custom.attr( 'data-id' ),
													title: $custom.attr( 'data-title' ),
													attachment: {
														id: $custom.attr( 'data-id' ),
														title: $custom.attr( 'data-title' ),
														url: $source.attr( 'src' ),
														mime: $source.attr( 'type' )
													}
												}
											} else if ( $iframe.length ) {
												data.s = this.get_attribute( 'type' );
												data.p = {
													c: this.get_attribute( 'video-color' ),
													id: $iframe.attr( 'data-code' ),
													url: this.get_attribute( 'url' )
												}
											}

											return {
												config: data
											};
										},

										/**
										 * Triggered when there is a change in the control
										 */
										input: function ( checked, skip_undo ) {
										},

										clear: function ( $element ) {
											$element = typeof $element !== 'undefined' ? $element : this.applyTo();
											$element.removeClass( 'tcb-elem-placeholder' );
											$element.find( '.tcb-inline-placeholder-action' ).remove();
											$element.find( '.tve_responsive_video-no_video' ).remove();
											$element.find( '.tve_responsive_video_container' ).removeAttr( 'style' );
											$element.find( 'iframe,video,script,.wistia_embed' ).remove();
										},
										/**
										 * Initializes the video controls, the same options as in the animation component
										 */
										after_initialize: function ( args ) {
											this.video_settings = new VideoControls( {
												config: {
													'component_controls': args.component.controls
												}
											} );

											this.$el.append( this.video_settings.$el.addClass( 'video-options' ) );
											this.video_settings.on( 'change', _.bind( this.apply, this ) );
											this.video_settings.on( 'start-time-changed', _.bind( this.start_time_changed, this ) );
											this.video_settings.on( 'color-change', _.bind( this.color_changed, this ) );
											this.video_settings.on( 'thumbnail-changed', _.bind( this.thumbnail_changed, this ) );
											this.video_settings.on( 'thumbnail-removed', _.bind( this.thumbnail_removed, this ) );
										},
										extra_settings_changed: function ( event, dom ) {
											var data_setting = dom.getAttribute( 'data-elem-attr' ),
												data_value = dom.checked ? dom.getAttribute( 'data-elem-attr-val' ) : dom.getAttribute( 'data-elem-attr-val-unchecked' );

											this.set_attribute( data_setting, data_value );

											if ( data_setting === 'autoplay' ) {
												this.show_hide_video_thumbnail_options( dom.checked );
											}

											this.apply();
										},
										start_time_changed: function ( $element ) {
											var min = parseInt( this.$( '.tve-time-control[data-time="Minute"]' ).find( 'input' ).val() ),
												sec = parseInt( this.$( '.tve-time-control[data-time="Second"]' ).find( 'input' ).val() );

											this.set_attribute( 'start-time', 60 * min + sec, $element );
											this.apply();
										},

										/**
										 * Color change event that is fired from provider control
										 *
										 * @param color
										 */
										color_changed: function ( color ) {
											this.set_attribute( 'video-color', color.toRgbString() );

											this.apply();
										},

										thumbnail_changed: function ( wpAttachment ) {
											this.set_attribute( 'overlay', 1 );
											this.activeElement.find( '.video_overlay' ).addClass( 'video_overlay_image' ).html( '<span class="overlay_play_button">' + this.videoOverlaySVG + '</span>' );
											this.activeElement.find( '.video_overlay' ).css( {
												'background-image': "url('" + wpAttachment.url + "')",
												'background-repeat': 'no-repeat',
												'background-size': 'cover',
												'background-position': 'center'
											} ).attr( {
												'data-width': wpAttachment.width,
												'data-height': wpAttachment.height
											} );
										},

										thumbnail_removed: function () {
											this.set_attribute( 'overlay', 0 );
											this.activeElement.find( '.video_overlay' ).removeClass( 'video_overlay_image' ).html( '' );
											this.activeElement.find( '.video_overlay' ).removeAttr( 'data-width' ).removeAttr( 'data-height' ).removeAttr( 'style' );
										},

										show_hide_provider_options: function ( provider ) {

											this.$( '.responsive-video-time-settings' ).hide();
											this.$( '.r-v-checkbox-settings' ).hide();

											if ( provider === 'youtube' || provider === 'wistia' ) {
												this.$( '.responsive-video-time-settings' ).show();
											}
											this.$( '.r-v-checkbox-settings[data-setting="' + provider + '"]' ).show();
										},

										/**
										 * Show / Hide Video Thumbnail Options
										 *
										 * @param autoplay
										 */
										show_hide_video_thumbnail_options: function ( autoplay ) {
											var $videoThumbnail = this.$el.find( '.tcb-responsive-video-thumbnail' );
											if ( autoplay ) {
												this.video_settings.videoThumbnail.file_picker.remove();
												$videoThumbnail.addClass( 'tcb-hidden' );
											} else {
												$videoThumbnail.removeClass( 'tcb-hidden' );
											}
										},

										/**
										 * Changes the video provider and updates the data type attribute
										 *
										 * @param $element
										 * @param dom
										 * @param event
										 */
										video_provider_changed: function ( $element, dom, event ) {

											/**
											 * Remove all data attributes
											 */
											TVE.removeDataAttributes( $element );

											/**
											 * Empty all provider URLs
											 */
											this.$( '.tve_provider_url' ).val( '' );

											/**
											 * reset the video content
											 */
											if ( ! this.activeElement.hasClass( 'tcb-elem-placeholder' ) ) {
												this.clear( this.activeElement );

												/*Element Filler. So that the user sees something on screen*/
												$element.find( '.tve_responsive_video_container' ).append( '<div class="tve_responsive_video-no_video">' + TVE.icon( 'video-player', 'svg', 'editor' ) + '</div>' ); //'<iframe style="background-color:#f0f3f3;">' + TVE.icon( 'trash' ) + '</iframe>'
											}

											/**
											 * Uncheck all hidden checkboxes
											 */
											this.$( 'input[type="checkbox"]:hidden' ).each( function () {
												this.checked = false;
											} );

											/**
											 * Removed Video Thumbnail
											 */
											this.video_settings.videoThumbnail.file_picker.remove();

											/**
											 *  Show Video Thumbnail Options
											 */
											this.$( '.tcb-responsive-video-thumbnail' ).removeClass( 'tcb-hidden' );

											this.show_hide_provider_options( dom.value );

											this.set_attribute( 'type', dom.value, $element );
										},

										/**
										 * Applies the video settings
										 */
										apply: function ( setAttributes ) {
											var $element = this.applyTo(),
												code = this.video_settings.get_embed_code( 'responsive', this.queryString( this.get_attribute( 'type' ) ) );

											this.clear( $element );

											if ( ! code ) {
												$element.find( '.tve_responsive_video_container' ).append( '<div class="tve_responsive_video-no_video">' + TVE.icon( 'video-player', 'svg', 'editor' ) + '</div>' );
												return this;
											}

											$element.find( '.tve_responsive_video_container' ).append( code );

											this.set_attribute( 'url', this.$el.find( '.tve_provider_url:visible' ).val() );

											return this;
										},
										queryString: function ( type ) {
											var queryString = '?',
												options,
												tcolor = new tinycolor( this.get_attribute( 'video-color' ) );

											switch ( type ) {
												case 'youtube':
													options = [
														'rel=' + (typeof this.get_attribute( 'rel' ) === 'undefined' ? '1' : this.get_attribute( 'rel' )),
														'modestbranding=' + (typeof this.get_attribute( 'modestbranding' ) === 'undefined' ? '0' : this.get_attribute( 'modestbranding' )),
														'controls=' + (typeof this.get_attribute( 'controls' ) === 'undefined' ? '1' : this.get_attribute( 'controls' )),
														'showinfo=' + (typeof this.get_attribute( 'showinfo' ) === 'undefined' ? '1' : this.get_attribute( 'showinfo' )),
														// 'autoplay=' + (typeof this.config('autoplay') === 'undefined' ? '0' : this.config('autoplay')),
														'fs=' + (typeof this.get_attribute( 'fs' ) === 'undefined' ? '1' : this.get_attribute( 'fs' )),
														'wmode=transparent'
													];
													if ( typeof this.get_attribute( 'start-time' ) !== 'undefined' && this.get_attribute( 'start-time' ) !== '0' ) {
														options.push( 'start=' + this.get_attribute( 'start-time' ) );
													}
													queryString += options.join( '&' );
													break;

												case 'wistia':

													options = [
														'chromeless=false', //+ (typeof this.get_attribute( 'controls' ) === 'undefined' ? 'false' : this.get_attribute( 'controls' ) === '0'),
														'controlsVisibleOnLoad=' + (typeof this.get_attribute( 'onload-controls' ) === 'undefined' ? 'true' : this.get_attribute( 'onload-controls' ) === '1'),
														'playbar=' + (typeof this.get_attribute( 'play-bar' ) === 'undefined' ? 'true' : this.get_attribute( 'play-bar' ) === '1'),
														//'autoPlay=' + (typeof this.config('autoplay') === 'undefined' ? 'false' : this.config('autoplay') === '1'),
														'fullscreenButton=' + (typeof this.get_attribute( 'fs' ) === 'undefined' ? 'true' : this.get_attribute( 'fs' ) === '1'),
														'playerColor=' + (typeof this.get_attribute( 'video-color' ) === 'undefined' ? 'fff' : tcolor.toHex()),
														'videoFoam=true'
													];
													var embed_type = this.get_attribute( 'embed_type' );
													if ( typeof this.get_attribute( 'start-time' ) !== 'undefined' && this.get_attribute( 'start-time' ) !== '0' && embed_type !== 'popover' ) {
														options.push( 'time=' + this.get_attribute( 'start-time' ) );
													}
													if ( embed_type === 'popover' ) {
														options.push( 'popover=true popoverAnimateThumbnail=true' );
														queryString += options.join( ' ' );
													} else {
														queryString += options.join( '&' );
													}
													break;
												case 'vimeo':

													options = [
														//'autoplay=' + (typeof this.config('autoplay') === 'undefined' ? '0' : this.config('autoplay')),
														'badge=' + (typeof this.get_attribute( 'modestbranding' ) === 'undefined' ? '1' : this.get_attribute( 'modestbranding' )),
														'title=' + (typeof this.get_attribute( 'showinfo' ) === 'undefined' ? '0' : this.get_attribute( 'showinfo' )),
														'color=' + (typeof this.get_attribute( 'video-color' ) === 'undefined' ? 'fff' : tcolor.toHex())
													];
													queryString += options.join( '&' );
													break;
												case 'custom':
													queryString = ''; // Override the '?'
													if ( typeof this.get_attribute( 'controls' ) === 'undefined' || this.get_attribute( 'controls' ) === '1' ) {
														queryString += ' controls="controls" '
													}
													if ( typeof this.get_attribute( 'loop' ) !== 'undefined' && this.get_attribute( 'loop' ) === '1' ) {
														queryString += ' loop '
													}

													break;
												default:
													queryString = '';
											}

											return queryString;
										},
										/**
										 * Returns a data attribute value
										 *
										 * @param what
										 * @returns {*}
										 */
										get_attribute: function ( what ) {
											return this.activeElement.attr( 'data-' + what );
										},

										/**
										 * Sets a data attribute
										 *
										 * @param what
										 * @param val
										 * @param $element
										 */
										set_attribute: function ( what, val, $element ) {
											$element = typeof $element === 'undefined' ? this.activeElement : $element;
											$element.attr( 'data-' + what, val );
										}
									} );
								}
							},
							"select-multiple.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 5/31/2017.
								 */
								var base = require( '../base' );

								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/select-multiple' ),
									initialize: function ( args ) {
										var self = this;
										this.render();

										this.$select = this.$el.find( 'select' );

										if ( this.$select.data( 'select2' ) ) {
											this.$select.select2( 'destroy' );
										}

										if ( typeof args.model.config.no_results === 'undefined' ) {
											args.model.config.no_results = 'No Results Found';
										}

										if ( typeof args.model.config.remote === 'undefined' ) {
											return;
										}

										if ( args.model.config.remote === true ) {

											this.$select.select2( {
												minimumInputLength: args.model.config.min_input_length,
												multiple: true,
												tags: args.model.config.tags, //TAGS: true or false. If set to false, new values can not be created
												ajax: {
													url: TVE.CONST.ajax_url,
													type: 'POST',
													dataType: 'json',
													data: function ( obj ) {
														return {
															term: obj.term, // search term
															action: TVE.CONST.ajax.action,
															custom: args.model.config.custom_ajax,
															nonce: TVE.CONST.nonce
														};
													},
													delay: 250,
													processResults: function ( data ) {
														return {
															results: data
														};
													},
													cache: true
												},
												language: {
													noResults: function () {
														return args.model.config.no_results;
													}
												}
											} );

										} else {

											this.$select.select2( {
												tags: args.model.config.tags, //TAGS: true or false. If set to false, new values can not be created
												multiple: true,
												minimumInputLength: args.model.config.min_input_length,
												data: args.model.config.data,
												language: {
													noResults: function () {
														return args.model.config.no_results;
													}
												},
												escapeMarkup: function ( markup ) {
													/**
													 * Allow markup in text messages: ex no results
													 */
													return markup;
												}
											} )
										}

										this.$select.on( 'select2:select', function ( e ) {
											var data = jQuery( this ).select2( 'data' );
											self.changed( jQuery( this ).select2( 'data' ) );
										} ).on( 'select2:unselect', function ( evt ) {
											self.changed( jQuery( this ).select2( 'data' ) );

											if ( ! evt.params.originalEvent ) {
												return;
											}
											evt.params.originalEvent.stopPropagation();
										} );
									},
									/**
									 * Wrapper for select change function
									 *
									 * @param valueArr - array
									 */
									changed: function ( valueArr ) {
										this.change( this.applyTo(), valueArr );
									},
									/**
									 * Return the value, as an array from the select
									 *
									 * @returns {*}
									 */
									getValue: function () {
										return this.$select.val();
									},
									/**
									 * Sets the select 2 value
									 *
									 * @param value - array
									 */
									setValue: function ( value ) {
										this.$select.val( value ).trigger( 'change' );
									},

									/**
									 * Sets value to a select that has data from remote location (dynamically from server)
									 */
									setValueRemote: function ( values ) {
										var _ids = [];
										this.$select.empty();

										_.each( values, function ( _val ) {
											_ids.push( _val.id );
											this.$select.append( '<option value="' + _val.id + '">' + _val.text + '</option>' );
										}, this );

										this.$select.val( _ids ).trigger( 'change' );
									}
								} );
							},
							"select.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/select' ),
									initialize: function () {
										this.render();

										this.$select = this.$el.find( 'select' );
									},
									changed: function ( event, dom ) {
										this.change( this.applyTo(), dom );
									},
									getValue: function () {
										return this.$select.val();
									},
									setValue: function ( value ) {
										this.$select.val( value );
									}

								} );
							},
							"shadow.js": function (exports, module, require) {
								var base = require( '../base' ),
									ColorPicker = require( './color-picker' ),
									Knob = require( './knob' ),
									Slider = require( './slider' ),
									DropPanel = require( './drop-panel' );

								module.exports = DropPanel.extend( {
									template: TVE.tpl( 'controls/shadow' ),
									after_initialize: function () {
										var self = this;
										this.controls = {
											ShadowColor: new ColorPicker( {
												el: this.$el.find( '.tve-shadow-color' ),
												model: {
													config: {
														default: 'rgba(0,0,0,0.4)',
														options: {
															showInput: true,
															showGradient: true
														},
														icon: true
													}
												}
											} ),
											ShadowDistance: new Slider( {
												el: this.$el.find( '.tve-shadow-distance' ),
												model: {
													config: {
														default: '3',
														min: '0',
														max: '100',
														label: 'Distance',
														um: ['px']
													}
												}
											} ),
											ShadowBlur: new Slider( {
												el: this.$el.find( '.tve-shadow-blur' ),
												model: {
													config: {
														default: '2',
														min: '0',
														max: '100',
														label: 'Blur',
														um: ['px']
													}
												}
											} ),
											ShadowAngle: new Knob( {
												el: this.$el.find( '.tve-shadow-angle' ),
												model: {
													config: {
														default: '320',
														min: '0',
														max: '359',
														label: 'Angle',
														um: ['DEG']
													}
												}
											} )

										};
										this.controls.ShadowDistance.input = this.controls.ShadowDistance.change = function ( $element, dom ) {
											var angle = self.model.get( 'angle' );
											self.model.set( 'distance', dom.value );
											self.model.set( 'horizontal', Math.round( dom.value * Math.cos( angle * (Math.PI / 180) ) ) );
											self.model.set( 'vertical', Math.round( - dom.value * Math.sin( angle * (Math.PI / 180) ) ) );
											self.change( true );
										};
										this.controls.ShadowAngle.input = this.controls.ShadowAngle.change = function ( $element, dom ) {
											var distance = self.model.get( 'distance' );
											self.model.set( 'angle', dom.value );
											self.model.set( 'horizontal', Math.round( distance * Math.cos( dom.value * (Math.PI / 180) ) ) );
											self.model.set( 'vertical', Math.round( - distance * Math.sin( dom.value * (Math.PI / 180) ) ) );
											self.change( true );

										};

										this.controls.ShadowColor.change = this.controls.ShadowColor.input = function ( color ) {
											self.model.set( 'color', color );
											self.change( true );
										};
										this.controls.ShadowBlur.input = this.controls.ShadowBlur.change = function ( $element, dom ) {
											self.model.set( 'blur', dom.value );
											self.change( true );
										};

										if ( ! this.simplified ) {
											this.controls.ShadowSpread = new Slider( {
												el: this.$el.find( '.tve-shadow-spread' ),
												model: {
													config: {
														default: '0',
														min: '-50',
														max: '50',
														label: 'Spread',
														um: ['px']
													}
												}
											} );
											this.controls.ShadowSpread.input = this.controls.ShadowSpread.change = function ( $element, dom ) {
												self.model.set( 'spread', dom.value );
												self.change( true );
											};
										}

									},
									update: function () {

									},
									getCollection: function () {
										return this.collection;
									},
									setCollection: function ( collection ) {
										this.collection = collection;
									},

									/**
									 * Update drop pannel controlls
									 */
									updateControls: function ( model, inner, config ) {
										this.model = null;
										if ( model ) {
											this.model = model;
										} else {
											this.config = config;
											this.model = this.getDefaultModel( inner );
											this.collection.add( this.model );
											this.collection.trigger( 'change-attributes' );
										}
										this.toSettings( this.model );
										this.controls.ShadowAngle.setValue( this.model.get( 'angle' ) );
										this.controls.ShadowDistance.setValue( this.model.get( 'distance' ) );
										if ( this.model.get( 'color' ) ) {
											this.controls.ShadowColor.setValue( this.model.get( 'color' ) );
										}
										this.controls.ShadowBlur.setValue( this.model.get( 'blur' ) );

										if ( ! this.simplified ) {
											this.controls.ShadowSpread.setValue( this.model.get( 'spread' ) );
										}

									},

									/**
									 * Trigger update css on affected element (also handles preview)
									 */
									change: function ( skip_undo ) {
										this.collection.trigger( 'change-attributes', skip_undo );
									},

									/**
									 * Set angle and distance from offsets
									 */
									toSettings: function ( model ) {
										var x = model.get( 'horizontal' ),
											y = model.get( 'vertical' ),
											distance = Math.ceil( Math.sqrt( Math.pow( x, 2 ) + Math.pow( y, 2 ) ) ), // Pythagoras theorem to calculate hypotenuse
											angle = Math.floor( this.getAngle( x, y ) );
										this.model.set( 'distance', distance );
										this.model.set( 'angle', angle );
									},

									/**
									 * Transform offsets to angle
									 */
									getAngle: function ( x, y ) {
										var theta = Math.atan2( y, x ); // Calculate opposite of required angle | range (-PI, PI]
										theta *= 180 / Math.PI; // Get angle rads to degs, range (-180, 180]
										if ( theta < 0 ) {
											theta = 360 + theta;
										} // Transform range to [0, 360) [-180, 0) becomes [180, 360)
										return (360 - theta); // return required angle
									},

									/**
									 * Create standard model out of default settings
									 */
									getDefaultModel: function ( inner ) {
										var model = new Backbone.Model(),
											distance, color, angle, spread, blur;
										if ( ! this.config.angle ) {
											distance = this.controls.ShadowDistance.getDefault();
											color = this.controls.ShadowColor.getDefault();
											angle = this.controls.ShadowAngle.getDefault();
											spread = this.controls.ShadowSpread.getDefault();
											blur = this.controls.ShadowBlur.getDefault();
										} else {
											distance = this.config.distance;
											color = this.config.color;
											angle = this.config.angle;
											spread = this.config.spread;
											blur = this.config.blurr;
										}

										model.set( 'blur', blur );
										if ( ! this.simplified ) {
											model.set( 'spread', spread );
										}
										model.set( 'color', color );
										model.set( 'inner', inner == 'inner' ? 'inset' : '' );
										model.set( 'index', 'new' );
										model.set( 'distance', distance );
										model.set( 'angle', angle );
										model.set( 'horizontal', Math.round( distance * Math.cos( angle * (Math.PI / 180) ) ) ); // Pythagoras theorem to calculate triangle side next to known angle
										model.set( 'vertical', Math.round( - distance * Math.sin( angle * (Math.PI / 180) ) ) ); // Pythagoras theorem to calculate triangle side opposite of known angle

										return model;

									},

									/**
									 * Handle Cancel action
									 */
									cancel: function () {
										this.collection.trigger( 'cancel-changes', this.model );
									},

									/**
									 * Handle Apply action
									 */
									apply: function () {
										this.collection.trigger( 'apply-changes' );
									}
								} );
							},
							"slider.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/slider' ),
									initialize: function () {
										this.render();
										this.umInit();

										var self = this;

										if ( this.model.config.um.length === 1 ) {
											this.$( '.input-um' ).show();
										}

										var skip_state,
											$input = this.$( '.tve-input' );
										this.$( '.handle' ).tve_draggable( {
											start: function () {
												self.currentValue = isNaN( self.value( false ) ) ? 0 : parseInt( self.value( false ) );
												skip_state = TVE.SKIP_CSS_STATE;
											},
											move: function ( delta ) {
												var value = self.currentValue + parseInt( delta );

								//				if ( typeof self.model.config.min !== 'undefined' ) {
								//					value = value < self.model.config.min ? self.model.config.min : value;
								//				}
								//
								//				if ( typeof self.model.config.max !== 'undefined' ) {
								//					value = value > self.model.config.max ? self.model.config.max : value;
								//				}

												if ( typeof $input.attr( 'min' ) !== 'undefined' ) {
													value = value < $input.attr( 'min' ) ? $input.attr( 'min' ) : value;
												}

												if ( typeof $input.attr( 'max' ) !== 'undefined' ) {
													value = value > $input.attr( 'max' ) ? $input.attr( 'max' ) : value;
												}


												TVE.SKIP_CSS_STATE = true;
												self.setValue( value + self.getUM(), true );
											},
											stop: function () {
												TVE.SKIP_CSS_STATE = skip_state;
												self.$( '.tve-input' ).trigger( 'change' );
											}
										} );
									},
									umInit: function () {
										var config = this.model.config,
											um = this.getUM().toLowerCase(),
											$input = this.$( '.tve-input, .tve-slider' ),
											min = 0, max = '', step = 1;

										switch ( um ) {
											case 'px':
												min = config.min || min;
												max = config.max;
												step = config.step || step;
												break;
											case 'em':
												max = 8;
												step = 0.05;
												break;
											case 'vw':
												max = 100;
												min = 0;
												step = 0.1;
												break;
											case 'vh':
												max = 100;
												min = 0;
												step = 0.1;
												break;
											case 'deg':
												max = 90;
												min = 0;
												step = 0.1;
												break;
											case '%':
												max = 100;
												break;
										}

										$input.attr( 'min', min );
										$input.attr( 'max', max );
										$input.attr( 'step', step );
										if ( this.isDefault && this.isDefault() ) {
											$input.filter( '.tve-slider' ).val( max );
										}
									},
									umChange: function ( $element, dom ) {
										var um = dom.getAttribute( 'data-value' );

										this.setUM( um );
										this.convertUM( um );
										this.change( this.applyTo(), this.$( '.tve-input' )[0] );
									},
									/**
									 * Convert value of the input to the selected unit of measure
									 * @param um
									 */
									convertUM: function ( um ) {
										var element = this.readFrom()[0],
											context = (element == TVE.ActiveElement[0]) ? TVE.ActiveElement.parent()[0] : TVE.ActiveElement[0],
											$input = this.$( '.tve-input, .tve-slider' ),
											newVal,
											selection = TVE.froala.has_selection();

										if ( selection ) {
											element = selection;
											context = TVE.ActiveElement[0];
										}

										newVal = TVE.convertUM( element, um, context, this.model.config.css );

										$input.val( newVal );

									},
									setUM: function ( um ) {
										if ( this.model.config.um.indexOf( um ) === - 1 ) {
											return;
										}

										this.$( '.tve-input-um.active' ).removeClass( 'active' );

										this.$( '.tve-input-um[data-value="' + um + '"]' ).addClass( 'active' );

										this.umInit();
									},
									value: function ( um ) {
										var m = um ? this.getUM() : '';
										return this.$( '.tve-input' ).val() + m;
									},
									getUM: function () {
										return this.$( '.tve-input-um.active' ).data( 'value' ) || this.model.config.um[0];
									},
									onChange: function ( $element, dom ) {
										this.setValue( dom.value + this.getUM() );

										TVE.SkipUpdate = false;
										/* triggered only when the user exits the input */
										this.change( $element, dom );
									},
									onInput: function ( $element, dom ) {
										/* make sure we have the same value on both the input and the slider */
										this.$( 'input' ).val( dom.value );
										/* Don't allow the component to update on user input */
										TVE.SkipUpdate = true;

										this.input( $element, dom );
										TVE.Editor_Page.reposition_icons();
									},
									/**
									 * Read the unit of measure from the value to set
									 * @param value
									 * @returns {string}
									 */
									readUM: function ( value ) {
										if ( value == parseFloat( value ) ) {
											return 'px';
										}

										var um = 'px',
											match = /^([+-]?(?:\d+|\d*\.\d+))([a-z]*|%)$/.exec( value );

										if ( match && match[2] ) {
											um = match[2];
										}

										return um;
									},
									/**
									 * Set value for the slider and input
									 * @param value
									 * @param trigger {Boolean} trigger change on inputs
									 */
									setValue: function ( value, trigger ) {
										this.setUM( this.readUM( value ) );

										value = parseFloat( value );

										if ( value == parseInt( value ) ) {
											value = parseInt( value );
										}

										if ( isNaN( value ) ) {
											return;
										}

										this.$( '.tve-input' ).val( value );
										this.$( '.tve-slider' ).val( value );

										if ( trigger ) {
											this.$( '.tve-input' ).trigger( 'change' );
										}
									},
									up: function () {
										this.setValue( (this.value( false ) - (- 1)) + this.getUM(), true );
									},
									down: function () {
										this.setValue( (this.value( false ) - 1) + this.getUM(), true );
									}
								} );
							},
							"social": {
								"network-options.js": function (exports, module, require) {
									(function ( $ ) {
										var DropPanel = require( '../drop-panel' ),
											watcher = require( '../../../libs/watcher' ),
											ImagePicker = require( '../file' ),
											base = require( '../../base' ),
											Networks = {},
											Base = DropPanel.extend( {
												template: TVE.tpl( 'controls/social/network-settings' ),
												events: function () {
													return _.extend( DropPanel.prototype.events, {
														'change [data-setting]': 'change_value'
													} );
												},
												before_initialize: function ( attr ) {
													this.data = {};
													this.network = attr.network;
												},
												after_initialize: function ( attr ) {
													var self = this;

													if ( this._tpl ) {
														this.$( '.n-settings' ).append( this._tpl() );
													}

													this.$( '[data-setting]' ).each( function () {
														var k = this.getAttribute( 'data-setting' );
														watcher( self.data, k, self.value_changed, self )
													} );

													if ( this.after_init ) {
														this.after_init();
													}

													this.$m = this.$( '.inline-message' );
												},
												change_value: function ( e ) {
													var input = e.currentTarget;
													watcher.skip_one();
													this.data[input.getAttribute( 'data-setting' )] = this.$( input ).val();
												},
												value_changed: function ( prop, value ) {
													this.$( '[data-setting="' + prop + '"]' ).val( value );
												},
												update: function ( $element ) {
													this.$element = $element;
													this.read_from_element();
													var cfg = {};
													cfg[this.network] = this.data;
													this.component.renderer.set_config( cfg );
												},
												set_model: function ( model ) {
													this.$( '.n-title' ).html( model.get( 'label' ) );
													this.$( '[data-setting]' ).first().focus();
													this.read_from_element();

													return this;
												},
												read_from_element: function () {
													var $item = this.$element.find( '.tve_s_' + this.network );
													this.data.label = $item.attr( 'data-label' );
													this.data.href = $item.attr( 'data-href' );

													if ( this.read_specific ) {
														this.read_specific( $item );
													}
												},
												apply: function ( $element ) {
													this.trigger( 'apply', $element, this.data );
												},
												cancel: function () {

												},
												message: function ( message, state ) {
													if ( ! message ) {
														this.$m.hide();

														return this;
													}
													state = state || 'info';
													this.$m.removeClass( 'm-success m-info m-error' ).addClass( 'm-' + state ).empty().show();
													if ( state === 'success' || state === 'error' ) {
														message = TVE.icon( state === 'success' ? 'check' : 'close2' ) + '&nbsp;' + message;
													}
													this.$m.html( message );

													return this;
												}
											} );

										module.exports = {
											fb_share: Base.extend( {
												_tpl: TVE.tpl( 'controls/social/fb-share' ),
												after_init: function () {
													this.image_picker = new ImagePicker( {} );
													this.$( '.fb-image-upload' ).append( this.image_picker.$el );
													this.listenTo( this.image_picker, 'select', function ( selection ) {
														this.data.image = selection.url;
													} );
													this.listenTo( this.image_picker, 'remove', function () {
														this.data.image = '';
													} );
													this.app_id = TVE.CONST.social_fb_app_id;
													this.app_valid = ! ! this.app_id;
												},
												read_specific: function ( $element ) {
													_.each( ['name', 'caption', 'description'], function ( field ) {
														this.data[field] = $element.attr( 'data-' + field );
													}, this );

													this.image_picker.set( {url: $element.attr( 'data-image' ) || ''} );
												},
												validate_app_id: function ( e, input ) {
													this.app_id = input.value;
													this.app_valid = false;
													if ( ! this.app_id ) {
														this.message( TVE.t.fb_app_id_required, 'error' );
														return;
													}
													this.message( TVE.t.validating_app_id, 'info' );
													var self = this;
													$.ajax( {
														url: 'https://graph.facebook.com/' + this.app_id,
														dataType: 'json',
														xhrFields: {
															withCredentials: false
														},
														crossDomain: true
													} ).done( function ( response ) {
														if ( response.id ) {
															self.app_valid = true;
															TVE.CONST.social_fb_app_id = self.app_id;
															self.message( TVE.t.fb_app_id_valid, 'success' );
															/** save it directly to the server */
															TVE.ajax( 'update_option', 'post', {
																option_name: 'tve_social_fb_app_id',
																option_value: self.app_id
															} );
														} else {
															self.message( TVE.t.fb_app_id_invalid, 'error' );
														}
													} ).error( function () {
														self.message( TVE.t.fb_app_id_invalid, 'error' );
													} );
												},
												validate: function () {
													if ( ! this.app_valid ) {
														this.message( TVE.t.fb_app_id_invalid, 'error' );

														return false;
													}

													return true;
												}
											} ),
											t_share: Base.extend( {
												_tpl: TVE.tpl( 'controls/social/t-share' ),
												after_init: function () {
													this.$tweet = this.$( 'textarea.tweet' );
													this.$via = this.$( '.via' );
												},
												read_specific: function ( $item ) {
													this.data.tweet = $item.attr( 'data-tweet' );
													this.data.via = ( $item.attr( 'data-via' ) || '' ).replace( /^@/, '' );
													this.$m.hide();
													this.char_count();
												},
												char_count: function () {
													var remaining = 140,
														via = this.$via.val(),
														tweet = this.$tweet.val();

													var url = this.data.href || location.href;

													/**
													 * t.co shortened links
													 * @type {number}
													 */
													remaining -= url.match( /^https/ ) ? 23 : 22;
													remaining -= tweet.length + 1; // space between text and link
													remaining -= via ? 6 + via.replace( '@', '' ).length : 0;

													this.$( '#t-counter' ).css( 'color', remaining < 0 ? '#ff8484' : '' ).html( remaining );
													this.remaining = remaining;
												},
												validate: function () {
													if ( this.remaining < 0 ) {
														this.message( TVE.t.tweet_too_long, 'error' );

														return false;
													}

													return true;
												}
											} ),
											pin_share: Base.extend( {
												_tpl: TVE.tpl( 'controls/social/pin-share' ),
												after_init: function () {
													this.image_picker = new ImagePicker( {} );
													this.$( '.pin-image-upload' ).append( this.image_picker.$el );
													this.listenTo( this.image_picker, 'select', function ( selection ) {
														this.data.media = selection.url;
													} );
													this.listenTo( this.image_picker, 'remove', function () {
														this.data.media = '';
													} );
												},
												read_specific: function ( $item ) {
													this.data.description = $item.attr( 'data-description' );
													this.image_picker.set( {url: $item.attr( 'data-media' ) || ''} );
												},
												validate: function () {
													var image = this.image_picker.get();
													if ( ! image || ! image.url ) {
														this.inline_message( TVE.t.pinterest_img_required, 'error', this.image_picker.$el );

														return false;
													}

													return true;
												},
												onOpen: function () {

												}
											} ),
											g_share: Base,
											in_share: Base,
											xing_share: Base
										};
									})( jQuery );
								},
								"selector.js": function (exports, module, require) {
									var DropPanel = require( '../drop-panel' );

									module.exports = DropPanel.extend( {
										networks: {
											'fb_share': 'Facebook',
											't_share': 'Twitter',
											'g_share': 'Google',
											'pin_share': 'Pinterest',
											'in_share': 'Linkedin',
											'xing_share': 'Xing'
										},
										after_initialize: function () {
											var html = '';
											_.each( this.networks, function ( network, k ) {
												html += '<label class="tcb-checkbox"><input type="checkbox" class="s-network change" data-fn="item_toggle" value="' + k + '"><span>' + network + '</span></label>';
											} );
											this.$( '.popup-content' ).html( html ).addClass( 'inline-checkboxes' );
										},
										attach_collection: function ( collection ) {
											this.collection = collection;
										},
										apply: function () {
											var self = this;
											this.$( '.s-network' ).each( function () {
												var item = self.collection.findWhere( {key: this.value} );
												if ( this.checked ) {
													! item && self.collection.add( {key: this.value, label: self.networks[this.value]}, {silent: true} );
												} else if ( item ) {
													self.collection.remove( item );
												}
											} );
											this.collection.trigger( 'change' );
										},
										cancel: function () {
										},
										update: function ( $element ) {

										},
										get_selected: function () {
											var list = [];
											this.$( '.s-network:checked' ).each( function () {
												list.push( this.value );
											} );

											return list;
										},
										read_element: function ( $element ) {
											var $all = this.$( '.s-network' ).prop( 'checked', false ),
												items = [], selected = [], networks = this.networks;

											if ( ! arguments.length ) {
												$element = this.applyTo();
											}

											$element.find( '.tve_s_item' ).each( function () {
												var k = this.getAttribute( 'data-s' );
												selected.push( k );
												items.push( {key: k, label: networks[k]} );
												$all.filter( '[value="' + k + '"]' ).prop( 'checked', true );
											} );

											this.component.renderer.set_config( {selected: selected}, false );

											return items;
										}
									} );
								},
								"style.js": function (exports, module, require) {
									var StylePicker = require( '../style-picker' );
									module.exports = StylePicker.extend( {
										read_from_element: function () {
											var m = this.applyTo().find( '.tve_social_items' ).attr( 'class' ).match( /(\s+)?tve_style_(\d+)/ ),
												style = ! m ? 'tve_style_1' : ('tve_style_' + m[2]);

											this.renderer.set_config( {style: style} );
											return style;
										},
										box_class: function () {
											return 'tcb-list tcb_social_sharing_style';
										},
										container_el: function () {
											return 'div';
										},
										container_class: function () {
											return 'tcb-scroll list-container dark-box';
										},
										item_template: function () {
											return _.template( '<div class="item click tve-select-item tcb-social-share-preview-item" data-fn="select" id="<#=key #>" data-value="<#=key #>"></div>' );
										},
										input: function ( $element ) {
											this.renderer.set_config( {style: this.model.selected} ).render_to( $element );
										},
										cancel: function ( $element ) {
											this.model.selected = this.model.selected_old;
											this.renderer.set_config( {style: this.model.selected_old} ).render_to( $element );
											this.renderer.clear_undo_snapshot();
											TVE.Components.shadow.update();
										},
										onOpen: function ( $element, target, $dropdown ) {
											var $socialItems = $element.find( '.tve_social_items' ),
												$listContainer = $dropdown.find( '.list-container' );

											$listContainer.removeClass( 'tve_social_ib tve_social_itb tve_social_cb' );

											if ( $socialItems.hasClass( 'tve_social_ib' ) ) {
												$listContainer.addClass( 'tve_social_ib' );
											} else if ( $socialItems.hasClass( 'tve_social_itb' ) ) {
												$listContainer.addClass( 'tve_social_itb' );
											} else if ( $socialItems.hasClass( 'tve_social_cb' ) ) {
												$listContainer.addClass( 'tve_social_cb' );
											}

											this.renderer.take_undo_snapshot( $element );
										},
										apply: function ( $element ) {
											this.renderer.render_to( $element, true );
											TVE.Components.shadow.update();
										}
									} );
								}
							},
							"style-change.js": function (exports, module, require) {
								/**
								 * General control for style changes
								 * Shows an input, with the Change button next to it
								 */
								var DropPanel = require( './drop-panel' );
								module.exports = require( '../base' ).control.extend( {
									template: TVE.tpl( 'controls/style-change' ),
									/**
									 * Set the droppanel instance to be opened by the "CHANGE" button
									 * @param panel
									 */
									set_drop_panel: function ( panel ) {
										if ( ! panel instanceof DropPanel ) {
											throw new Error( 'Style changer expects a DropPanel instance' );
										}
										this.panel = panel;
										this.panel.parent_control = this;

										this.listenTo( this.panel, 'update', this.update_ui );
									},
									/**
									 * Opens the Drop Panel
									 */
									open_panel: function ( $element, target ) {
										if ( ! this.panel ) {
											return false;
										}

										this.panel.open( $element, target );

										return false;
									},
									/**
									 * Just forward the call to the panel instance
									 */
									input: function () {
										if ( ! this.panel ) {
											return false;
										}
										if ( this.panel.getLabel ) {
											this.update_ui();
										}
										return this.panel.input.apply( this.panel, arguments );
									},
									/**
									 * Forward the call to the panel instance
									 */
									update: function () {
										if ( ! this.panel ) {
											return false;
										}

										return this.panel.update.apply( this.panel, arguments );
									},
									/**
									 * Sets the selected text
									 * @param {String} [selected_text] Optional. text that go into the text input
									 */
									update_ui: function ( selected_text ) {
										selected_text = selected_text || '';
										if ( ! selected_text && this.panel && this.panel.getLabel ) {
											selected_text = this.panel.getLabel();
										}

										this.$( 'input.style-change-input' ).val( selected_text );

										return this;
									}
								} );
							},
							"style-picker.js": function (exports, module, require) {
								(function ( $ ) {
									/* Style picker control */
									var DropPanel = require( './drop-panel' ),
										watch = require( '../../libs/watcher' );

									module.exports = DropPanel.extend( {
										template: TVE.tpl( 'controls/style' ),
										after_initialize: function () {
											watch( this.model, 'selected', this.change, this );
										},
										box_class: function () {
											return 'tve-style-options dark-box';
										},
										container_class: function () {
											return 'row middle-xs';
										},
										container_el: function () {
											return 'div';
										},
										/**
										 * triggered each time the selected value changes
										 */
										change: function () {
											this.trigger( 'update', this.getLabel( this.model.selected ) );

											this.$el.find( '.tve-select-item' ).removeClass( 'active' ).filter( '[data-value="' + this.model.selected + '"]' ).addClass( 'active' );
										},
										/**
										 * Select element
										 *
										 * @param $element
										 * @param dom
										 */
										select: function ( $element, dom ) {
											this.model.selected = dom.getAttribute( 'data-value' );
											this.input( $element, dom );
										},
										/**
										 * Gets the label from the selected element
										 *
										 * @param selected
										 * @returns {string}
										 */
										getLabel: function ( selected ) {
											selected = typeof selected === 'undefined' ? this.model.selected : selected;
											if ( ! selected || ! this.model.config.items[selected] ) {
												return '';
											}
											var item = this.model.config.items[selected];

											return item.label ? item.label : item;
										},
										render_item: function ( key, value ) {
											var tpl = this.item_template();

											return tpl( {key: key, label: value.label ? value.label : value, value: value} );
										},
										item_template: function () {
											return TVE.tpl( 'implement me' );
										},
										/**
										 * Should read and return the selected item key from the element being selected
										 */
										read_from_element: function () {
											throw new Error( 'Implement read_from_element function' );
										},
										update: function () {
											var selected = this.read_from_element();
											this.model.selected = selected;

											this.model.selected_old = selected;
										}
									} );
								})( jQuery );
							},
							"switch.js": function (exports, module, require) {
								var checkbox = require( './checkbox' );

								module.exports = checkbox.extend( {
									template: TVE.tpl( 'controls/switch' )
								} );
							},
							"table-borders.js": function (exports, module, require) {
								var Borders = require( './borders' );

								module.exports = Borders.extend( {
									controls_init: function () {
										Borders.prototype.controls_init.apply( this, arguments );
									},
									setConfig: function () {
										Borders.prototype.setConfig.apply( this, arguments );

										/* if the table has no borders, update the CSS to reflect it */
										var $element = this.applyTo();
										if ( $element.hasClass( 'tve_no_border' ) ) {
											$element.head_css( {'border-width': '0px'}, null, this.config.css_suffix, false, '#tve_editor ' );
											$element.removeClass( 'tve_no_border' );
										}
									},
									/**
									 * Update element css when one of the control changes.
									 * @param $element
									 * @returns {boolean}
									 */
									change: function ( $element ) {

										if ( this.controls.Style === 'none' ) {
											return false;
										}

										var css = {},
											side = this.border_side === '' ? 'border' : 'border-' + this.border_side,
											important = this.config.important ? ' !important' : '';

										css[side] = this.controls.Width.getValue() + 'px ' +
										            this.controls.Style.getValue() + ' ' +
										            this.controls.Color.getValue() + important;

										$element.head_css( css, null, this.config.css_suffix, false, '#tve_editor ' );
									},
									remove_sides: function () {
										this.$el.children( '.row' ).addClass( 'middle-xs' );
										this.$( '.border-boxes' ).empty();

										return this;
									}
								} );
							},
							"text": {
								"typefocus-settings.js": function (exports, module, require) {
									/**
									 * Created on 5/12/2017.
									 */
									var DropPanel = require( '../drop-panel' ),
										ColorPicker = require( '../color-picker' );

									module.exports = DropPanel.extend( {
										template: TVE.tpl( 'controls/text/typefocus-settings' ),
										after_initialize: function () {
											this.listenTo( this.model, 'change', this.render );
										},
										render: function () {
											if ( this.picker ) {
												this.picker.destroy();
											}
											this.$( '.popup-content' ).html( this.template() );
											this.$speed = this.$( '#timer-ms' );

											if ( this.render_callback ) {
												this.render_callback.call( this );
												delete this.render_callback;
											}
											var $color = this.$( '.highlight-color' );
											if ( $color.length ) {
												this.picker = new ColorPicker( {
													el: $color[0],
													model: {
														config: {
															options: {
																output: 'object',
																preferredFormat: 'hex',
																showInput: false,
																showGradient: false,
																showAlpha: true,
																allowEmpty: true
															}
														}
													},
													change: _.bind( this.h_color_change, this )
												} );
												this.picker.setValue( this.model.get( 'colors' ) );
											}
										},
										h_color_change: function ( color ) {
											this.model.set( 'colors', color ? color.toString() : '', {silent: true} );
										},
										add_variation: function () {
											this.model.get( 'variations' ).push( '' );
											this.render_callback = function () {
												this.$( 'input.variation-item' ).last().focus();
											};
											this.render();
										},
										edit_variation: function ( el, dom, e ) {
											if ( e.which === 13 ) {
												this.add_variation();
												return true;
											}
											this.model.get( 'variations' )[dom.getAttribute( 'data-index' )] = dom.value;
											return false;
										},
										remove_variation: function ( e, dom ) {
											var index = dom.getAttribute( 'data-index' );
											this.model.get( 'variations' ).splice( index, 1 );
											this.model.trigger( 'change' );
											return false;
										},
										attr: function ( e, checkbox ) {
											this.model.set( checkbox.getAttribute( 'data-field' ), ! ! checkbox.checked );
										},
										speed: function ( e, dom ) {
											this.model.set( {'speed': dom.value}, {silent: true} );
											this.$speed.html( dom.value );
											return false;
										},
										validate: function () {
											if ( ! this.model.validate() ) {
												TVE.page_message( this.model.error, true );
												return false;
											}

											return true;
										},
										apply: function () {
											if ( ! TVE.froala.editor ) {
												return;
											}
											var editor = TVE.froala.editor,
												snapshot = editor.snapshot.get();

											var attr = this.model.get_dom_attr(),
												dom = this.model.__dom;
											if ( ! dom ) {
												editor.commands.clearFormatting();
												editor.format.apply( 'span', attr );
												dom = editor.format.is( 'span', {class: attr.class}, true );

											} else {
												_.each( attr, function ( v, k ) {
													dom.setAttribute( k, v );
												} );
											}
											if ( dom.textContent !== this.model.get( 'text' ) ) {
												jQuery( dom ).text( this.model.get( 'text' ) );
											}
											dom.removeAttribute( 'data-tve-custom-colour' );
											editor.events.focus();
											editor.undo.saveStep( snapshot );
											editor.undo.saveStep();

											TVE.froala.exec( 'toolbar.showInline' );
										},
										cancel: function () {
											this.model.restoreState();
											TVE.froala.exec( 'toolbar.showInline' );
										},
										default_changed: function ( e, dom ) {
											this.model.set( 'text', dom.value );
										}
									} );
								},
								"typefocus.js": function (exports, module, require) {
									var Settings = require( './typefocus-settings' ),
										Model = require( '../../../models/typefocus' ),
										settingsModel = new Model(),
										previous_element = null;

									module.exports = require( '../../base' ).control.extend( {
										template: TVE.tpl( 'controls/text/typefocus' ),
										after_initialize: function () {
											this.settings = new Settings( {
												model: settingsModel
											} );
										},
										open_settings: function ( $element, dom ) {
											settingsModel.saveState();
											this.settings.open( $element, dom );
										},
										update: function () {
											var elem;
											if ( TVE.froala.editor && ( elem = TVE.froala.editor.format.is( 'span', {class: 'tve_typefocus'}, true ) ) ) {
												/**
												 * avoid extra reads
												 */
												if ( elem === previous_element ) {
													return;
												}
												this.state( 'edit', elem );
												previous_element = elem;
											} else {
												if ( previous_element === null ) {
													settingsModel.set( 'text', TVE.froala.editor.selection.text() );
													return;
												}
												previous_element = null;
												this.state( 'add' );
											}
										},
										input: function () {
										},
										state: function ( state, elem ) {
											this.$( '.state-toggle' ).hide().filter( '.state-' + state ).show();
											var $preview = this.$( '#typefocus-preview' ).html( '' );
											if ( state === 'edit' ) {
												settingsModel.read( elem );
												$preview.html( TVE.tpl( 'controls/preview-list-item' )( {
													view: this,
													item: settingsModel
												} ) );
											} else {
												settingsModel.reset( true );
												settingsModel.set( 'text', TVE.froala.editor.selection.text() );
											}
										},
										has_settings_icon: function () {
											return false;
										},
										item_click: function () {
											this.open_settings.apply( this, arguments );
										},
										item_remove: function () {
											/**
											 * unwrap the dom element
											 */
											var el = settingsModel.__dom,
												parent = el.parentNode;
											while ( el.firstChild ) {
												parent.insertBefore( el.firstChild, el );
											}
											parent.removeChild( el );
											this.state( 'add' );

											return false;
										}
									} );
								}
							},
							"text-input.js": function (exports, module, require) {
								var input = require( './label-input' );

								module.exports = input.extend( {
									template: TVE.tpl( 'controls/text-input' ),
									render: function () {
										this.$input = this.$el.find( 'input' );
										if ( this.model instanceof Backbone.Model === false ) {
											var obj = this.model.config;
											this.model = new Backbone.Model( {
												label: obj.label,
												extra_attrs: obj.extra_attrs,
												label_col_x: obj.label_col_x,
												placeholder: obj.placeholder,
												cols: obj.cols,
												rows: obj.rows
											} )
										}

										this.$el.html( this.template( {model: this.model} ) );
									}
								} );
							},
							"time-slider.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 4/13/2017.
								 */
								var base = require( '../base' );
								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/time-slider' ),
									min: 0,
									max: 21600,
									initialize: function () {
										if ( typeof this.model.config.min !== 'undefined' ) {
											this.min = this.model.config.min;
										}
										if ( typeof this.model.config.max !== 'undefined' ) {
											this.max = this.model.config.max;
										}

										this.render();
										var self = this;

										this.$el.find( '.minutes-handle' ).tve_draggable( {
											start: function () {
												self.currentMinutesValue = isNaN( self.valueMinutes() ) ? 0 : parseInt( self.valueMinutes() );
											},
											move: function ( delta ) {
												var value = self.currentMinutesValue + parseInt( delta );
												if ( value < self.min ) {
													value = self.min;
												}

												if ( value > Math.floor( self.max / 60 ) ) {
													value = Math.floor( self.max / 60 );
												}

												self.$( '.tcb-input-minutes' ).val( value );
											},
											stop: function () {
												self.$el.find( '.tcb-input-minutes' ).trigger( 'change' );
											}
										} );

										this.$el.find( '.seconds-handle' ).tve_draggable( {
											start: function () {
												self.currentSecondsValue = isNaN( self.valueSeconds() ) ? 0 : parseInt( self.valueSeconds() );
											},
											move: function ( delta ) {
												var value = self.currentSecondsValue + parseInt( delta );
												if ( value < 0 ) {
													value = 0;
												}
												if ( value > 59 ) {
													value = 59;
												}

												self.$( '.tcb-input-seconds' ).val( value );
											},
											stop: function () {
												self.$el.find( '.tcb-input-seconds' ).trigger( 'change' );
											}
										} );
									},
									/**
									 * Return the minutes
									 *
									 * @returns {*}
									 */
									valueMinutes: function () {
										return this.$el.find( '.tcb-input-minutes' ).val();
									},
									/**
									 * Returns the seconds
									 *
									 * @returns {*}
									 */
									valueSeconds: function () {
										return this.$el.find( '.tcb-input-seconds' ).val();
									},
									/**
									 * onChange function that is being triggered when an input (text or slider) is changed
									 *
									 * @param $element
									 * @param dom
									 */
									onChange: function ( $element, dom ) {
										var value;
										if ( dom.classList.contains( 'tve-slider' ) ) {
											value = dom.value;
										} else if ( dom.classList.contains( 'tcb-input-minutes' ) || dom.classList.contains( 'tcb-input-seconds' ) ) {
											var minutes = isNaN( this.valueMinutes() ) ? 0 : parseInt( this.valueMinutes() ),
												seconds = isNaN( this.valueSeconds() ) ? 0 : parseInt( this.valueSeconds() );
											value = minutes * 60 + seconds;

											if ( value > this.max ) {
												value = this.max;
											}
										}

										this.setValue( value );
										this.change( $element, value )
									},
									/**
									 * Updates the inputs based on the slider movement
									 *
									 * @param $element
									 * @param dom
									 */
									onInput: function ( $element, dom ) {
										var minutes = Math.floor( dom.value / 60 ),
											seconds = dom.value % 60;

										this.$( '.tcb-input-minutes' ).val( minutes );
										this.$( '.tcb-input-seconds' ).val( seconds );
									},
									/**
									 * Sets all the inputs
									 *
									 * @param value
									 */
									setValue: function ( value ) {
										var minutes = Math.floor( value / 60 ),
											seconds = value % 60;

										this.$( '.tcb-input-minutes' ).val( minutes );
										this.$( '.tcb-input-seconds' ).val( seconds );
										this.$( '.tve-slider' ).val( value );
									},
									up: function ( $element, dom ) {
										var _timeSetting = dom.getAttribute( 'data-time' );

										this._changeTimeFromArrows( _timeSetting, + 1 );
									},
									down: function ( $element, dom ) {
										var _timeSetting = dom.getAttribute( 'data-time' );

										this._changeTimeFromArrows( _timeSetting, - 1 );
									},
									/**
									 * Changes the time from UP and DOWN arrows
									 *
									 * @param timeSettings min or sec
									 * @param plusMinus +1 or -1
									 * @private
									 */
									_changeTimeFromArrows: function ( timeSettings, plusMinus ) {
										if ( timeSettings === 'min' ) {
											var _minuteValue = parseInt( this.valueMinutes() ) + parseInt( plusMinus );
											if ( _minuteValue < 0 ) {
												_minuteValue = 0;
											}
											this.$( '.tcb-input-minutes' ).val( _minuteValue );
										} else if ( timeSettings === 'sec' ) {
											this.$( '.tcb-input-seconds' ).val( parseInt( this.valueSeconds() ) + parseInt( plusMinus ) );
										}

										this.$( '.tcb-input-minutes' ).trigger( 'change' );
									}
								} );
							},
							"toc": {
								"headings.js": function (exports, module, require) {
									/**
									 * Created by dan bilauca on 5/11/2017.
									 */
									var multiple_checkbox = require( '../multiple-checkbox' );

									module.exports = multiple_checkbox.extend( {

										/**
										 * number of max headings allowed
										 */
										max_headings: 3,

										template: TVE.tpl( 'controls/toc/headings' ),

										update_content: function ( $element, button ) {

											var self = this,
												$table = $element.find( '.tve_ct_content' ),
												_headers = this.get_checked_inputs();

											$element.find( '.tve_ct_content' ).html( '' );

											if ( _headers.length <= 0 ) {
												return;
											}

											var $headers = TVE.Editor_Page.editor.find( _headers.join( ',' ) ).not('.tve_faq *');
											$headers.each( function () {
												var $this = jQuery( this ),
													clean_id = $this.attr( 'id' ) ? $this.attr( 'id' ) : self.generateNewID(),
													$item = jQuery( '<div class="' + self.getCssClass( $this ) + '" ><a href="#' + clean_id + '">' + $this.text() + '</a></div>' );
												/**
												 * append element to the list only if it's visible on the page
												 *
												 * e.g. having headings in WP Content element
												 */
												if ( $this.is( ':visible' ) ) {
													$table.append( $item );
												}
												$this.attr( 'id', clean_id );
											} );

											this.splitInColumns( $element );
										},

										generateNewID: function () {

											var i = 1,
												ID = 'tab-con-' + i;

											while ( TVE.Editor_Page.editor.find( '#' + ID ).length > 0 ) {
												ID = 'tab-con-' + (++ i);
											}
											return ID;
										},

										getCssClass: function ( $header ) {

											return "tve_ct_level" + this.get_checked_inputs().indexOf( $header[0].nodeName.toLowerCase() );
										},

										splitInColumns: function ( $element ) {

											$element.find( '.tve_ct_content' ).children( '.leftCol, .rightCol' ).remove();
											var totalTopLevels = $element.find( '.tve_ct_content .tve_ct_level0' ).length,
												topLevelToColumns = 0,
												columns = [];

											for ( var i = 0; i < $element.attr( 'data-columns' ); i ++ ) {
												var column = jQuery( '<div class="ct_column sep"></div>' );
												columns.push( column );
											}
											//remove the sep class for the last column
											columns.push( columns.pop().removeClass( 'sep' ) );

											//remove the columns for the case where there are only one link as top level
											$element.find( '.tve_ct_content .ct_column' ).remove();

											if ( totalTopLevels <= 1 ) {
												//return; //this return does not put the links into columns
											}

											var columnIndex = 0;
											$element.find( '.tve_ct_content' ).children( '.tve_ct_level0, .tve_ct_level1, .tve_ct_level2' ).each( function ( i ) {
												var $this = jQuery( this );

												if ( $this.is( '.tve_ct_level0' ) ) {
													columnIndex = Math.floor( topLevelToColumns * columns.length / totalTopLevels );
												}

												columns[columnIndex].append( $this );

												if ( $this.is( '.tve_ct_level0' ) ) {
													topLevelToColumns ++;
												}
											} );

											//append columns to element
											$element.find( '.tve_ct_content' ).html( '' );
											for ( var i = 0, column; column = columns[i ++]; ) {
												column.css( 'width', 100 / columns.length + '%' );
												$element.find( '.tve_ct_content' ).append( column );
											}

											//set up max height for all columns if there are more than one
											var maxHeightOfColumns = 0;
											$element.find( '.ct_column' ).each( function () {
												var $this = jQuery( this );
												if ( $this.height() > maxHeightOfColumns ) {
													maxHeightOfColumns = $this.height();
												}
											} );
											$element.find( '.ct_column' ).css( 'min-height', maxHeightOfColumns + 'px' );
										}

									} );
								}
							},
							"toggle.js": function (exports, module, require) {
								var base = require( '../base' );

								module.exports = base.control.extend( {
									template: TVE.tpl( 'controls/toggle' ),
									update: function () {
									},
									addToggle: function () {
										var $element = this.applyTo(),
											$new_toggle = $element.find( ".tve_faq" ).first().clone();

										$new_toggle.find( '.tve_faqC' ).html( '' );
										$element.append( $new_toggle );
									},
									orderToggle: function () {
										var $element = this.applyTo(),
											position = $element.offset();

										$element.addClass( 'canvas-mode' );
										TVE.Editor_Page.disable();
										TVE.main.switch_menu_to( 'custom', 'toggle' );
										$element.sortable( {
											tolerance: 'pointer',
											axis: 'y'
										} );
										$element.append( TVE.inner.jQuery( '#tcb-toggle-panel' ).clone( true, true ) );
									},
									close_editor: function () {
										var $element = this.applyTo();
										if($element.sortable()){
											$element.sortable( 'destroy' );
										}
										$element.removeClass( 'canvas-mode' );
										$element.find( '#tcb-toggle-panel' ).remove();

										jQuery( TVE.Editor_Page ).unbind( 'editor.onenable' );
										TVE.Editor_Page.enable();
										TVE.main.element_selected( $element );
										return this;
									}
								} );
							}
						},
						"editor-settings.js": function (exports, module, require) {
							(function ( $ ) {

								/**
								 * Revision Manager view
								 */
								TVE.RevisionManager = require( './modals/revision' );

								/**
								 * Handles editor general settings section - undo / redo, save, etc
								 */
								var Base = require( './base' ).base_view,
									parent,
									revisionManagerInstance = TVE.RevisionManager.get_instance( TVE.modal.get_element( 'revision-manager' ) );

								/**
								 * Change responsive previews
								 */
								var Responsive = Base.extend( {
									icons: {
										desktop: 'responsive',
										tablet: 'tablet2',
										mobile: 'mobile2'
									},
									widths: {
										desktop: '100%',
										tablet: 768,
										mobile: 360
									},
									/**
									 * Click on change preview - changes the current preview device
									 *
									 * @param e
									 * @param btn
									 * @returns {boolean}
									 */
									change_preview: function ( e, btn ) {
										this.$( '.click' ).removeClass( 'selected' );
										btn.classList.add( 'selected' );
										this.select_device( btn.getAttribute( 'data-device' ) );
										parent.close_panel();

										return false;
									},
									/**
									 * Changes the current preview device and selects the corresponding icon
									 *
									 * @param {String} device
									 */
									select_device: function ( device ) {
										TVE.main.device = device;
										TVE.main.$container.find( 'iframe' ).animate( {
											width: this.widths[device]
										}, 200 );
										TVE.main.$container.removeClass( 'preview-desktop preview-tablet preview-mobile' ).addClass( 'preview-' + device );
										TVE.Editor_Page.$body.removeClass( 'preview-desktop preview-tablet preview-mobile' ).addClass( 'preview-' + device );

										setTimeout( function () {
											TVE.main.trigger( 'device_change', {device: device} );
											if ( TVE.ActiveElement ) {
												TVE.main.update_components();
												TVE.Editor_Page.reposition_icons();
											} else {
												TVE.Editor_Page.blur();
											}
										}, 200 );

										return this;
									}
								} );

								var More = Base.extend( {
									undo: function () {
										TVE.UndoManager.undo();

										return false;
									},
									redo: function () {
										TVE.UndoManager.redo();

										return false;
									},
									revisions: function () {
										revisionManagerInstance.open( {
											top: '20%'
										} );
									}
								} );

								/**
								 * Main settings component
								 */
								module.exports = Base.extend( {
									initialize: function ( attr ) {
										parent = this;
										this.$panels = this.$( '.tcb-settings-panel' );
										this.responsive = new Responsive( {
											el: this.$( '.tve-responsive' )
										} );
										this.more = new More( {
											el: this.$( '.tve-more' )
										} );

										this.bind_events();
									},
									bind_events: function () {
										var _fn = _.bind( function ( e ) {
											if ( e.type === 'mousedown' ) {
												if ( ! $.contains( this.el, e.target ) ) {
													this.close_panel();
												}
											} else if ( e.which === 27 ) {
												this.close_panel();
											}
										}, this );

										/* handle focus out */
										TVE.$document.add( TVE.inner.$document )
											.keyup( _fn )
											.mousedown( _fn );

										this.$( 'a[href]' ).not( '[href="javascript:void(0)"]' ).on( 'click', _.bind( function ( e ) {
											e.stopPropagation();
											this.close_panel();
										}, this ) );
									},
									/**
									 * Open a panel with settings
									 *
									 * @param e
									 * @param btn
									 */
									open_panel: function ( e, btn ) {
										if ( btn.classList.contains( 'active' ) ) {
											return this.close_panel();
										}
										this.$panels.hide().filter( btn.getAttribute( 'data-target' ) ).show();
										this.$el.children( '.click' ).removeClass( 'active' );
										btn.classList.add( 'active' );

										return false;
									},
									/**
									 * Close panel
									 *
									 * @returns {Boolean}
									 */
									close_panel: function () {
										this.$panels.hide();
										this.$el.children( '.click' ).removeClass( 'active' );

										return false;
									},
									/**
									 * Switch sidebar menu to settings
									 */
									sidebar_settings: function () {
										TVE.main.switch_menu_to( 'templates' );
									},
									/**
									 * Triggers saving of content
									 *
									 * @param {jQuery.Event} [e] optional
									 * @param {DOMNode} [btn] optional
									 *
									 * @returns {boolean}
									 */
									save: function ( e, btn ) {
										btn = btn || this.$( '.tve-save' )[0];
										var o = btn.innerHTML;
										btn.classList.add( 'tve-disabled' );
										btn.innerHTML = TVE.t.saving;
										TVE.set_login_callback( this.save, this );
										TVE.Editor_Page.save( true ).always( function () {
											btn.classList.remove( 'tve-disabled' );
											btn.innerHTML = o;
										} );

										return false;
									}
								} );
							})( jQuery );
						},
						"inline": {
							"column-options.js": function (exports, module, require) {
								var InlinePanel = require( './inline-drop-panel' );

								module.exports = InlinePanel.extend( {
									template: TVE.tpl( 'inline/column-options' ),
									render_row: function ( e, row ) {
										this.component.renderer.render_to( this.$element.removeClass( 'tcb-elem-placeholder' ), true, row.parentNode.getAttribute( 'data-cols' ), this.$( row ).index() );
										TVE.drag.refresh();
										TVE.Editor_Page.blur();
										this.hide();
										TVE.Editor_Page.focus_element( this.$element.removeClass( 'edit_mode' ) );
									}
								} );
							},
							"content-templates.js": function (exports, module, require) {
								var InlinePanel = require( './inline-drop-panel' ),
									test = null;

								(function ( $ ) {
									module.exports = InlinePanel.extend( {
										template: TVE.tpl( 'inline/content-templates' ),
										after_initialize: function () {
											this.$( '.drop-panel' ).addClass( 'small-pad tcb-autocomplete' );
											this.autocomplete();
										},
										autocomplete: function () {
											var self = this;
											this.$input = this.$( '.tcb-search' ).autocomplete( {
												minLength: 0,
												source: function ( request, response ) {
													var results = $.ui.autocomplete.filter( TVE.CONST.content_templates, request.term );

													response( results.slice( 0, 5 ) );
												},
												appendTo: this.$( '.popup-content' ),
												select: function ( e, ui ) {
													TVE.drag.fetch( {
														data: {
															key: ui.item.id,
															usertpl: true
														}
													}, TVE.ActiveElement );
													TVE.Editor_Page.blur();
													e.stopPropagation();

													return false;
												}
											} );

											this.$input.data( 'ui-autocomplete' )._renderItem = function ( ul, item ) {
												ul.addClass( 'tcb-suggest' );
												var r = new RegExp( this.term, 'i' ),
													li = $( '<li></li>' ).on( 'click', '.item-delete', _.bind( self.delete_template, self ) )
														.data( 'item.autocomplete', item )
														.append( '<a href="#" class="tcb-truncate">' + item.label.replace( r, '<span class="highlight">' + this.term + '</span>' ) + '</a>' )
														.append( TVE.icon( 'trash', 'svg', null, 'item-delete' ) )
														.appendTo( ul );
												li.find( '.item-delete' ).attr( 'title', TVE.t.delete );

												return li;
											};
											test = this.$input.data( 'ui-autocomplete' );
										},
										onOpen: function () {
											this.$input.val( '' ).focus().autocomplete( 'search' );
										},
										delete_template: function ( e ) {
											var $i = this.$input.autocomplete( 'widget' ).addClass( 'force-display' );
											if ( ! confirm( TVE.t.confirm_delete_tpl ) ) {
												return false;
											}
											var self = this,
												$icon = $( e.currentTarget ),
												$li = $icon.closest( 'li' ),
												key = $li.data( 'item.autocomplete' ).id;

											$icon.replaceWith( '<img class="tcb-loading" src="' + TVE.url( 'editor/css/images/loader_transparent.gif' ) + '">' );

											TVE.ajax( 'delete_content_template', 'post', {key: key} )
												.done( function ( response ) {
													TVE.CONST.content_templates = response.list;
													TVE.page_message( response.message );
												} )
												.always( function () {
													$i.removeClass( 'force-display' );
													self.$input.focus().autocomplete( 'search' );
												} );

											return false;
										}
									} );
								})( jQuery );
							},
							"inline-drop-panel.js": function (exports, module, require) {
								var DropPanel = require( '../controls/drop-panel' );
								(function ( $ ) {
									module.exports = DropPanel.extend( {
										append_element: function ( attr ) {
											this.setElement( $( '<div>', {
												id: 'tcb-drop-' + ( this.$el.data( 'view' ) || this.key() ),
												class: 'tcb-drop-panel inline-panel',
												html: this._template(),
												'data-view': this.key()
											} ).appendTo( '#inline-drop-panels' )[0] );

											if ( attr && attr.minWidth ) {
												this.$el.css( 'min-width', attr.minWidth + 'px' );
											}
										},
										open: function ( $element, target ) {
											this.visible = true;
											var $key_target = TVE.$document.add( TVE.inner.$document );
											$key_target.on( 'keydown.drop_panel', _.bind( function ( e ) {
												if ( e.which === 27 ) {
													this.onCancel();
													$key_target.off( 'keydown.drop_panel' );
												}
											}, this ) );
											this.show();
											this.position( target );
											this.onOpen( $element, target );

											/* bind the scroll event on the inner frame's window */
											TVE.inner.$window.off( 'scroll.' + this.key() ).on( 'scroll.' + this.key(), _.bind( this.on_window_scroll, this ) );

											this.$element = $element;

											return false;
										},
										/**
										 * hide the current drop panel
										 */
										hide: function ( $element, dom ) {
											this.visible = false;

											this.$el.hide();
											/* hide all colorpickers */
											this.$( '.color-picker' ).spectrum( 'hide' );
											this.trigger( 'close' );
											this.onClose( $element, dom );

											/* remove the scroll event listener */
											TVE.inner.$window.off( 'scroll.' + this.key() );
										},
										onOpen: function ( $element, target ) {

										},
										cancel: function () {
										},
										on_window_scroll: function () {
											var top = this.offset.top - TVE.inner.$window.scrollTop();
											top = top <= this.base_offset.top ? this.base_offset.top : top;

											this.$el.css( {
												top: ( top ) + 'px'
											} );
										},
										/**
										 * position the drop panel under the target
										 *
										 * This needs to also take into account the scrollTop of the inner frame
										 *
										 * @param $target
										 */
										position: function ( $target ) {
											if ( ! $target.jquery ) {
												$target = $( $target );
											}
											this.base_offset = TVE.main.$container.offset();
											this.offset = $target.offset();
											this.offset.left += this.base_offset.left;
											this.offset.top += this.base_offset.top + $target.outerHeight();

											if ( this.offset.top + this.__drop_panel_height - TVE.inner.$window.scrollTop() > TVE.inner.$window.height() ) {
												this.offset.top -= this.__drop_panel_height + $target.outerHeight() + 30;
												this.$( '.tcb-panel-arrow' ).addClass( 'arrow-bottom' );
											} else {
												this.$( '.tcb-panel-arrow' ).removeClass( 'arrow-bottom' );
											}

											this.$el.css( {
												left: ( this.offset.left + $target.outerWidth() / 2 - this.$el.outerWidth() / 2  ) + 'px',
												top: ( this.offset.top - TVE.inner.$window.scrollTop() ) + 'px'
											} );
										}
									} );
								})( jQuery );
							},
							"table-size.js": function (exports, module, require) {
								var InlinePanel = require( './inline-drop-panel' ),
									matrix = [[]],
									rows = 1, cols = 1;

								module.exports = InlinePanel.extend( {
									template: TVE.tpl( 'inline/table-size' ),
									after_initialize: function () {
										this.$preview = this.$( '#table-size-preview' );
										this.$cells = this.$( '.table-size-cell' );
										for ( var i = 1; i <= 6; i ++ ) {
											matrix[i] = [];
											for ( var j = 1; j <= 8; j ++ ) {
												matrix[i][j] = this.$cells.get( ( i - 1 ) * 8 + j - 1 );
											}
										}
										matrix[1][1].classList.add( 'sel' );
									},
									highlight: function ( e, dom ) {
										this.$cells.removeClass( 'sel' );
										rows = parseInt( dom.getAttribute( 'data-row' ) );
										cols = parseInt( dom.getAttribute( 'data-col' ) );

										for ( var i = 1; i <= rows; i ++ ) {
											for ( var j = 1; j <= cols; j ++ ) {
												matrix[i][j].classList.add( 'sel' );
											}
										}
										this.$preview.html( rows + ' x ' + cols );
									},
									insert: function () {
										TVE.ActiveElement.removeClass( 'thrv-table-placeholder tcb-elem-placeholder' ).addClass( 'thrv_table tcb-fixed' ).html( TVE.plugins.table.build( rows, cols ) );
										TVE.Editor_Page.focus_element( TVE.ActiveElement );
										this.hide();
									}
								} );
							}
						},
						"landing-page.js": function (exports, module, require) {
							
							module.exports = {

							};
						},
						"main.js": function (exports, module, require) {
							(function ( $ ) {
								var placeholder_timeout = null,
									storage = require( '../libs/storage' ),
									blur_element_timeout = null;

								require( '../libs/spectrum' );
								_.templateSettings = {
									evaluate: /<#([\s\S]+?)#>/g,
									interpolate: /<#=([\s\S]+?)#>/g,
									escape: /<#-([\s\S]+?)#>/g
								};
								/**
								 * froala license code
								 */
								try {
									(function ( k ) {
										localStorage.FEK = k;
									})( 'cSXSE1LHAFJVCXCLS==' )
								} catch ( e ) {
								}
								/**
								 * Main TVE object - used in the main frame and also in the child frame
								 */
								var TVE = window.TVE = window.TVE || {};

								$.extend( true, tcb_main_const.display, storage.get( 'tcb-components' ) || {} );

								$.extend( TVE, {
									CONST: tcb_main_const,
									t: tcb_main_const.i18n,
									$document: $( document ),
									$window: $( window ),
									$: $,
									outer: {
										document: document,
										window: window,
										$window: $( window ),
										$document: $( document )
									}
								} );

								/* include utils */
								$.extend( TVE, require( '../_utils.js' ) );

								/* main includes */
								$.extend( true, TVE, require( './_includes' ) );

								TVE.Landing_Page = require( './landing-page' );

								var TCB_Main = TVE.Views.Base.base_view.extend( {
									device: 'desktop',
									responsive: {
										desktop: {
											media: '(min-width: 300px)',
											rule_index: 0
										},
										tablet: {
											media: '(max-width: 1023px)',
											rule_index: 1
										},
										mobile: {
											media: '(max-width: 767px)',
											rule_index: 2
										}
									},
									media_query_tpl: function () {
										return this.responsive[this.device].media;
									},
									media_rule_index: function () {
										return this.responsive[this.device].rule_index;
									},
									all_media: function () {
										var arr = [];
										$.each( this.responsive, function ( device, data ) {
											arr.push( data.media );
										} );

										return arr;
									},
									events: function () {
										return _.extend( {}, TVE.Views.Base.base_view.prototype.events, {
											'dragstart': 'drag_start',
											'dragend': 'drag_end',
											'click .tve-element': 'cpanel_elem_click',
											'click .tve-element-pin': 'pin_element',
											'click .settings-icon': function () {
												this.switch_menu_to( 'settings' );
											},
											'click .back-icon, .uber-name': function () {
												this.deselect_element();
											}
										} );
									},
									initialize: function () {
										this.$cpanel = this.$( '#tve_cpanel' );
										this.$loader = this.$( '#tve_page_loader' );
										this.$cpanel.find( '.tve-element' ).attr( 'draggable', 'true' );
										this.$container = this.$( '#tcb-frame-container' );
										this.$elements = this.$cpanel.find( '#tve-elements' );
										this.$components = this.$cpanel.find( '#tve-components' );
										this.$settings = this.$cpanel.find( '#tve-sidebar-settings' );
										this.$frame = this.$( 'iframe#tve-editor-frame' );
										this.$dropPanels = this.$( '#tcb-drop-panels' );
										this.$ActiveElement = this.$( '.tve-active-element' );

										this.$static_elements = this.$( '#tve-static-elements' );

										this.custom_events();

										TVE.frame_offset = this.$container.offset();
										this.panel_offset();

										this.states_dropdown = new (require( './controls/element-states' ))( {el: this.$ActiveElement.find( '.element-states' )[0]} );

										TVE.state_manager = new (require( '../libs/state-manager' ))( this.states_dropdown );
									},
									/**
									 * Calculates and stores the panel offset
									 *
									 * @returns {*}
									 */
									panel_offset: function () {
										TVE.panel_offset = this.$cpanel.offset();

										return TVE.panel_offset;
									},
									/**
									 * handles back-icon or name click
									 */
									deselect_element: function () {
										this.switch_menu_to( 'elements' );
										if ( TVE.ActiveElement ) {
											TVE.Editor_Page.selection_manager.blur();
											delete TVE.ActiveElement;
										}
									},

									custom_events: function () {
										this.on( 'overlayevent', this.overlay );
										this.on( 'lb_opening', function () {
											this.$el.addClass( 'frame-maximized' );
										} );
										this.on( 'lb_close', function () {
											this.$el.removeClass( 'frame-maximized' );
										} );
										TVE.$document.on( 'heartbeat-tick.wp-auth-check', function ( e, data ) {
											if ( 'wp-auth-check' in data && ! data['wp-auth-check'] ) {
												var $frame = $( '#wp-auth-check-frame' ).off( 'load.tcb' ).on( 'load.tcb', function () {
													$frame.contents().find( 'form#loginform' ).append( '<input type="hidden" name="tve_interim_editor_key" value="' + TVE.CONST.userkey + '">' );
												} );
											}
										} );
									},
									/**
									 * Called when the active element changes to update the breadcrumbs view
									 */
									active_elem_nav_view: null,
									active_element_navigation: function () {
										if ( ! this.active_elem_nav_view ) {
											var ActiveElemNavView = require( './components/sel-elem-nav' );
											this.active_elem_nav_view = new ActiveElemNavView( {
												el: this.$( '#tcb-top-nav-list' )[0]
											} );
										}
										this.active_elem_nav_view.reset_breadcrumbs();
									},
									/**
									 * called on the inner editor iframe DOMReady event
									 */
									editor_loaded: function () {

										/* after the iframe loads, we initialize the menu only once, not at every refresh */
										if ( TVE.is_loaded ) {
											return;
										}

										TVE.is_loaded = true;

										this.undo_manager_init();
										this.menu_init();
										this.overlay( true );

										this.$frame.contents().on( 'click', 'a', function () {
											if ( ! $( this ).parents( '.media-modal' ).length ) {
												return false;
											}
										} );
										this.editor_settings = new (require( './editor-settings' ))( {
											el: this.$( '#tcb-editor-settings' )[0]
										} );

										this.sidebar_settings = new (require( './sidebar-settings' ))( {
											el: this.$( '#tve-sidebar-settings' )[0]
										} );

										/**
										 * Focus "search elements" input on Ctrl + F (only on the main frame)
										 */
										TVE.$document.off( 'keydown.tcb' ).on( 'keydown.tcb', _.bind( function ( e ) {
											if ( e.ctrlKey && ! e.altKey ) {
												if ( e.which === 70 ) {
													this.$( '.tve-search input' ).focus();

													return false;
												}
											}
										}, this ) );

										/* update components after each undo/redo action */
										TVE.main.off( 'after_undo_redo' ).on( 'after_undo_redo', function () {
											/**
											 * This was causing some of the controls to not be updated after undo-ing a change. e.g. the button group element
											 * @type {*}
											 * @private
											 */
											var _skip_update = TVE.SkipUpdate;
											TVE.SkipUpdate = false;
											TVE.main.update_components();
											TVE.SkipUpdate = _skip_update;
										} );
									},
									/**
									 * show a 'loading' animation on the screen
									 * this should be used when making ajax requests that take a big longer, so the user actually notices that something is happening in the background
									 *
									 * @param {*} [close_it] optional, whether or not to close the overlay
									 */
									overlay: function ( close_it ) {
										if ( close_it ) {
											this.$loader.removeClass( 'tve-open' );
											return;
										}
										this.$loader.addClass( 'tve-open' );
									},
									drag_start: function ( e ) {
										if ( ! TVE.allow_drag() ) {
											return false;
										}
										var $target = $( e.target );
										if ( ! $target.hasClass( 'tve-element' ) || this.device == 'mobile' ) {
											return false;
										}
										e.originalEvent.dataTransfer.setData( 'text/plain', '' );
										e.target.style.opacity = 0.6;
										e.stopPropagation();
										this.dragged_elem = this._build_elem_data( $target );

										TVE.drag.main_drag_start( this.dragged_elem );
									},
									drag_end: function ( e ) {
										if ( e ) {
											e.target.style.opacity = 1;
										}
										this.dragged_elem = null;

										TVE.drag.dragend( true );
									},
									_build_elem_data: function ( $elem ) {
										return {
											type: $elem.data( 'elem' ),
											data: $elem.data(),
											post_data: $elem.find( 'input' ).serializeArray(),
											static_element: this.static_element( $elem.data( 'elem' ) )
										};
									},
									/**
									 * Click on sidebar element: insert it directly into the page
									 *
									 * @param e
									 * @returns {boolean}
									 */
									cpanel_elem_click: function ( e ) {

										/* make sure we don't click on the pin */
										if ( e.target.classList.contains( 'tve-element-pin' ) ) {
											return false;
										}

										TVE.drag.insert_from_parent( this._build_elem_data( $( e.currentTarget ) ) );
										return false;
									},
									child_drag_end: function () {
										this.dragged_elem = null;
									},
									/**
									 * Get the static element based on element type
									 *
									 * @param {string} element_type
									 * @returns {*}
									 */
									static_element: function ( element_type ) {
										return this.$static_elements.find( "[data-elem='" + element_type + "']" );
									},
									undo_manager_init: function () {
										var undo_manager = require( '../libs/undo-manager' );

										//TODO: is 10 a good amount of undo's?
										TVE.UndoManager = new undo_manager( 10, this.$( '#tcb-undo' ), this.$( '#tcb-redo' ) );

										TVE.UndoManager.setCallback( function ( undoCommands ) {
											if ( undoCommands !== undefined && undoCommands.length ) {
												window.onbeforeunload = function () {
													return TVE.t.LeavePageUnsavedChanges;
												}
											} else {
												window.onbeforeunload = null;
											}
										} );

										TVE.SKIP_CSS_STATE = false;
									},
									menu_init: function () {
										TVE.Elements = tcb_main_const.elements;

										this.$( '.tve-search input' ).tve_search( this.$( '.tve-element' ) );

										TVE.Components = {};
										/* hide all controls at init and display them only when an element is selected */
										this.hide_components();

										$.each( TVE.Elements, function ( key, element ) {
											/**
											 * example: Content Templates
											 */
											if ( element.is_placeholder ) {
												TVE.Components[key] = new TVE.Views.Components[key]( {
													config: {},
													options: {}
												} );
												return;
											}
											$.each( element.components, function ( component, object ) {

												if ( typeof TVE.Components[component] === 'undefined' ) {
													/* render all components - at the same time, they will init their controls */
													var $el = $( '#tve-' + component + '-component' ),
														view = $el.data( 'view' );

													if ( typeof view === 'undefined' ) {
														TVE.Components[component] = new TVE.Views.Base.component( {el: $el[0]} );
													} else {
														TVE.Components[component] = new TVE.Views.Components[view]( {
															el: $el[0],
															config: object.config,
															/* in case there are some general options sent with localize */
															options: tcb_main_const.options[component] || {},
															renderer: TVE.renderers[component] || null
														} );
													}

													TVE.Components[component].setKey( component );
												}
											} );
										} );

										this.switch_menu_to( 'elements' );

										this.$scrollbar = this.$( '#tve-scroll-panel' ).scrollbar();
										this.$scrollbar.__height = this.$scrollbar.height();
									},
									/**
									 * Makes sure $element is visible in the side-menu ( by adapting the scroll position )
									 * @param $element
									 * @param {String} [animate] optional, defaults to 'fast'. if null, no animation
									 */
									scroll_panel_to: function ( $element, animate ) {
										if ( typeof animate === 'undefined' ) {
											animate = 'fast';
										}
										var el_top = $element.offset().top,
											height = $element.outerHeight(),
											diff = el_top + height - TVE.main.$scrollbar.__height,
											st = TVE.main.$scrollbar.scrollTop();

										if ( height && diff > 0 ) {
											if ( animate !== null ) {
												TVE.main.$scrollbar.animate( {scrollTop: st + diff - 93}, animate );
											} else {
												TVE.main.$scrollbar.scrollTop( st + diff - 93 );
											}
										} else if ( height && el_top < 135 ) {
											TVE.main.$scrollbar.scrollTop( st + ( el_top - 135 ) );
										}
									},
									/**
									 * Re-initializes the menu - this should be called when parts of the menu will change
									 *
									 */
									menu_reinit: function () {
										this.clear_focus();
										$.each( TVE.Components, function ( component, component_obj ) {
											if ( typeof TVE.Elements.general.components[component] !== 'undefined' && TVE.Elements.general.components[component].options ) {
												component_obj.options = TVE.Elements.general.components[component].options;
												component_obj.reinit();
											}
										} );
									},
									/**
									 *
									 * @param {string} menu
									 * @param {string} [extra] optional, used when menu = 'custom'
									 */
									switch_menu_to: function ( menu, extra ) {

										this.$( '.sidebar-block' ).hide();
										this.$( '#migrate-element' ).hide();
										this.$( '.tve-search input' ).val( '' ).trigger( 'keyup' );

										this.$cpanel.find( '.header-icon' ).hide();

										switch ( menu ) {
											case 'migrate_element':
												this.$components.hide();
												this.$settings.hide();
												this.$( '#migrate-element' ).show();
												break;

											case 'elements':
												this.$elements.show();
												this.$( '.tve-search' ).show();
												this.$cpanel.find( '.settings-icon' ).show();
												break;

											case 'components':
												this.$components.show();
												this.$ActiveElement.show();
												this.$cpanel.find( '.back-icon' ).show();
												break;

											case 'settings':
												this.$settings.show();
												this.sidebar_settings.show_tab( 'settings' );
												this.$cpanel.find( '.back-icon' ).show();
												delete TVE.ActiveElement;
												break;

											case 'templates':
												this.$settings.show();
												this.sidebar_settings.show_tab( 'templates' );
												this.$cpanel.find( '.back-icon' ).show();
												delete TVE.ActiveElement;
												break;
											case 'custom':
												this.$( '#sidebar-' + extra ).show();
												break;
										}
									},
									components_menu: function () {
										this.switch_menu_to( 'components' );

										return false;
									},
									hide_components: function () {
										this.$components.find( '.tve-component' ).hide();
									},
									clear_focus: function () {

										/* when we're not on the default state, we don't clear focus. we exit the state only when the user clicks save. */
										if ( ! TVE.state_manager.is_default() ) {
											return;
										}

										/* Closes all opened panels */
										TVE.Views.Controls.DropPanel.close_all();
										this.$( '.tve-panel' ).removeClass( 'drop-panel-open' );

										this.switch_menu_to( 'elements' );

										/* close all color pickers */
										this.$el.find( '.color-picker' ).spectrum( 'hide' );

										clearTimeout( blur_element_timeout );
										blur_element_timeout = setTimeout( function () {
											// clear the active element in a setTimeout call to allow any possible change events to be triggered
											delete TVE.ActiveElement;
										} );

										$.each( TVE.Components, function ( k, v ) {
											v.reset();
										} );

										TVE.state( TVE.STATE_DEFAULT );

										this.trigger( 'clear_focus' );
									},
									set_element_name: function ( name, suffix ) {
										if ( ! TVE.ActiveElement ) {
											return;
										}
										name = name || TVE.Elements[TVE._type( TVE.ActiveElement )].name;

										if ( typeof suffix !== 'undefined' && suffix ) {
											name += suffix;
										}

										this.$ActiveElement.find( '.element-name' ).html( name );
									},
									/**
									 * Display components from the selected element in the sidebar menu
									 * @param $element
									 * @param {Object} event
									 * @param {Boolean} [force_show_icons] optional, defaults to true
									 */
									element_selected: function ( $element, event, force_show_icons ) {
										clearTimeout( blur_element_timeout );
										/* if we're another state than the default one, we can't select another element except if it's the current one or one of his children */
										if ( ! TVE.state_manager.is_default() && ! ( TVE.state_manager.is_child( $element ) || TVE.state_manager.get_parent().is( $element )) ) {
											return;
										}

										if ( typeof force_show_icons === 'undefined' ) {
											force_show_icons = true;
										}

										var _type = TVE._type( $element ), self = this,
											is_placeholder = $element.hasClass( 'tcb-elem-placeholder' );

										if ( typeof TVE.Elements[_type] === 'undefined' ) {
											/* this should not happen, but just in case */
											return;
										}

										/* remove any temporary state that might have been stored at some point */
										TVE.UndoManager.temp.delete();

										/* save the current active element that was clicked on */
										TVE.ActiveElement = $element;

										/* when selecting a child we set it also in the state manager so we can differentiate it from his parent */
										if ( TVE.state_manager.is_child( $element ) ) {
											TVE.state_manager.set_element( $element );
										} else if ( ! $element.is( TVE.state_manager.get_parent() ) ) {
											/* Write the current active element name on top of the components list */
											this.set_element_name( TVE.Elements[_type].name );
											if ( TVE.Elements[_type].hover ) {
												/* show hover state */
												this.states_dropdown.enable();
											} else {
												this.states_dropdown.disable();
											}
										}

										TVE.state( TVE.STATE_EDIT );
										if ( force_show_icons ) {
											TVE.Editor_Page.selection_manager.show_icons( TVE.ActiveElement );
										}

										if ( TVE.Components[_type] ) {
											/* For placeholder elements, short-circuit the init here */
											if ( is_placeholder && TVE.Components[_type].placeholder_action ) {
												event && event.preventDefault();
												if ( ! TVE.Elements[_type].is_placeholder ) {
													TVE.Components[_type].setConfig( TVE.Elements[_type].components[_type].config, true );
												}
												clearTimeout( placeholder_timeout );
												placeholder_timeout = setTimeout( function () {
													TVE.Components[_type].placeholder_action();
												}, 200 );

												return true;
											} else if ( TVE.Components[_type].needs_update( $element ) ) {

												this.component_migration = TVE.Components[_type];
												this.switch_menu_to( 'migrate_element' );
												return;
											}
										}

										this.hide_components();

										this.trigger( 'element_selected', TVE.ActiveElement );

										$.each( TVE.Elements[_type].components, function ( component, options ) {
											/**
											 * the component may be part of a hidden stack which should not be displayed by default, and also not updated
											 */
											if ( options.hidden ) {
												return;
											}

											TVE.Components[component].setConfig( options.config );
											TVE.Components[component].disable_controls( options.disabled_controls || [] );

											TVE.Components[component].setOrder( options.order );

											TVE.Components[component].toggleDropdown( 'docked', component === _type || ! tcb_main_const.display[_type][component].docked );
											TVE.Components[component].toggleDropdown( 'advanced', tcb_main_const.display[_type][component].advanced );

											TVE.Components[component].show();
										} );

										this.switch_menu_to( 'components' );
										this.$scrollbar.scrollTop( 0 );

										/* update the components in case the element has some hover css */
										TVE.ActiveElement.not( '.thrv_text_element,.thrv_heading' ).one( 'mouseleave', function () {
											if ( TVE.ActiveElement ) {
												self.update_components();
											}
										} );
										this.active_element_navigation();
									},
									/**
									 * Trigger the upgrading of an element to TCB2 version
									 * Element is TVE.ActiveElement
									 * the element's main component should handle the element upgrade.
									 */
									migrate_element: function () {
										if ( ! this.component_migration ) {
											return false;
										}

										TVE.Editor_Page.before_action();

										this.component_migration.migrate_element( TVE.ActiveElement );

										TVE.Editor_Page.after_action();

										TVE.Editor_Page.focus_element( TVE.ActiveElement.removeClass( 'edit_mode' ) );
									},
									/**
									 * Trigger update for the components of the Active Element
									 *
									 * @param {Array} [components] custom list of components - allows partial updates. If missing it will update all components
									 *
									 * @return {TCB_Main} allows chained calls
									 */
									update_components: function ( components ) {
										if ( ! TVE.ActiveElement || TVE.SkipUpdate ) {
											TVE.SkipUpdate = false;
											return this;
										}
										var _type = TVE._type( TVE.ActiveElement );

										if ( typeof components !== 'undefined' && components.length ) {
											_.each( components, function ( component ) {
												if ( TVE.Components[component] ) {
													TVE.Components[component].update();
												}
											} );

											return this;
										}

										$.each( TVE.Elements[_type].components, function ( component, options ) {
											/**
											 * Do not update hidden components
											 */
											if ( ! options.hidden ) {
												TVE.Components[component].update();
											}
										} );

										TVE.Editor_Page.reposition_icons();

										return this;
									},
									/**
									 * Completely hide the side panel
									 */
									hide_side_panel: function () {
										this.$el.addClass( 'panel-hidden' );
									},
									show_side_panel: function () {
										this.$el.removeClass( 'panel-hidden' );
									},
									togglePanel: function ( e ) {
										this.$el.toggleClass( 'editor-collapsed' );
										var collapsed = this.$el.hasClass( 'editor-collapsed' ) ? 'collapsed' : 'expanded';

										e.currentTarget.setAttribute( 'title', e.currentTarget.getAttribute( 'data-title-' + collapsed ) );
										if ( TVE.ActiveElement ) {
											setTimeout( function () {
												TVE.Editor_Page.reposition_icons();
											}, 200 );
										}

										return false;
									},
									pin_element: function ( e ) {
										var $pinned_category = this.$( '.tve-category[data-category="' + TVE.CONST.pinned_category + '"]' ),
											$destination,
											$element = $( e.currentTarget.parentElement ),
											pinned = [];

										if ( e.currentTarget.classList.contains( 'pinned' ) ) {
											e.currentTarget.classList.remove( 'pinned' );
											/* after an element is unpinned, we take it back to his default category */
											$destination = this.$( '.tve-category[data-category="' + e.currentTarget.dataset.defaultCategory + '"]' )

											if ( this.$( '.pinned' ).length === 0 ) {
												/* if there are no pinned elements, we remove the category */
												$pinned_category.remove();
											}
										} else {
											e.currentTarget.classList.add( 'pinned' );

											$destination = $pinned_category;

											/* if the pinned category does not exist, we add it */
											if ( $destination.length === 0 ) {
												$destination = $( '<div>', {
													class: 'tve-category',
													'data-category': TVE.CONST.pinned_category,
													text: TVE.CONST.pinned_category
												} ).prependTo( this.$( '#tve-elements' ) )
											}

										}

										/* remove the element from his current category and move it where it needs to be -> pinned or default category */
										$element.detach().insertAfter( $destination );

										this.$( '.pinned' ).each( function () {
											pinned.push( this.dataset.element );
										} );

										TVE.ajax( 'update_option', 'post', {
											option_name: 'tcb_pinned_elements',
											option_value: pinned
										} );
									}
								} );

								$( function () {

									TVE.main = window.TCB_Main = new TCB_Main( {
										el: document.body
									} );

									window.TCB_READY = true;

									$( document ).trigger( 'tcb_main_ready' );
								} );

							})( jQuery );
						},
						"modals": {
							"_open.js": function (exports, module, require) {
								/**
								 * Created on 12/2/2016.
								 */
								var modals = {
									'base': require( './base' ).base,
									'options-post-types': require( './options-post-types' ),
									'page-events': require( './page-events' )
								};

								/**
								 * Open a modal by key
								 *
								 * @param {String} modal_key
								 * @param {String} [element_id] optional, use modal key if element_id is not defined
								 *
								 * @return {base} modal view instance
								 */
								module.exports = function ( modal_key, element_id ) {
									if ( ! modals[modal_key] ) {
										throw new Error( 'Modal: ' + modal_key + ' not found' );
									}
									if ( ! modals[modal_key].$$instance ) {
										modals[modal_key].$$instance = new modals[modal_key]( {
											el: TVE.modal.get_element( element_id || modal_key )
										} );
									}
									modals[modal_key].$$instance.open();

									return modals[modal_key].$$instance;
								};
							},
							"api-connections.js": function (exports, module, require) {
								(function ( $ ) {

									var base = require( '../base' ),
										modal = require( './base' ),
										api = require( '../../models/api' ),
										extended_api = require( '../../models/extended_apis' ),
										CodeParser = require( '../../models/html-parser' ),
										EditApiCardView, SimpleApiCardView, ApiFieldsView;

									module.exports = modal.base.extend( {

										after_initialize: function () {
											this.$el.addClass( 'medium' );
											this.$content = this.$( '.tve-wizard-content' );
											this.$progress = this.$( '.tve-wizard-progress' );

											this.apis = {};
											/* initialize all the apis that have a connection in the dashboard */
											_.each( TVE.CONST.api_connections, function ( name, key ) {
												this.apis[key] = new api( {
													key: key,
													name: name
												} )
											}, this );

											var self = this;

											/**
											 * Listen on newly created apis from another tab to add them to the list
											 */
											TVE.StorageManager.on( 'tve_new_api', function ( newApi ) {
												if ( ! self.apis[newApi.key] ) {

													self.apis[newApi.key] = new api( {
														key: newApi.key,
														name: newApi.name
													} );

													var card = new SimpleApiCardView( {
														model: self.apis[newApi.key]
													} );

													self.$content.find( '.tve-api-list' ).append( card.$el );
												}

												/* remove api from storage after it is set */
												TVE.StorageManager.unset( 'tve_new_api' );
											} );
										},

										save: function () {
											this.close();
										},
										/**
										 * Before opening the modal we render all apis
										 */
										before_open: function ( options ) {

											options = options || {};

											this.component = options.component ? options.component : null;

											var step = Object.keys( this.apis ).length > 0 ? 'apis' : 'start',
												params = {};

											if ( options.api ) {
												params.api = options.api;
												step = 'edit';
											}

											if ( options.form ) {
												step = 'form';
												params.step = 1;
											}

											this._template[step].call( this, params );
										},

										apis_init: function () {
											/* Read APIs directly from the form */
											TVE.ActiveElement.data( 'lg' ).set( 'read', 'apis' );

											var connections = TVE.ActiveElement.data( 'lg' ).get( 'apis' );

											/* when we set the first time a connection, we also open the redirect options */
											this.do_redirect_options = Object.keys( connections ).length === 0;

											/* set the config for each api that we read from the form */
											_.each( this.apis, function ( api, key ) {

												var config = {};

												if ( connections && connections[key] ) {
													config = connections[key];
													this.apis[key].set( 'state', 1 );
												} else {
													this.apis[key].set( 'state', 0 );
												}

												this.apis[key].set( 'config', config );

											}, this );
										},

										_template: {
											start: function ( params ) {
												var step = 1,
													total = 4;

												if ( typeof params.next === 'undefined' ) {
													params.next = true;
												}

												this.progress( 1, step, total );

												this.slide( 'lead-generation/start', params.next );
											},
											apis: function () {
												var step = 1,
													total = 3,
													$apiList;

												this.apis_init();

												this.progress( 1, step, total );

												this.slide( 'lead-generation/apis', 1 );

												$apiList = this.$content.find( '.tve-api-list' ).empty();

												/* populate the api list with all the apis, except the ones that are already added to the form. */
												_.each( this.apis, function ( api ) {
													if ( api.ready() ) {
														return;
													}
													var card = new SimpleApiCardView( {
														model: api
													} );

													$apiList.append( card.$el );
												}, this );
											},
											edit: function ( params ) {
												if ( typeof params.api === 'undefined' && typeof this.apis[params.api] === 'undefined' ) {
													this.close();
												}

												this.currentApi = params.api;

												var apiView,
													api = this.apis[params.api];

												this.progress( 1, 2, 3 );

												this.apis_init();

												this.slide( 'lead-generation/edit', 1, {api: api.get( 'name' )} );

												/* run some specific code for some specific apis that have custom fields and functionality */
												if ( typeof extended_api[params.api] === 'function' ) {
													if ( ! extended_api[params.api].initialized ) {
														extended_api[params.api]( this.$el, api );
														/* make sure we run this only once */
														extended_api[params.api].initialized = true;
													}
												}

												apiView = new EditApiCardView( {
													model: api
												} );

												this.$content.find( '.edit-api-card' ).html( apiView.$el );
											},
											form: function ( params ) {
												this.progress( 1, params.step || 0, 2 );

												this.slide( 'lead-generation/form', 1 );

												var code = TVE.ActiveElement.data( 'lg' ).get( 'custom_html_code' ) || '';

												this.$( '#lead_generation_code' ).val( code );
											},
											fields: function () {
												/* read previous fields */
												TVE.ActiveElement.data( 'lg' ).set( 'read', 'form_fields' );

												var connected = [],
													form_fields = TVE.ActiveElement.data( 'lg' ).get( 'form_fields' );

												_.each( this.apis, function ( api ) {
													if ( api.ready() ) {
														connected.push( api );
													}
												} );

												if ( connected.length > 0 ) {
													this.progress( 1 );

													this.slide( '', 1 );

													var $apiFields = new ApiFieldsView( {
														apis: connected,
														form_fields: form_fields,
														currentApi: this.currentApi,
														redirect_modal: this.do_redirect_options ? this.component : false
													} );

													this.$content.html( $apiFields.$el );
												} else {
													this.close();
													TVE.page_message( 'Please make sure that you have at least one connected api!', true );
												}
											}
										},

										/**
										 * Go to a step from the lead generation wizard
										 * @param $element
										 * @param dom
										 */
										step: function ( $element, dom ) {
											var template = dom.getAttribute( 'data-template' ),
												params = dom.dataset;

											this._template[template] && this._template[template].call( this, params );
										},

										/**
										 * Slide the current step to right or left depending if going forward or back
										 * @param template
										 * @param next
										 * @param params
										 */
										slide: function ( template, next, params ) {
											this.$content.hide( 'slide', {direction: (next ? 'left' : 'right')}, 300 );
											this.$content.html( TVE.tpl( template )( params ) ).show( 'slide', {direction: (next ? 'right' : 'left')}, 300 );
										},

										/**
										 * Draw the top progress bar depending on the step we're on
										 * @param next
										 * @param step
										 * @param total
										 */
										progress: function ( next, step, total ) {
											step = step ? step : parseInt( this.$progress.data( 'step' ) ) + (next ? 1 : - 1);

											total = total ? total : this.$progress.data( 'total' );

											this.$progress.find( '.current-progress' ).css( {
												width: 100 * step / total + '%'
											} );

											this.$progress.find( '.step-count' ).html( 'Step ' + step + ' / ' + total );

											this.$progress.data( 'step', step );
											this.$progress.data( 'total', total );
										},
										parseHTML: function () {
											var code = this.$( '#lead_generation_code' ).val(),
												Parser = new CodeParser( code ), inputs;

											/* parse the code and save the code */
											inputs = Parser.parse();
											inputs.code = code;

											if ( Parser.isValid() ) {
												/* Run custom changes on the inputs for various apis */
												inputs = extended_api.custom_html( inputs );

												/* write the custom html fields in the new form */
												TVE.ActiveElement.data( 'lg' ).set( 'customHtml', inputs );
												TVE.ActiveElement.data( 'lg' ).set( 'write', 'customHtml' );

												/* save the connection type as a custom html */
												TVE.ActiveElement.data( 'lg' ).set( 'type', 'custom-html' );
												TVE.ActiveElement.data( 'lg' ).set( 'write', 'type' );

												this.close();
											} else {
												TVE.page_message( 'Invalid code! Please add at least one input.', true );
											}
										}
									} );

									EditApiCardView = base.base_view.extend( {
										template: TVE.tpl( 'lead-generation/edit-api-card' ),
										before_initialize: function ( params ) {
											$.extend( true, this, params );
										},
										/**
										 * Make an ajax call and get all information related to the api
										 * @param force - force a new call to the api or get the information from the db
										 */
										getApi: function ( force ) {
											var edit_tpl = TVE.tpl( 'lead-generation/apis/default' ), self = this;

											force = (typeof force === 'boolean' ? force : false);

											if ( TVE.is_tpl( 'lead-generation/apis/' + this.model.get( 'key' ) ) ) {
												edit_tpl = TVE.tpl( 'lead-generation/apis/' + this.model.get( 'key' ) );
											}

											this.loading( true );

											this.model.getApi( force, function () {
												self.loading( false );

												self.$setup.html( edit_tpl( {api: self.model} ) );

												/* trigger after the api is rendered */
												$( TVE.main ).trigger( 'tve-api-after-render-' + self.model.get( 'key' ), {api: self.model, $container: self.$setup} );
											} );
										},
										forceGet: function () {
											this.getApi( true );
										},
										saveSettings: function () {
											var list = this.$( '.api-list' ).val();

											this.model.setConfig( {'list': list} );

											/* trigger an event so we can capture extra config for specific apis or from other plugins that include tcb */
											$( TVE.main ).trigger( 'tve-api-options-' + this.model.get( 'key' ), {api: this.model, $container: this.$el} );
										},
										step: function ( event, dom ) {
											if ( dom.dataset.template === 'fields' ) {
												this.saveSettings();

												this.model.validate();

												if ( this.model.ready() ) {
													var apis = TVE.ActiveElement.data( 'lg' ).get( 'apis' );

													apis[this.model.get( 'key' )] = this.model.get( 'config' );

													TVE.ActiveElement.data( 'lg' ).set( 'apis', apis );
												} else {
													alert( this.model.get( 'error' ) );
													event.stopPropagation();
												}
											}
										},
										after_render: function () {
											this.$setup = this.$( '.connection-setup' );
											this.$buttons = this.$( 'button.click' );

											this.$setup.scrollbar();

											this.getApi( false );
										},
										loading: function ( show ) {
											this.$setup.toggleClass( 'loading', ! ! show );

											this.$buttons.prop( 'disabled', ! ! show );
										},
										setupChange: function ( $element, dom ) {
											var config = {};

											config [dom.dataset.name] = dom.value;

											this.model.setConfig( config );
										}
									} );

									SimpleApiCardView = base.base_view.extend( {
										template: TVE.tpl( 'lead-generation/api-card' ),
										className: 'col-sm-4',
										tagName: 'div'
									} );

									ApiFieldsView = base.base_view.extend( {
										template: TVE.tpl( 'lead-generation/fields' ),
										default_fields: [
											{id: 'name', placeholder: TVE.t.name},
											{id: 'phone', placeholder: TVE.t.phone}
										],
										before_initialize: function ( options ) {
											this.apis = options.apis;
											this.currentApi = options.currentApi;
											this.form_fields = options.form_fields;
											this.redirect_modal = options.redirect_modal;
										},
										after_render: function () {
											/* the default custom fields will be used in case we have more than one connection */
											var custom_fields = this.default_fields;

											/* if we have only one api connected, than the custom fields ar the ones from him, if we have more, we work only with the default ones */
											if ( this.apis.length === 1 ) {
												custom_fields = this.apis[0].get( 'custom_fields' );
											}

											this.$( '.api-fields-add' ).html( TVE.tpl( 'lead-generation/api-field-add' )( {fields: custom_fields} ) );

											this.$fields = this.$( '.custom-fields' );
											this.$add_state = this.$( '.add-state' );
											this.$fields_state = this.$( '.fields-state' );

											/* by default the email is added */
											this.custom_fields = {
												email: {
													id: 'email',
													placeholder: 'Email',
													required: true
												}
											};

											if ( this.apis.length === 1 ) {
												/* in case we have some form fields already existing we append those and write the placeholder/require field */
												this.init_form_fields();
											}
										},
										init_form_fields: function () {
											if ( Object.keys( this.form_fields ).length ) {
												/* set email placeholder */
												this.custom_fields.email.placeholder = this.form_fields.email ? this.form_fields.email.placeholder : this.custom_fields.email.placeholder;
												this.$( '#email-field' ).val( this.custom_fields.email.placeholder );

												/* we don't need this anymore */
												delete this.form_fields.email;

												this.$fields.empty();

												_.each( this.form_fields, function ( field ) {
													this.$fields.append( TVE.tpl( 'lead-generation/custom-field' )( {
														id: field.id,
														placeholder: field.placeholder,
														value: field.placeholder,
														required: field.required
													} ) );

													this.$fields_state.find( '.tve-checkbox[value="' + field.id + '"]' ).prop( 'checked', true );

													this.custom_fields[field.id] = field;
												}, this );
											}
										},
										save: function () {

											if ( this.redirect_modal ) {
												/* when we connect an api for the first time, we also display the submit options */
												this.redirect_modal.manage_submit_options();
											}

											TVE.ActiveElement.data( 'lg' ).set( 'write', 'reset' );
											/* save the custom fields */
											TVE.ActiveElement.data( 'lg' ).set( 'custom_fields', this.custom_fields );
											/* write the api connections and the extra fields */
											TVE.ActiveElement.data( 'lg' ).set( 'write', 'apis' );
											/* write the custom fields  */
											TVE.ActiveElement.data( 'lg' ).set( 'write', 'custom_fields' );

											/* set type to api */
											TVE.ActiveElement.data( 'lg' ).set( 'type', 'api' );
											TVE.ActiveElement.data( 'lg' ).set( 'write', 'type' );
										},
										removeField: function ( event, dom ) {
											/* remove the custom field row */
											this.$( '.api-' + dom.dataset.id + '-field' ).remove();
											/* and un check the checkbox for the specific field */
											this.$fields_state.find( 'input[value="' + dom.dataset.id + '"]' ).prop( 'checked', false );
											delete this.custom_fields[dom.dataset.id];
										},
										toggleAddFields: function () {
											this.$add_state.toggle();
											this.$fields_state.toggle();
										},
										/**
										 * We ge all the checkboxes and the ones that are checked, we verify if they are added and if not we add them. The others we remove
										 */
										addFields: function () {
											_.each( this.$fields_state.find( '.tve-checkbox' ), function ( input ) {

												var $current = this.$fields.find( '.api-' + input.value + '-field' );

												if ( input.checked ) {
													if ( $current.length === 0 ) {
														this.$fields.append( TVE.tpl( 'lead-generation/custom-field' )( {id: input.value, placeholder: input.dataset.placeholder, value: '', required: false} ) )
													}

													if ( typeof this.custom_fields[input.value] === 'undefined' ) {
														this.custom_fields[input.value] = {
															id: input.value,
															placeholder: input.dataset.placeholder,
															required: false
														}
													}
												} else {
													if ( $current.length > 0 ) {
														$current.remove();
														delete this.custom_fields[input.value];
													}
												}
											}, this );

											this.toggleAddFields();
										},
										placeholderChange: function ( event, dom ) {
											this.custom_fields[dom.dataset.id].placeholder = dom.value;
										},
										requiredChange: function ( event, dom ) {
											this.custom_fields[dom.dataset.id].required = dom.checked;
										}
									} )
									;

								})( jQuery );
							},
							"base.js": function (exports, module, require) {
								/**
								 * Created on 12/2/2016.
								 */
								var base = require( '../base' );

								module.exports = {
									base: base.base_view.extend( {
										/**
										 * leanModal default options
										 */
										options: {
											opacity: .8,
											dismissible: true
										},
										close_options: {},
										/**
										 * Extend the list of events with CLOSE and SAVE
										 */
										events: function () {
											return _.extend( {}, base.base_view.prototype.events, {
												'click .tcb-modal-cancel': 'close',
												'click .tcb-modal-save': 'save'
											} );
										},
										has_fixed_footer: function () {
											return false;
										},
										/**
										 * no action needed, the html for the elements should already be in the page for the default modal
										 */
										render: function () {

										},
										/**
										 * Opens (shows) the modal
										 */
										open: function ( options ) {
											if ( typeof this['before_open'] === 'function' ) {
												this['before_open'].call( this, options );
											}

											var opts = _.extend( {}, this.options, options ),
												fn = opts.ready || null,
												self = this;

											if ( opts.css ) {
												this.$el.css( opts.css );
											}

											if ( this.has_fixed_footer() ) {
												this.$el.addClass( 'tcb-fixed-footer' );
											}

											opts.ready = function () {
												if ( typeof self['after_open'] === 'function' ) {
													self['after_open'].call( self, this );
												}
												if ( fn ) {
													fn.call( this );
												}
											};
											if ( opts.complete ) {
												this.close_options.complete = opts.complete;
											}
											/* close any other overlays */
											jQuery( '.tvd-lean-overlay' ).remove();

											if ( opts.dismissible === false ) {
												this.$el.find( '.tcb-modal-close' ).hide();
											} else {
												this.$el.find( '.tcb-modal-close' ).show();
											}

											this.$el.openModal( opts );
										},
										/**
										 * Close the modal
										 * @param e
										 * @returns {boolean}
										 */
										close: function ( e ) {
											e && e.preventDefault();
											if ( typeof this['before_close'] === 'function' ) {
												this['before_close'].call( this, e );
											}
											this.$el.closeModal( this.close_options );
											return false;
										},
										/**
										 * Saves the settings / user actions from this modal
										 * This should be implemented in all objects that extend from this
										 * @param e
										 */
										save: function ( e ) {
											if ( typeof this['before_save'] === 'function' ) {
												this['before_save'].call( this, e );
											}

											this.close();
											e.preventDefault();
											return false;
										}
									} ),
									/**
									 * Get a modal div element based on id
									 *
									 * @param {String} modal_id id of the modal's div element
									 *
									 * @return {Element}
									 */
									get_element: function ( modal_id ) {
										return document.getElementById( 'tcb-modal-' + modal_id.replace( /_/g, '-' ) );
									}
								};
							},
							"custom-html.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 4/18/2017.
								 */
								var modalBase = require( './base' ),
									content_manager = require( '../../../editor/src/util/content' ),
									_instance = null;

								module.exports = modalBase.base.extend( {
									editor: null,
									no_preview_html: '<div class="tve_shortcode_overlay"><span>No preview available.</span></div>',
									iframe_cover: '<div class="tve_iframe_cover"></div>',
									/**
									 * Save method that is triggered from
									 * Custom HTML "Save" Button inside the modal window
									 */
									save: function () {
										var $target = TVE.ActiveElement,
											htmlContent = jQuery.trim( this.editor.getValue() ),
											prevHtmlContent = $target.html();

										$target.removeClass( 'tcb-elem-placeholder' );
										if ( htmlContent.length > 0 ) {
											htmlContent = content_manager.convert_script_tags( htmlContent );
										}

										$target.html( htmlContent );

										if ( $target.height() <= 10 && $target.find( 'img' ).length === 0 ) {
											/**
											 When the content has only a script or a style tag with no HTML inside.
											 "<=10" is placed because of the min height that an empty drop zone could have.
											 Images will have a delay until loaded.
											 */
											$target.append( this.no_preview_html );
											htmlContent += this.no_preview_html;
										} else {
											if ( $target.find( 'iframe' ).length ) {
												$target.append( jQuery( this.iframe_cover ) );
												htmlContent += this.iframe_cover;
											}
										}

										/*Trigger Click on Active Element to Display the Custom HTML Options in the sidebar*/
										$target.trigger( 'click' );

										/**
										 * UNDO / REDO Manager
										 */
										TVE.UndoManager.add( {
											undo: function () {
												$target.html( prevHtmlContent );
											},
											redo: function () {
												$target.html( htmlContent );
											}
										} );

										this.close();
									},
									/**
									 * Before open modal callback
									 */
									before_open: function () {
										this.editor = ace.edit( 'tcb-custom-html-code' );
										this.editor.setTheme( 'ace/theme/chrome' );
										this.editor.session.setMode( 'ace/mode/html' );
										this.editor.session.setUseWrapMode( true );

										if ( TVE.ActiveElement.hasClass( 'tcb-elem-placeholder' ) ) {
											this.editor.setValue( '' );
										} else {
											var prepared_content = content_manager.revert_script_tags( TVE.ActiveElement.html() );
											this.editor.setValue( prepared_content );
											this.editor.selection.clearSelection();
										}

										this.editor.focus();
									}
								}, {
									/**
									 * "Singleton" implementation for modal instance
									 *
									 * @param el
									 */
									get_instance: function ( el ) {
										if ( ! _instance ) {
											_instance = new TVE.CustomHTML( {
												el: el
											} );
										}

										return _instance;
									}
								} );
							},
							"icons.js": function (exports, module, require) {
								/**
								 * Created by dan bilauca on 4/28/2017.
								 */
								var modalBase = require( './base' ),
									_instance;

								module.exports = modalBase.base.extend( {

									selected_class: 'tve-icon-selected',

									events: function () {

										return _.extend( {}, modalBase.base.prototype.events(), {
											'keyup .tve-search-icon': 'search_icon'
										} );
									},

									before_open: function () {

										var $svg_icons_wrapper = this.$( '#tve-svg-icons' );

										if ( $svg_icons_wrapper.html().length === 0 ) {
											this._render_svg_icons( $svg_icons_wrapper );
										}
									},

									/**
									 * remove all binds from all controls that have added
									 */
									before_close: function () {

										this.off( 'save' );
										if ( TVE.ActiveElement.hasClass( 'tcb-elem-placeholder' ) ) {
											TVE.Editor_Page.blur();
										} else {
											TVE.Editor_Page.focus_element( TVE.ActiveElement );
										}
									},

									_render_svg_icons: function ( $placeholder ) {

										var $icons = jQuery( '#tve-default-icons symbol' );

										$icons.each( function ( index, dom ) {
											var id = dom.getAttribute( 'id' );
											id = id.replace( 'icon-', '' );
											$placeholder.append( '<span class="tve-icon click tve-svg-icon" data-cls="icon-' + id + '" title="' + id + '" data-fn="select_icon">' + TVE.icon( id ) + '</span>' );
										} );
									},

									_deselect_all_icons: function () {

										this.$( '.tve-icon' ).removeClass( this.selected_class );
									},

									select_icon: function ( event, dom ) {

										this._deselect_all_icons();
										dom.classList.add( this.selected_class );
									},

									search_icon: function ( event ) {

										var $input = jQuery( event.currentTarget ),
											$list = jQuery( '#' + $input.data( 'search-for' ) ),
											$icons = $list.children().css( {
												display: 'none'
											} );

										this._deselect_all_icons();

										$icons.filter( function () {
											return this.getAttribute( 'title' ).indexOf( $input.val() ) !== - 1;
										} ).css( {
											display: 'inline-block'
										} );
									},

									save: function () {

										var $target = TVE.ActiveElement,
											$icon = this.$( '.' + this.selected_class ),
											data = {
												icon: $icon
											};
										if ( ! $icon.length ) {
											return;
										}
										$target.removeClass( 'tcb-elem-placeholder' ).addClass( 'tcb-icon-display' );

										this.trigger( 'save', data );

										this.close();
									}
								}, {
									get_instance: function ( el ) {
										if ( ! _instance ) {
											_instance = new TVE.IconsModal( {
												el: el
											} );
										}

										return _instance;
									}
								} );
							},
							"landing-page.js": function (exports, module, require) {
								(function ( $ ) {

									var modalBase = require( './base' ),
										cloud_thumbnail = 'http://landingpages.thrivethemes.com/wp-content/plugins/thrive-visual-editor/landing-page/templates/thumbnails/';

									module.exports = modalBase.base.extend( {
										el: TVE.modal.get_element( 'lp-templates' ),
										lp_set: TVE.tpl( 'landing-pages/lp-set' ),
										lp_template: TVE.tpl( 'landing-pages/lp-template' ),
										lp_delete_confirmation: TVE.tpl( 'landing-pages/delete-confirmation' ),
										tag_item: TVE.tpl( 'landing-pages/tag-item' ),
										events: {
											'click .tcb-modal-save': 'save',
											'click .tcb-modal-close': 'close',
											'click .tab-item': 'tab_click',
											'click .expand-set': 'expand_set',
											'click .close-icon': 'render_sets',
											'mouseover .tve-template-item .template-thumbnail': 'show_preview',
											'mouseleave .tve-template-item .template-thumbnail': 'hide_preview',
											'change .template-tag': 'filter_templates',
											'click .tags-title': function () {
												this.$filter.toggle();
											},
											'click': function ( e ) {
												if ( ! this.$filter.is( e.target ) && this.$filter.has( e.target ).length === 0 && ! e.target.classList.contains( 'tags-title' ) ) {
													this.$filter.hide();
												}
											},
											'click .tve-template-item .template-wrapper': function ( e ) {
												this.$( '.template-wrapper.active' ).removeClass( 'active' );
												e.currentTarget.classList.toggle( 'active' );
											},
											'input .tags-search': function ( e ) {
												this.render_tags( e.target.value )
											},
											'click .tcb-delete-saved-template': 'delete_saved_template',
											'click .tcb-cancel-delete-template': 'no_delete_template',
											'click .tcb-apply-delete-template': 'yes_delete_template'

										},
										initialize: function () {
											this.$el.addClass( 'medium' );

											this.$tabs = this.$( '.tab-item' );
											this.$content = this.$( '.tve-tab-content' );
											this.$filter = this.$( '.tags-select' );
											this.$preview = this.$( '.tve-template-preview' );

											this.$default_templates = this.$( '.tve-default-templates-list' );
											this.$saved_templates = this.$( '.tve-saved-templates-list' );
											this.$tag_list = this.$( '.template-tags' );

											this._filter_templates();

											this.render_sets();

											this.render_tags();

											this.$( '.tve-tabs-content' ).scrollbar();
										},
										before_open: function () {
											this.render_sets();
										},
										tab_click: function ( event ) {
											var tab = event.currentTarget.getAttribute( 'data-content' );

											this.$tabs.removeClass( 'active' );
											event.currentTarget.classList.add( 'active' );

											this.$content.removeClass( 'active' );
											this.$content.filter( '[data-content="' + tab + '"]' ).addClass( 'active' );

											/* tags filter should be displayed only for default templates because not all the saved ones have tags. */
											this.$( '.tags-filter' )[event.currentTarget.getAttribute( 'data-content' ) === 'default' ? 'visible' : 'invisible']();
										},
										delete_saved_template: function ( event ) {
											var $templateItem = jQuery( event.currentTarget ).closest( '.tve-template-item' );

											$templateItem.find( '.template-wrapper' ).hide();
											$templateItem.append( this.lp_delete_confirmation() );

										},
										/**
										 * Cancel A Delete Action And Returns to Default State
										 *
										 * @param event
										 */
										no_delete_template: function ( event ) {
											var $templateItem = jQuery( event.currentTarget ).closest( '.tve-template-item' );
											$templateItem.find( '.template-wrapper' ).show();
											$templateItem.find( '.tcb-delete-template-confirmation' ).remove();
										},
										/**
										 * Deletes A Saved Landing Page
										 *
										 * @param event
										 */
										yes_delete_template: function ( event ) {
											var $templateItem = jQuery( event.currentTarget ).closest( '.tve-template-item' ),
												data = {
													custom_action: 'landing_page_delete',
													tve_landing_page: $templateItem.attr( 'data-key' )
												},
												self = this;
											TVE.main.overlay();
											TVE.Editor_Page.save( false, function ( response ) {
												if ( response.success === true ) {
													$templateItem.remove();

													/*Remove The Deleted Template From The Saved Templates Array*/
													self.saved_templates = self.saved_templates.filter( function ( o ) {
														return o.key !== $templateItem.attr( 'data-key' )
													} );
												}
												TVE.main.overlay( 'hide' );
											}, data );
										},
										render_tags: function ( filter ) {
											var self = this;
											this.$tag_list.empty();

											if ( typeof filter === 'undefined' ) {
												filter = '';
											}

											_.each( this.tags, function ( tag ) {
												if ( tag.indexOf( filter ) !== - 1 ) {
													self.$tag_list.append( self.tag_item( {tag: tag} ) );
												}
											} );
										},
										render_sets: function () {
											var self = this;

											this.$default_templates.empty();

											_.each( this.default_sets, function ( v ) {
												self.$default_templates.append( self.lp_set( v ) );
											} );

											this.$saved_templates.empty();

											_.each( this.saved_templates, function ( v, k ) {
												v.count = k;
												self.$saved_templates.append( self.lp_template( v ) );
											} );
										},
										expand_set: function ( e ) {
											var $set = $( e.currentTarget ).parents( '.tve-template-set' ),
												set_key = $set.data( 'set' ),
												self = this;

											if ( typeof set_key === 'undefined' ) {
												return;
											}

											if ( this.$default_templates.find( '.expanded-set' ).length ) {
												this.render_sets();
												$set = this.$default_templates.find( '.tve-template-set[data-set="' + set_key + '"]' );
											}

											$set.empty().removeClass( 'tve-template-set' ).addClass( 'expanded-set' );

											$set.append( '<span>' + this.default_sets[set_key].label + '</span><div class="close-icon"></div>' );

											_.each( this.default_sets[set_key].templates, function ( v, k ) {
												v.count = k;
												$set.append( self.lp_template( v ) );
											} );

										},
										filter_templates: function () {
											var tags = [], self = this;
											this.$tag_list.find( ".template-tag:checked" ).each( function () {
												tags.push( this.value );
											} );

											if ( tags.length === 0 ) {
												this.$default_templates.removeClass( 'expanded-set' );
												this.render_sets();
											} else {
												this.$default_templates.addClass( 'expanded-set' ).empty();

												_.each( this.default_sets, function ( set ) {
													_.each( set.templates, function ( template ) {
														_.each( tags, function ( tag ) {
															if ( template.tags.indexOf( tag ) !== - 1 ) {
																self.$default_templates.append( self.lp_template( template ) );
																return;
															}
														} );
													} );
												} );
											}
										},
										save: function () {
											var $template = this.$( '.tve-template-item .active' ), self = this;

											if ( $template && $template.length ) {
												var lp = $template.data( 'key' ),
													data = {
														tve_landing_page: lp,
														custom_action: 'landing_page'
													};

												if ( $template.data( 'cloud' ) && '1' === $template.attr( 'data-cloud' ) ) {
													data = TVE.apply_filters( 'tcb_cloud_template_download', {
														action: 'tve_cloud_templates',
														task: 'download',
														template: lp,
														post_id: TVE.CONST.post_id
													} );
												}
												TVE.set_login_callback( this.save, this );
												TVE.main.overlay();
												TVE.Editor_Page.save( false, function () {
													TVE.CONST.landing_page = lp;
													window.onbeforeunload = null;
													TVE.page_message( TVE.t.TemplateChange );

													top.window.location.reload();
												}, data );


											} else {
												TVE.page_message( TVE.t.SelectTemplate, true, 5000 );
											}
										},
										show_preview: function ( e ) {

											/*Disable Preview For Saved Landing Page*/
											if ( e.currentTarget.parentElement.getAttribute( 'data-key' ).indexOf( 'user-saved-template-' ) === 0 ) {
												return;
											}

											var target = e.currentTarget.getBoundingClientRect(),
												left = 70 + (1 + parseInt( e.currentTarget.getAttribute( 'data-count' ) ) % 4 ) * 190;

											this.$preview.css( {
												left: left,
												top: target.top - e.currentTarget.offsetHeight,
												'background-image': e.currentTarget.style.backgroundImage
											} );

											this.$preview.show();
										},
										hide_preview: function ( e ) {
											this.$preview.hide();
										},
										_filter_templates: function () {
											var self = this;
											this.default_sets = {};
											this.saved_templates = [];
											this.tags = [];

											_.each( TVE.CONST.lp_templates, function ( v, k ) {
												var set = v.set.toLowerCase().replace( / /g, '-' ),
													thumb = (v.downloaded ? cloud_thumbnail : TVE.CONST.templates_path + '/thumbnails/') + k + '.png';

												if ( typeof self.default_sets[set] === 'undefined' ) {
													self.default_sets[set] = {
														set: set,
														label: v.set,
														thumbnail: thumb,
														templates: []
													}
												}

												self.default_sets[set].templates.push( {
													key: k,
													name: v.name,
													tags: v.tags,
													thumbnail: thumb
												} );

												_.each( v.tags, function ( tag ) {
													if ( self.tags.indexOf( tag ) === - 1 ) {
														self.tags.push( tag );
													}
												} );
											} );

											_.each( TVE.CONST.cloud_lp_templates, function ( v, k ) {
												var set = v.set.toLowerCase().replace( / /g, '-' ),
													thumb = cloud_thumbnail + k + '.png';

												if ( typeof self.default_sets[set] === 'undefined' ) {
													self.default_sets[set] = {
														set: set,
														label: v.set,
														thumbnail: thumb,
														templates: []
													}
												}

												self.default_sets[set].templates.push( {
													key: k,
													name: v.name,
													tags: v.tags,
													thumbnail: thumb,
													cloud: true
												} );
											} );

											_.each( TVE.CONST.saved_lp_templates, function ( v, k ) {
												self.saved_templates.push( {
													key: 'user-saved-template-' + k,
													name: v.name,
													tags: v.tags,
													thumbnail: v.thumbnail ? v.thumbnail : TVE.CONST.templates_path + '/thumbnails/' + v.template + '.png'
												} );
											} );

											this.tags.sort();
										},
										force_modal_close: function () {
											TVE.outer.$document.find( '.tvd-lean-overlay' ).remove();
										}

									} );
								})( jQuery );
							},
							"lg-error-messages.js": function (exports, module, require) {
								var modal_base = require( './base' ),
									_instance = null;

								module.exports = modal_base.base.extend( {

									labels: TVE.t.error_labels,
									default_errors: TVE.t.lg_errors,

									events: function () {
										return _.extend( {}, modal_base.base.prototype.events(), {
											'click #tcb-sign-up-error-enabled': 'toggle_signup_error_editor'
										} );
									},

									has_fixed_footer: function () {
										return true;
									},

									_get_type: function () {
										return this.type;
									},

									_get_signup_error_editor: function () {

										if ( ! this.$signup_error_editor ) {
											this.$signup_error_editor = this.$( '#tcb-lg-signup-error-editor' );
										}

										return this.$signup_error_editor;
									},

									toggle_signup_error_editor: function ( event ) {

										var self = this;
										this._get_signup_error_editor().toggle( {
											duration: 0,
											complete: function () {
												self.display_editor = event.currentTarget.checked;
											}
										} );
									},

									/**
									 * Used as render() function
									 * Loop through model arguments and append input to fields container
									 */
									render_errors: function () {

										this._get_fields_container().empty();

										this._get_signup_error_wrapper()[this._get_type() === 'api' ? 'show' : 'hide']();

										if ( this.display_editor ) {
											this.$( '#tcb-sign-up-error-enabled' ).prop( 'checked', true );
											this._get_signup_error_editor().show();
										}
										this._set_editor_content( this.custom_messages['error'] || '' );

										_.each( this.model.attributes, function ( error, key, object ) {
											this.render_error( {
												key: key,
												value: error,
												label: this.labels[key]
											} )
										}, this );
									},

									get_editor: function () {

										if ( ! this.editor ) {
											this.editor = tinymce.get( 'tcb_lg_error' );
										}

										return this.editor;
									},

									get_editor_content: function () {

										return this.get_editor() ? this.get_editor().getContent() : '';
									},

									_set_editor_content: function ( content ) {

										return this.get_editor() ? this.get_editor().setContent( content ) : false;
									},

									/**
									 * reset model to defaults and re-render the errors
									 */
									restore_defaults: function () {

										_.each( this.default_errors, function ( error, key, obj ) {
											this._set( key, error );
										}, this );

										this.render_errors();
									},

									/**
									 * callback when an input triggers change event
									 * @param event
									 * @param input
									 */
									change: function ( event, input ) {

										var _value = input.value,
											key = input.getAttribute( 'data-key' );

										this._set( key, _value );
									},

									/**
									 * Set model property
									 *
									 * @param key
									 * @param value
									 *
									 * @returns {boolean} false when model does not have prop defined
									 */
									_set: function ( key, value ) {

										this.model.set( key, value );

										return true;
									},

									/**
									 * cache for fields wrapper(container)
									 */
									_get_fields_container: function () {

										if ( ! this.$container ) {
											this.container = this.$( '.tcb-fields-error' ).first();
										}

										return this.container;
									},

									_get_signup_error_wrapper: function () {

										if ( ! this.$signup_error_wrapper ) {
											this.$signup_error_wrapper = this.$( '#tcb-signup-error-wrapper' );
										}

										return this.$signup_error_wrapper;
									},

									render_error: function ( item ) {

										var tpl = TVE.tpl( 'lead-generation/errors/item' ),
											_defaults = {
												key: 'key',
												label: 'label',
												value: 'value'
											};

										item = item || {};
										item = _.extend( _defaults, item );

										this._get_fields_container().append( '<div class="col-xs-6">' + tpl( {item: item} ) + '</div>' );
									}

								}, {
									get_instance: function ( el, model ) {
										if ( ! _instance ) {
											_instance = new TVE.LGErrorMessages( {
												el: el,
												model: model || new Backbone.Model()
											} );
										}

										return _instance;
									}
								} );
							},
							"lg-submit-options.js": function (exports, module, require) {
								/**
								 * Created by dan bilauca on 7/3/2017.
								 */

								var modal_base = require( './base' ),
									autocomplete = require( '../controls/link' ),
									_instance = null;

								module.exports = modal_base.base.extend( {

									initialize: function () {
										modal_base.base.prototype.initialize.apply( this, arguments );

										this.listenTo( this.model, 'change:submit_option', this.render_option_form );
									},

									events: function () {

										return _.extend( {}, modal_base.base.prototype.events(), {
											'click .tcb-optin-option-card': 'select_option'
										} );
									},

									/**
									 * when a option card is clicked
									 */
									select_option: function ( event ) {

										this.$el.find( '.tcb-optin-option-card' ).removeClass( 'tcb-card-selected' );

										event.currentTarget.classList.add( 'tcb-card-selected' );

										this.model.set( 'submit_option', event.currentTarget.dataset.key );
									},

									/**
									 * render option form
									 * calls dynamically form method
									 * triggers an event on this
									 */
									render_option_form: function ( model, new_value ) {

										this.$( '#tcb-lg-success-message-editor' ).hide( 0 );

										var method = 'render_form_' + new_value;

										/**
										 * on this event Thrive Leads should hook in and render its form
										 * when user picks the change state option from options list
										 */
										var event = jQuery.Event( 'lead_generation_submit_option.tcb' );
										event.to_implement = method;
										event.model = this.model;

										this.trigger( event );

										if ( event.isPropagationStopped() ) {
											return this;
										}

										if ( typeof this[method] === 'function' ) {
											return this[method]();
										}

										console.log( this.model );
										throw new Error( method + ' not implemented' );
									},

									/**
									 * render form for message option
									 */
									render_form_message: function () {

										/**
										 * hide form and display the wp_editor for this option
										 */
										this._get_form_wrapper().empty().hide();

										this.$( '#tcb-lg-success-message-editor' ).show( 0 );
									},

									/**
									 * render form for redirect option
									 */
									render_form_redirect: function () {

										/**
										 * hide editor in case it is visible
										 */
										this.$( '#tcb-lg-success-message-editor' ).hide( 0 );

										var self = this,
											view = new autocomplete( {
												hide_preview: true
											} );

										view.set_link( this.model.get( 'back_url' ) );

										this._get_form_wrapper().append( view.$el ).show( 0 );

										view.on( 'directurl', function ( request ) {
											self.model.set( 'back_url', request.term );
										} );
										view.on( 'select', function ( item ) {
											self.model.set( 'back_url', item.url );
										} );

										return this;
									},

									has_fixed_footer: function () {

										return true;
									},

									/**
									 * get the tinymce editor used for success message
									 */
									get_editor: function () {

										if ( ! this.editor ) {
											this.editor = tinymce.get( 'tcb_lg_success_message' );
										}

										return this.editor;
									},

									/**
									 * get the tinymce editor content
									 */
									get_editor_content: function () {

										return this.get_editor() ? this.get_editor().getContent() : '';
									},

									/**
									 * render options cards and form for selected option
									 */
									render_options: function () {

										/**
										 * empty the form wrapper to be able to render the form for selected option
										 */
										this._get_form_wrapper().empty();

										/**
										 * empty the options wrapper to render them again
										 */
										this._get_options_wrapper().empty();

										/**
										 * render options cards
										 */
										this.collection.each( function ( model, index, array ) {
											this._get_options_wrapper().append( this.render_option( model ) );
										}, this );

										/**
										 * of there is an option selected then render its form
										 */
										var selected_model = this.collection.findWhere( {key: this.model.get( 'submit_option' )} );

										if ( selected_model instanceof Backbone.Model ) {
											this.render_option_form( this.model, this.model.get( 'submit_option' ) );
										}

										if ( this.model.get( 'submit_option' ) === 'message' ) {
											this.get_editor().setContent( this.model.get( 'custom_messages' ).success || '' );
										}
									},

									/**
									 * render option card
									 */
									render_option: function ( model ) {

										var tpl = TVE.tpl( 'lead-generation/submit-options/card' ),
											key = model.get( 'key' );

										return tpl( {item: model, selected: key === this.model.get( 'submit_option' )} );
									},

									/**
									 * form wrapper where to append all the forms html
									 */
									_get_form_wrapper: function () {

										if ( ! this.$form_wrapper ) {
											this.$form_wrapper = this.$( '#tcb-lg-submit-options-form-wrapper' );
										}

										return this.$form_wrapper;
									},

									/**
									 * Placeholder for all option cards
									 *
									 * @returns {*}
									 * @private
									 */
									_get_options_wrapper: function () {

										if ( ! this.$options_wrapper ) {
											this.$options_wrapper = this.$( '#tcb-lg-submit-options-wrapper' );
										}

										return this.$options_wrapper;
									}

								}, {

									get_instance: function ( el, model ) {

										if ( ! _instance ) {
											_instance = new TVE.LGSubmitOptions( {
												el: el,
												model: model || new Backbone.Model()
											} );
										}

										return _instance;
									}
								} );
							},
							"options-post-types.js": function (exports, module, require) {
								module.exports = require( './base' ).base.extend( {
									save: function () {
										var params = TVE.ajax_data( 'save_link_post_types', 'post', {post_types: this.checkbox_values( '.post-type' )} );
										jQuery.ajax( params ).done( function ( response ) {
											TVE.page_message( response.message );
										} );
										this.close();
									}
								} );
							},
							"page-events.js": function (exports, module, require) {
								(function ( $ ) {
									var ViewBase = require( './base' ).base,
										formView, dataStore,
										triggers = [];

									var Form = ViewBase.extend( {
										template: TVE.tpl( 'page-events/form' ),
										main: null,
										after_initialize: function ( attr ) {
											this.main = attr.main;
										},
										render: function () {
										},
										reset: function ( eventModel ) {
											if ( typeof eventModel === 'undefined' ) {
												eventModel = dataStore.newEvent();
											}
											this.model = eventModel;

											return this;
										},
										has_multiple_actions: function () {
											var cnt = 0;
											$.each( dataStore.actions, function ( key, item ) {
												if ( ! item.disabled ) {
													cnt ++;
												}
											} );

											return cnt > 1;
										},
										state: function ( state ) {
											if ( state === 'action' && this.model && ! this.model.a && ! this.has_multiple_actions() ) {
												this.model.a = 'thrive_lightbox';
											}

											this.$el.html( this.template() );
											this.$( '.form-state' ).hide().filter( '.state-' + state ).show();

											if ( this['render_' + state] ) {
												this['render_' + state]();
											}
										},
										get_triggers: function () {
											return dataStore.triggers;
										},
										get_actions: function () {
											return dataStore.actions;
										},
										render_trigger: function () {
											if ( this.model.t ) {
												var view = dataStore.triggers[this.model.t].view;
												view.model = this.model;
												view.setElement( this.$( '#trigger-settings' ) );
												view.render();
												this.toggle_continue( true );
											}
										},
										render_action: function () {
											if ( this.model.a && dataStore.actions[this.model.a].view ) {
												var view = dataStore.actions[this.model.a].view;
												view.model = this.model;
												view.parent = this;
												view.setElement( this.$( '#action-settings' ) );
												view.render();
											}
										},
										toggle_continue: function ( state ) {
											this.$( '.form-step-action .continue' )[state ? 'show' : 'hide']();
										},
										item_select: function ( e ) {
											var field = e.currentTarget.getAttribute( 'data-field' );
											this.model[field] = e.currentTarget.getAttribute( 'data-item' );
											this.state( field === 't' ? 'trigger' : 'action' );
										},
										trigger_cancel: function () {
											this.model.config = {};
											this.model.t = '';
											if ( ! dataStore.hasEvents() ) {
												this.state( 'default' );
											} else {
												this.main.dashboard();
											}
										},
										trigger_continue: function () {
											this.state( 'action' );
										},
										action_cancel: function () {
											this.model.a = '';
											this.state( 'trigger' );
										},
										action_continue: function () {
											var result = dataStore.validate( this.model );
											if ( result !== true ) {
												return this.show_error( result );
											}
											dataStore.save( this.model );
											this.main.dashboard();
										},
										show_error: function ( error ) {
											this.$( '.form-step-action' ).find( '.inline-message' ).remove().end().append( '<div style="bottom:-35px;right:0" class="tcb-absolute inline-message m-error tcb-text-right">' + error + '</div>' );
										},
										can_add_events: function () {
											return dataStore.events.length < 4;
										}
									} );

									module.exports = ViewBase.extend( {
										options: {
											opacity: .8,
											css: {
												'padding-bottom': '120px'
											}
										},
										before_initialize: function () {
											dataStore = new DataStore( TVE.CONST.page_events );
											formView = new Form( {
												main: this
											} );

											this.$el.addClass( 'medium-small' );
										},
										render: function () {
											this.dashboard();

											return this;
										},
										after_open: function () {

										},
										dashboard: function () {
											formView.setElement( this.$( '#events-form' ) );

											if ( ! dataStore.hasEvents() ) {
												this.$( '.modal-header' ).html( TVE.tpl( 'page-events/no-events' )() );
												formView.reset( dataStore.newEvent() ).state( 'trigger' );

												return this;
											}

											this.$( '.modal-header' ).html( TVE.tpl( 'page-events/list' )( {
												view: this,
												dataStore: dataStore
											} ) ).show();
											formView.state( 'default' );
										},
										render_action_preview: function ( evt ) {
											var view = dataStore.actions[evt.a].view;
											if ( view ) {
												return view.render_preview( evt );
											}
										},
										_show_form: function ( model ) {
											if ( dataStore.hasEvents() ) {
												this.$( '.modal-header' ).hide();
											}
											formView.reset( model ).state( 'trigger' );
										},
										add_event: function () {
											this._show_form( dataStore.newEvent() );
											return false;
										},
										edit_event: function ( e ) {
											var item = e.currentTarget;
											this._show_form( dataStore.getEvent( item.getAttribute( 'data-index' ) ) );
										},
										delete_event: function ( e ) {
											var item = e.currentTarget;
											dataStore.removeEvent( item.getAttribute( 'data-index' ) );
											this.dashboard();
										}
									} );

									function DataStore( page_events ) {
										this.events = page_events;
										this.triggers = TVE.apply_filters( 'tcb_page_event_triggers', {
											'exit': {
												label: 'Exit intent',
												icon: 'exit_intent',
												view: (new ExitTrigger())
											},
											'timer': {
												label: 'Timer',
												icon: 'timer',
												tpl: 'page-events/triggers/timer',
												view: (new TimerTrigger())
											}
										} );

										this.actions = TVE.apply_filters( 'tcb_page_event_actions', {
											'thrive_lightbox': {
												label: 'Open Thrive Lightbox',
												icon: 't-lightbox',
												view: (new ThriveLightbox())
											},
											'thrive_leads_2_step': {
												label: 'Open Thrive Leads ThriveBox',
												icon: 't-box',
												disabled: true,
												view: null
											}
										}, ThriveLightbox );

										this.animations = TVE.Components.animation.options.actions.thrive_lightbox.data.animations;
									}

									DataStore.prototype.newEvent = function () {
										return {
											t: '',
											a: '',
											config: {}
										};
									};

									DataStore.prototype.validate = function ( model ) {
										if ( ! this.events.length ) {
											return true;
										}
										var valid = true;
										_.each( this.events, function ( evt, index ) {
											if ( evt.a === model.a && evt.t === model.t && index !== model.event_index ) {
												valid = false;
											}
										} );
										return valid ? true : TVE.t.page_event_action_duplicate;
									};

									DataStore.prototype.save = function ( event ) {

										if ( typeof event.event_index === 'undefined' ) {
											this.events.push( event );
										} else {
											var index = event.event_index;
											delete event.event_index;
											this.events.splice( index, 1, event );
										}

										return this.events;
									};

									DataStore.prototype.removeEvent = function ( index ) {
										index = parseInt( index );
										this.events.splice( index, 1 );
									};

									DataStore.prototype.getEvent = function ( index ) {
										index = parseInt( index );
										return $.extend( true, {event_index: index}, this.events[index] );
									};

									DataStore.prototype.hasEvents = function () {
										return this.events.length > 0;
									};

									var ExitTrigger = ViewBase.extend( {
										template: TVE.tpl( 'page-events/triggers/exit' ),
										enable_mobile: function ( e ) {
											this.model.config.e_mobile = e.currentTarget.checked ? 1 : 0;
											this.render();
										},
										slider_update: function ( e ) {
											var target = e.currentTarget,
												value = parseInt( target.value || 0 );
											if ( isNaN( value ) || value < 1 ) {
												value = 0;
											}
											if ( value > 300 ) {
												value = 300;
											}
											target.value = value;
											this.$( target.getAttribute( 'data-target' ) ).val( value );
											this.model.config[target.getAttribute( 'data-config' )] = value;
										},
										initialize: function () {
										},
										render: function () {
											this.$el.html( this.template( {m: this.model} ) );

											return this;
										}
									} );

									var TimerTrigger = ExitTrigger.extend( {
										template: TVE.tpl( 'page-events/triggers/timer' )
									} );

									var ThriveLightbox = ViewBase.extend( {
										template: TVE.tpl( 'page-events/actions/lightbox' ),
										render: function () {
											if ( ! this.model ) {
												return this;
											}

											if ( ! this.model.config.l_anim ) {
												this.model.config.l_anim = 'instant';
											}
											this.$el.html( this.template() );

											var $select = this.$( '#evt-lightbox' );
											if ( $select.length && (! this.model.config.l_id || String( this.model.config.l_id ) !== $select.val()) ) {
												this.model.config.l_id = $select.val();
											}

											this.parent.toggle_continue( $select.length );

											return this;
										},
										lightbox_change: function ( e ) {
											this.model.config.l_id = $( e.currentTarget ).val();
										},
										animation_change: function ( e ) {
											this.model.config.l_anim = $( e.currentTarget ).val();
										},
										get: function () {
											return TVE.Components.animation.options.actions.thrive_lightbox.data.lightboxes;
										},
										create_lightbox_toggle: function ( e ) {
											var $link = $( e.currentTarget );
											this.$( '.form-create-lb' ).toggle();
											$link.toggleClass( 'expanded' );
											$link.text( $link.hasClass( 'expanded' ) ? TVE.t.cancel : TVE.t.create_new_lightbox );
											this.$( '.create-lb' ).focus();
										},
										create_lightbox: function () {
											var $title = this.$( '.create-lb' ).removeClass( 'has-error' ),
												$form = this.$( '.form-create-lb' ),
												self = this;
											if ( ! $.trim( $title.val() ) ) {
												$title.addClass( 'has-error' ).focus();
												return;
											}
											$form.addClass( 'loading' );
											TVE.ajax( 'create_lightbox', 'post', {
												title: $title.val(),
												post_id: TVE.CONST.post.ID
											} ).done( function ( response ) {
												TVE.Components.animation.options.actions.thrive_lightbox.data.lightboxes.push( response.lightbox );
												TVE.page_message( response.message );
												self.render();
												self.$( '#evt-lightbox' ).val( response.lightbox.id ).trigger( 'change' );
											} ).always( function () {

											} );
										},
										get_edit_link: function ( l_id ) {
											var link = '';
											$.each( this.get(), function ( i, lb ) {
												if ( lb.id == l_id ) {
													link = lb.edit_url;
												}
											} );

											return link;
										},
										render_preview: function ( evt ) {
											return TVE.tpl( 'page-events/actions/lightbox-preview' )( {
												label: dataStore.actions[evt.a].label,
												edit_url: this.get_edit_link( evt.config.l_id ),
												animation: dataStore.animations[evt.config.l_anim || 'instant'],
												event: evt,
												view: this
											} );
										}
									} );

								})( jQuery );
							},
							"revision.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 3/16/2017.
								 */
								var modalBase = require( './base' ),
									_instance = null;

								module.exports = modalBase.base.extend( {
									template_item: TVE.tpl( 'controls/revision-manager-item' ),
									/**
									 * Constructor
									 */
									collection: null,
									initialize: function () {
										this.collection = new Backbone.Collection( tcb_main_const.revisions );

										this.listenTo( this.collection, 'reset', this.render );
										this.render();
									},
									render: function () {
										this.$( '#tcb-revision-list' ).empty();
										this.collection.each( this.renderOne, this );
									},
									/**
									 * Render one revision item
									 *
									 * @param item
									 * @returns {exports}
									 */
									renderOne: function ( item, index ) {
										this.$( '#tcb-revision-list' ).append( this.template_item( {model: item, index: index} ) );
										return this;
									},
									/**
									 * Click callback for "Restore Revision" lnk
									 *
									 * @param event
									 * @param dom
									 * @returns {boolean}
									 */
									clicked: function ( event, dom ) {
										event.preventDefault();

										var url = dom.getAttribute( 'href' );
										//TODO: add an overlay loader here
										jQuery.get( url, function () {
											window.parent.location.reload();
										} );

										return false;
									}
								}, {
									/**
									 * Reset revisions constant
									 *
									 * @param revisions
									 */
									reset_revisions: function ( revisions ) {

										if ( ! revisions instanceof Array ) {
											revisions = [];
										}

										if ( _instance ) {
											_instance.collection.reset( revisions );
										}
									},
									/**
									 * "Singleton" implementation for modal instance
									 *
									 * @param el
									 */
									get_instance: function ( el ) {
										if ( ! _instance ) {
											_instance = new TVE.RevisionManager( {
												el: el
											} );
										}

										return _instance;
									}
								} );
							},
							"testimonial.js": function (exports, module, require) {
								var modalBase = require( './base' ),
									_instance = null;

								module.exports = modalBase.base.extend( {
									item_template: TVE.tpl( 'testimonial/template' ),
									events: {
										'click .tcb-modal-save': 'choose',
										'click .tve-template-item .template-wrapper': function ( e ) {
											this.$( '.template-wrapper.active' ).removeClass( 'active' );
											e.currentTarget.classList.toggle( 'active' );
										},
										'mouseover .tve-template-item .template-thumbnail': 'show_preview',
										'mouseleave .tve-template-item .template-thumbnail': 'hide_preview',
										'click .tcb-modal-close': 'close'

									},
									render: function () {
										var self = this;
										this.$preview = this.$( '.tve-template-preview' );
										_.each( this.model.config.templates, function ( item, index ) {
											item.key = index;
											self.$( '.tve-default-templates-list .expanded-set' ).append( self.item_template( {item: item} ) );
										} );
									},
									choose: function () {
										this.model.change_template( this.$( '.template-wrapper.active' ).attr( 'data-key' ) );
										this.close();
									},
									/**
									 * After lightbox open callback
									 */
									after_open: function ( args ) {
										this.$( '.template-wrapper.active' ).removeClass( 'active' );
										this.$( '[data-key="' + this.model.get_current_template() + '"]' ).addClass( 'active' );
									},
									show_preview: function ( e ) {

										var target = e.currentTarget.getBoundingClientRect();
										this.$preview.css( {
											left: target.left - this.$el.position().left + target.width + 20,
											top: target.top - e.currentTarget.offsetHeight,
											'background-image': e.currentTarget.style.backgroundImage
										} );

										this.$preview.show();
									},
									hide_preview: function ( e ) {
										this.$preview.hide();
									}
								}, {
									/**
									 * "Singleton" implementation for modal instance
									 *
									 * @param el
									 */
									get_instance: function ( el, component ) {

										if ( ! _instance ) {
											_instance = new TVE.TestimonialStyles( {
												el: el,
												model: component
											} );

										}
										return _instance;
									}
								} )
								;
							},
							"wordpress-content.js": function (exports, module, require) {
								/**
								 * Created by Ovidiu on 4/10/2017.
								 */
								var modalBase = require( './base' ),
									_instance = null,
									content_manager = require( '../../../editor/src/util/content' );

								module.exports = modalBase.base.extend( {
									/**
									 * Save method that is triggered from
									 * Wordpress Shortcode "Save" Button inside the modal window
									 */
									save: function () {
										var self = this,
											$target = TVE.ActiveElement,
											code = $target.find( '.tve_shortcode_raw' ),
											content = $target.find( '.tve_shortcode_rendered' ),
											post_data = {
												content: content_manager.get_shotcode_tinymce_content()
											};

										if ( post_data.content.length === 0 ) {
											TVE.page_message( TVE.t.emptyContent, true );
											return;
										}

										this.$save_button.addClass( 'tve-disabled' );

										if ( code.length === 0 ) {
											$target.empty();
											code = jQuery( '<div class="tve_shortcode_raw" style="display: none"></div>' ).appendTo( $target );
											content = jQuery( '<div class="tve_shortcode_rendered"></div>' ).appendTo( $target );
										}

										code.html( '___TVE_SHORTCODE_RAW__' + post_data.content + '__TVE_SHORTCODE_RAW___' );

										TVE.ajax( 'render_shortcode', 'post', post_data )
										   .done( function ( data ) {
											   $target.removeClass( 'tcb-elem-placeholder' );
											   content.html( data.response );
											   if ( (content.children().length && content.outerHeight() === 0) || content.children().length === 0 ) {
												   content.append( '<div class="tve_shortcode_overlay"><span>No preview available. Please save and reload the page.</span></div>' );
											   }

											   /*Trigger Click on Active Element to Display the WordPress Content Options in the sidebar*/
											   $target.trigger( 'click' );

											   TVE.page_message( data.text );
											   self.close();
										   } )
										   .always( function ( data ) {
											   self.$save_button.removeClass( 'tve-disabled' );
										   } );

									},
									/**
									 * After lightbox open callback
									 */
									after_open: function ( args ) {
										this.$save_button = this.$( '.tcb-modal-save' );
										jQuery( '.tvd-lean-overlay' ).addClass( 'tcb-modal-wordpress-content-overlay' );

										var content = TVE.ActiveElement.find( '> .tve_shortcode_raw' ).html();
										if ( typeof content === 'undefined' ) {
											content = '';
										} else {
											content = content.replace( '___TVE_SHORTCODE_RAW__', '' ).replace( '__TVE_SHORTCODE_RAW___', '' )
										}

										content_manager.set_shotcode_tinymce_content( content );
									}
								}, {
									/**
									 * "Singleton" implementation for modal instance
									 *
									 * @param el
									 */
									get_instance: function ( el ) {
										if ( ! _instance ) {
											_instance = new TVE.WordPressContent( {
												el: el
											} );
										}

										return _instance;
									}
								} );
							}
						},
						"sidebar-settings.js": function (exports, module, require) {
							(function ( $ ) {

								var Base = require( './base' ),
									ImagePicker = require( '../libs/file-picker' ),
									Modal = require( './modals/base' ),
									lp_templates = require( './modals/landing-page' ),
									custom_css, edit_html, exportLP, saveTemplate, saveTemplateLP;

								module.exports = Base.base_view.extend( {
									initialize: function () {
										this.$body = $( 'body' );

										this.$tabs = this.$( '.tve-tab' );
										this.$settings = this.$( '.settings-list' );

										this.$reminders = this.$( '[data-setting="reminders"]' );
										this.$reminders.find( 'span' ).text( TVE.CONST.tve_display_save_notification === 1 ? 'Off' : 'On' );

										custom_css.init();
										edit_html.init();

										this.export_lp_modal = new exportLP();
										this.lp_templates = new lp_templates();

										this.save_template_lp_modal = new saveTemplateLP( {'landing_page_templates': this.lp_templates} );
										this.save_template_modal = new saveTemplate();

										this.landing_page_settings( TVE.CONST.landing_page.trim().length > 0 );
									},
									tab_click: function ( event, dom ) {
										this.show_tab( dom.getAttribute( 'data-list' ) );
									},
									show_tab: function ( tab ) {
										this.$tabs.removeClass( 'active' );
										this.$tabs.filter( '[data-list="' + tab + '"]' ).addClass( 'active' );

										this.$settings.hide();
										this.$settings.filter( '[data-list="' + tab + '"]' ).show();
									},
									landing_page_settings: function ( is_landing_page ) {
										this.$( '.settings-list[data-list="templates"] .setting-item' ).show();
										var $not_lp_options = this.$( '.settings-list[data-list="templates"] .setting-item.not-lp' );
										/* show all settings but some of them if a template is not selected */
										if ( ! is_landing_page && (TVE.CONST.post_type === 'post' || TVE.CONST.post_type === 'page') ) {
											this.$( '.settings-list[data-list="templates"] .setting-item.lp-only' ).hide();
											$not_lp_options.show();
										} else {
											$not_lp_options.hide();
										}
									},
									setting: function ( event, dom ) {
										var func = dom.getAttribute( 'data-setting' );

										if ( typeof this[func] === 'function' ) {
											this[func]( event, dom );
										}
									},
									/**
									 * Open the Page Event Manager modal
									 */
									page_events: function () {
										TVE.modal_open( 'page-events' );
									},
									custom_css: function ( event, dom ) {
										custom_css.open();
									},
									/**
									 * Edit editor HTML code
									 */
									edit_html: function () {
										edit_html.open();
									},
									reminders: function () {

										TVE.CONST.tve_display_save_notification = Math.abs( parseInt( TVE.CONST.tve_display_save_notification ) - 1 );

										TVE.main.overlay();

										var $element = this.$reminders.find( 'span' ),
											data = {
												option_name: 'tve_display_save_notification',
												option_value: TVE.CONST.tve_display_save_notification
											};

										TVE.ajax( 'update_option', 'post', data ).done( function ( response ) {
											TVE.main.overlay( 'close' );

											if ( TVE.CONST.tve_display_save_notification ) {
												TVE.Editor_Page.enableSaveWarning();
												TVE.page_message( "Save Reminders are turned On", false, 3000 );
											} else {
												TVE.Editor_Page.disableSaveWarning();
												TVE.page_message( "Save Reminders are turned Off", false, 3000 );
											}

											$element.text( TVE.CONST.tve_display_save_notification === 1 ? 'Off' : 'On' );
										} );
									},
									editor_side: function () {
										TVE.CONST.cpanel_attr.position = this.$body.hasClass( 'tve-left-side' ) ? 'right' : 'left';

										this.$body.removeClass( 'tve-left-side tve-right-side' ).addClass( 'tve-' + TVE.CONST.cpanel_attr.position + '-side' );
										TVE.main.panel_offset();

										TVE.ajax( 'editor_display_config', 'post', {
											attribute: 'position',
											value: TVE.CONST.cpanel_attr.position
										} );
									},
									lp_settings: function () {
										var $body = TVE.inner.$body.removeClass( 'edit_mode' );
										TVE.Editor_Page.focus_element( $body );
									},
									save_template_lp: function () {
										this.save_template_lp_modal.reset();
										this.save_template_lp_modal.open();
									},

									save_template: function () {
										this.save_template_modal.reset();
										this.save_template_modal.open();
									},

									change_lp: function () {
										this.lp_templates.$filter.hide();
										this.lp_templates.open();
									},
									import_lp: function () {
										/* confirm before importing to warn user that he will loose changes */
										if ( ! this.tve_lp_import_confirmed && ! confirm( TVE.t.LPImportConfirm ) ) {
											return false;
										}

										/* remember the confirm */
										this.tve_lp_import_confirmed = true;

										if ( this.lp_import_frame ) {
											this.controls.lp_import_frame.open();
											return;
										}

										this.lp_import_frame = wp.media.frames.file_frame = wp.media( {
											title: 'Import Landing Page',
											button: {
												text: 'Import'
											},
											multiple: false,
											frame: 'select',
											library: {
												type: 'application/zip'
											}
										} );

										var self = this;

										this.lp_import_frame.on( 'select', function () {
											var file = self.lp_import_frame.state().get( 'selection' ).first().toJSON();

											if ( file.mime !== 'application/zip' ) {
												TVE.page_message( 'Only .zip files are allowed', true );
												self.lp_import_frame.open();
												return;
											}

											/* send the AJAX post request to unzip and import the lading page */
											TVE.main.overlay();
											$.post( TVE.CONST.ajax_url, {
												attachment_id: file.id,
												action: 'tve_lp_import',
												page_id: TVE.CONST.post_id
											}, function ( response ) {
												if ( ! response.success ) {
													TVE.main.overlay( true );
													TVE.page_message( response.message, true, 8000 );
													self.lp_import_frame.open();
													return;
												}
												window.onbeforeunload = null;
												top.window.location.href = response.url;
											}, 'json' ).fail( function ( r ) {
												TVE.main.overlay( true );
												TVE.page_message( TVE.t.UnknownError + r.responseText, true, 10000 );
												self.lp_import_frame.open();
											} ).always( function () {
											} );
										} );

										this.lp_import_frame.open();
									},
									export_lp: function () {
										this.export_lp_modal.reset();
										this.export_lp_modal.open();
									},
									revert: function ( skip_confirm ) {
										if ( ! (typeof skip_confirm !== 'undefined' && skip_confirm === 'skip_confirm' ) && ! confirm( TVE.t.DeleteContentInLandingPage ) ) {
											return false;
										}

										var data = {
											tve_landing_page: '',
											custom_action: 'landing_page'
										}, self = this;
										TVE.main.overlay();
										TVE.set_login_callback( function () {
											this.revert( 'skip_confirm' );
										}, this );
										TVE.Editor_Page.save( false, function () {
											window.onbeforeunload = null;
											top.window.location.reload();
										}, data );
									},
									reset: function ( skip_confirm ) {
										if ( ! (typeof skip_confirm !== 'undefined' && skip_confirm === 'skip_confirm' ) && ! confirm( TVE.t.ClearContentOfLandingPage ) ) {
											return false;
										}

										var data = {
											custom_action: 'landing_page_reset'
										};
										TVE.main.overlay();
										TVE.set_login_callback( function () {
											this.reset( 'skip_confirm' );
										}, this );
										TVE.Editor_Page.save( false, function () {
											window.onbeforeunload = null;
											TVE.iframe_refresh();
										}, data );
									},
									/**
									 * Open the control panel for editing general stuff for a Thrive Lightbox
									 */
									lightbox_settings: function () {
										TVE.Editor_Page.focus_element( TVE.inner_$( '.tve_p_lb_content' ) );
									}
								} );

								custom_css = {
									init: function () {
										this.$code = $( '.tve-custom-code-wrapper' );

										this.$code.find( '.code-expand' ).click( $.proxy( this.expand, this ) );
										this.$code.find( '.code-close' ).click( $.proxy( this.close, this ) );

										this.editor = ace.edit( 'tve-custom-css-code' );
										this.editor.setTheme( 'ace/theme/monokai' );
										this.editor.session.setMode( 'ace/mode/css' );
										this.editor.setPrintMarginColumn( 1000 );

										this.set();

										this.close();

										return this;
									},
									set: function () {
										this.editor.setValue( TVE.Editor_Page.get_custom_css(), 1 );
									},
									save: function () {
										TVE.Editor_Page.add_custom_css( this.editor.getValue() );
									},
									open: function () {
										this.$code.show();
										this.editor.focus();
									},
									close: function () {
										this.save();
										this.$code.hide();
									},
									expand: function () {
										this.$code.toggleClass( 'full-width' );
										this.editor.resize();
									}
								};

								edit_html = {
									init: function () {
										this.$htmlCode = $( '.tve-editor-html-wrapper' );

										this.$htmlCode.find( '.code-button-close' ).click( $.proxy( this.close, this ) );
										this.$htmlCode.find( '.code-button-check' ).click( $.proxy( this.save, this ) );

										this.htmlEditor = ace.edit( 'tve-custom-html-code' );
										this.htmlEditor.setTheme( 'ace/theme/monokai' );
										this.htmlEditor.session.setMode( 'ace/mode/html' );
										this.htmlEditor.session.setUseWrapMode( true );

										this.close();

										return this;
									},
									open: function () {
										this.htmlEditor.setValue( TVE.inner.jQuery( '#tve_editor' ).html(), 1 );
										this.$htmlCode.show();
										this.htmlEditor.focus();
									},
									save: function () {
										TVE.inner.jQuery( '#tve_editor' ).html( this.htmlEditor.getValue() );
										this.close();
									},
									close: function () {
										this.$htmlCode.hide();
									}
								};

								exportLP = Modal.base.extend( {
									el: TVE.modal.get_element( 'export-lp' ),
									events: {
										'click .choose-image': function () {
											this.picker.open();
										},
										'click .remove-image': function () {
											this.thumbnail = '';
											this.$remove_image.hide();
											this.$preview.css( 'background-image', 'url("' + this.$preview.data( 'default' ) + '")' );
										},
										'click .tcb-modal-save': 'save',
										'click .tcb-modal-close': 'close'
									},
									initialize: function () {
										this.$template_name = this.$( '#tve-template-name' );
										this.picker = (new ImagePicker()).on_select( this.change_image, this );
										this.$remove_image = this.$( '.remove-image' );
										this.$preview = this.$( '.thumbnail-preview' );
										this.$el.addClass( 'medium-small' );
										this.reset();
									},
									reset: function () {
										this.thumbnail = '';
										this.$template_name.val( '' );
										this.$remove_image.hide();
										this.$preview.css( 'background-image', 'url("' + this.$preview.data( 'default' ) + '")' );
									},
									/**
									 * This also applies the srcset and sizes attributes
									 *
									 * @param thumb
									 */
									change_image: function ( thumb ) {
										this.thumbnail = thumb.id;
										this.$remove_image.show();
										this.$preview.css( 'background-image', 'url("' + thumb.url + '")' );
									},
									save: function () {
										var data = {
											action: 'tve_lp_export',
											post_id: TVE.CONST.post_id,
											template_name: this.$template_name.val().trim(),
											thumb_id: this.thumbnail
										}, self = this;

										if ( data.template_name.length === 0 ) {
											TVE.page_message( TVE.t.ExportFileNameRequired, true, 5000 );
											return false;
										}

										TVE.main.overlay();

										TVE.set_login_callback( this.save, this );

										TVE.Editor_Page.save( true, function ( response ) {
											self.close();
											TVE.page_message( response.message, false, 8000 );
											TVE.main.overlay( 'close' );
											window.top.location.href = response.url;
										}, data );
									}
								} );

								saveTemplateLP = Modal.base.extend( {
									el: TVE.modal.get_element( 'save-template-lp' ),
									events: {
										'click .tcb-modal-save': 'save',
										'click .tcb-modal-close': 'close',
										'click .tve-add-tag': 'add_tag',
										'keydown .tve-new-tag-name': function ( e ) {
											if ( e.keyCode === 13 ) {
												this.add_tag();
											}
										},
										'click .close-icon': function ( e ) {
											$( e.currentTarget ).parent().remove();
										}
									},
									initialize: function ( args ) {
										this.lp_templates = args.landing_page_templates;

										this.$tag_input = this.$( '.tve-new-tag-name' );
										this.$tag_list = this.$( '.tve-tags-list' );
										this.$template_name = this.$( '#tve-template-name' );

										this.tags = [];

										this.$el.addClass( 'medium-small' );
									},
									add_tag: function () {
										var tag = this.$tag_input.val().trim();

										this.$tag_input.val( '' );

										if ( tag === '' || this.tags.indexOf( tag ) !== - 1 ) {
											return;
										}

										this.tags.push( tag );
										this.$tag_list.append( '<div class="tag" data-tag="' + tag + '">' + tag + '<span class="close-icon"></span></div>' )
									},
									save: function () {
										var data = {
												tve_landing_page_save: this.$template_name.val(),
												tve_landing_page: TVE.CONST.landing_page,
												template_tags: this.$tag_list.find( '.tag' ).map( function () {
													return this.getAttribute( 'data-tag' );
												} ).get()
											},
											self = this;

										if ( data.tve_landing_page_save.length === 0 ) {
											TVE.page_message( TVE.t.EnterTemplateName, true, 5000 );
											return;
										}
										TVE.main.overlay();
										TVE.set_login_callback( this.save, this );
										TVE.Editor_Page.save( false, function ( response ) {
											TVE.main.overlay( 'close' );
											TVE.page_message( TVE.t.PageTemplateSave, false, 5000 );

											/*Update the saved landing page templates array and render the sets*/
											TVE.CONST.saved_lp_templates = response.saved_lp_templates;
											self.lp_templates._filter_templates();
											self.lp_templates.render_sets();

											self.close();
										}, data );
									},
									reset: function () {
										this.$tag_input.val( '' );
										this.$template_name.val( '' );
										this.$tag_list.empty();
										this.tags = [];
									}
								} );

								saveTemplate = Modal.base.extend( {
									el: TVE.modal.get_element( 'save-template' ),
									events: {
										'click .tcb-modal-save': 'save',
										'click .tcb-modal-close': 'close',
										'click .close-icon': function ( e ) {
											$( e.currentTarget ).parent().remove();
										}
									},
									initialize: function () {
										this.$template_name = this.$( '#tve-template-name' );
									},
									save: function () {
										var form = new FormData();
										TVE.main.overlay();
										form.append( 'template_name', this.$template_name.val() );
										form.append( 'template_content', TVE.Editor_Page.editor.html() );
										form.append( 'template_category', '[#page#]' );
										form.append( 'post_id', TVE.CONST.post_id );
										form.append( 'custom_css', TVE.Editor_Page.content_manager.get_stylesheet_rules() );
										form.append( 'media_rules', JSON.stringify( TVE.Editor_Page.editor.collect_head_css() ) );

										TVE.generateElementPreview( TVE.inner_$( '#tve_editor' ), this, this.execute_ajax, form );
									},
									/**
									 * Executes save page template ajax request
									 *
									 * @param $this
									 * @param form
									 */
									execute_ajax: function ( $this, form ) {
										form.append( 'custom', 'save_user_template' );
										form.append( 'action', TVE.CONST.ajax.action );
										form.append( 'nonce', TVE.CONST.nonce );

										jQuery.ajax( {
											type: 'POST',
											url: TVE.CONST.ajax_url,
											data: form,
											processData: false,
											contentType: false,
											success: function ( data ) {
												TVE.page_message( TVE.t.TemplateSave, false, 5000 );
												$this.close();
												TVE.CONST.content_templates = data.content_templates;
											},
											complete: function () {
												TVE.main.overlay( 'close' );
											},
											error: function ( error ) {
												TVE.page_message( error.responseJSON.message, 1 );
											}
										} );

									},
									reset: function () {
										this.$template_name.val( '' );
									}
								} );

							})( jQuery );
						}
					}
				}
			}
		}
	}
})("workspace/editor/js/main/views/main");
